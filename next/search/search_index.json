{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyInj","text":"<p>Type-safe dependency injection for Python 3.13+</p> <p>Status: Beta \u2014 Active development; breaking changes may occur between pre-releases. Pin exact versions in production.</p> <p>PyInj is a minimal, type-safe DI container focused on clarity and performance:</p> <ul> <li>Thread-safe and async-safe resolution</li> <li>O(1) lookups and cached injection metadata</li> <li>Circular dependency detection and safe cleanup</li> <li>Protocol-based type safety and auto-registration via metaclass</li> <li>Zero runtime dependencies</li> </ul>"},{"location":"#quick-install","title":"Quick Install","text":"<pre><code># uv (recommended)\nuv add pyinj\n\n# or pip\npip install pyinj\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from pyinj import Container, Token, Scope\n\ncontainer = Container()\n\nDB_TOKEN = Token[Database](\"database\")\ncontainer.register(DB_TOKEN, create_database, Scope.SINGLETON)\n\ndb = container.get(DB_TOKEN)\nawait container.dispose()\n</code></pre> <p>Continue with Getting Started for basic patterns and Usage for type-safe injection, metaclass auto-registration, and async lifecycles.</p>"},{"location":"advanced/","title":"Advanced","text":""},{"location":"advanced/#protocol-based-resolution","title":"Protocol-Based Resolution","text":"<pre><code>@container.inject\ndef business_logic(logger: Logger, db: Database) -&gt; str:\n    logger.info(\"Processing\")\n    return db.query(\"SELECT 1\")\n</code></pre>"},{"location":"advanced/#scopes","title":"Scopes","text":"<ul> <li>SINGLETON: one instance per container</li> <li>TRANSIENT: new instance per resolve</li> <li>REQUEST: request-bound lifetime</li> </ul>"},{"location":"advanced/#testing-and-overrides","title":"Testing and Overrides","text":"<pre><code>mock = Mock(spec=Logger)\ncontainer.override(logger_token, mock)\n...\ncontainer.clear_overrides()\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>This API reference is generated automatically from the source using mkdocstrings.</p>"},{"location":"api/#top-level-package","title":"Top-level package","text":"<p>PyInj - Type-safe dependency injection for modern Python.</p> <p>Status: Beta - APIs may change between pre-releases. Pin exact versions in production.</p> <p>Highlights: - Immutable tokens with pre-computed hashes (O(1) lookups) - ContextVar-based scoping for async and thread safety - <code>@inject</code> decorator (FastAPI-inspired) and lightweight markers - Scala-style \"given\" instances for ergonomic overrides - Zero runtime dependencies</p> Quick start <p>from pyinj import Container, Token, Scope</p> <p>container = Container() DB = TokenDatabase container.register(DB, create_database, scope=Scope.SINGLETON)</p> <p>db = container.get(DB)</p>"},{"location":"api/#pyinj--use-db","title":"... use db ...","text":""},{"location":"api/#pyinj.CircularDependencyError","title":"<code>CircularDependencyError</code>","text":"<p>               Bases: <code>ResolutionError</code></p> <p>Raised when a circular dependency is detected during resolution.</p> Source code in <code>src/pyinj/exceptions.py</code> <pre><code>class CircularDependencyError(ResolutionError):\n    \"\"\"Raised when a circular dependency is detected during resolution.\"\"\"\n\n    def __init__(self, token: Token, chain: list[Token]) -&gt; None:\n        \"\"\"Initialize circular dependency error.\n\n        Args:\n            token: The token that created the cycle\n            chain: The resolution chain showing the cycle\n        \"\"\"\n        super().__init__(\n            token,\n            chain,\n            f\"Circular dependency detected: {' -&gt; '.join(t.name for t in chain)} -&gt; {token.name}\",\n        )\n</code></pre>"},{"location":"api/#pyinj.CircularDependencyError.__init__","title":"<code>__init__(token, chain)</code>","text":"<p>Initialize circular dependency error.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>The token that created the cycle</p> required <code>chain</code> <code>list[Token]</code> <p>The resolution chain showing the cycle</p> required Source code in <code>src/pyinj/exceptions.py</code> <pre><code>def __init__(self, token: Token, chain: list[Token]) -&gt; None:\n    \"\"\"Initialize circular dependency error.\n\n    Args:\n        token: The token that created the cycle\n        chain: The resolution chain showing the cycle\n    \"\"\"\n    super().__init__(\n        token,\n        chain,\n        f\"Circular dependency detected: {' -&gt; '.join(t.name for t in chain)} -&gt; {token.name}\",\n    )\n</code></pre>"},{"location":"api/#pyinj.Container","title":"<code>Container</code>","text":"<p>               Bases: <code>ContextualContainer</code></p> <p>Ergonomic, type-safe DI container with async support.</p> <p>Features: - O(1) lookups with a compact registry - Thread/async-safe singleton initialization - Contextual scoping using <code>contextvars</code> (request/session) - Scala-inspired \"given\" instances for testability - Method chaining for concise setup and batch operations</p> Example <p>container = Container() LOGGER = TokenLogger container.register_singleton(LOGGER, ConsoleLogger)</p> <p>@inject def handler(logger: Inject[Logger]):     logger.info(\"hello\")</p> Source code in <code>src/pyinj/container.py</code> <pre><code>class Container(ContextualContainer):\n    \"\"\"Ergonomic, type-safe DI container with async support.\n\n    Features:\n    - O(1) lookups with a compact registry\n    - Thread/async-safe singleton initialization\n    - Contextual scoping using ``contextvars`` (request/session)\n    - Scala-inspired \"given\" instances for testability\n    - Method chaining for concise setup and batch operations\n\n    Example:\n        container = Container()\n        LOGGER = Token[Logger](\"logger\")\n        container.register_singleton(LOGGER, ConsoleLogger)\n\n        @inject\n        def handler(logger: Inject[Logger]):\n            logger.info(\"hello\")\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize enhanced container.\"\"\"\n        super().__init__()\n\n        # Token factory for convenient creation\n        self.tokens: TokenFactory = TokenFactory()\n\n        # Given instances (Scala-inspired)\n        self._given_providers: dict[type[Any], Provider] = {}\n\n        # Override less-precise base attributes with typed variants\n        self._providers: dict[Token[Any], Provider] = {}\n        self._token_scopes: dict[Token[Any], Scope] = {}\n        self._singletons: dict[Token[Any], Any] = {}\n        self._async_locks: dict[Token[Any], asyncio.Lock] = {}\n\n        # Performance metrics\n        self._resolution_times: deque[float] = deque(maxlen=1000)\n        self._cache_hits: int = 0\n        self._cache_misses: int = 0\n\n        # Thread safety\n        self._lock: threading.RLock = threading.RLock()\n        self._singleton_locks: dict[Token[Any], threading.Lock] = defaultdict(\n            threading.Lock\n        )\n\n        # Track dependencies for graph\n        self._dependencies: dict[Token[Any], set[Token[Any]]] = defaultdict(set)\n\n        # Per-context overrides (DI_SPEC requirement)\n        self._overrides: ContextVar[dict[Token[Any], Any] | None] = ContextVar(\n            \"pyinj_overrides\",\n            default=None,\n        )\n\n        # Thread-local resolution tracking for cycle detection\n        self._local = threading.local()\n\n    # ============= Internal Helpers (Phase 1) =============\n\n    def _coerce_to_token(self, spec: Token[Any] | type[Any]) -&gt; Token[Any]:\n        if isinstance(spec, Token):\n            return spec\n        if isinstance(spec, type):\n            for registered in self._providers:\n                if registered.type_ == spec:\n                    return registered\n            return Token(spec.__name__, spec)\n        # Disallow string-based tokens for type safety\n        raise TypeError(\n            \"Token specification must be a Token or type; strings are not supported\"\n        )\n\n    def _get_override(self, token: Token[Any]) -&gt; Any | None:\n        current = self._overrides.get()\n        if current and token in current:\n            return current[token]\n        return None\n\n    def _resolution_stack(self) -&gt; list[Token[Any]]:\n        stack = getattr(self._local, \"resolving\", None)\n        if not isinstance(stack, list):\n            new_stack: list[Token[Any]] = []\n            self._local.resolving = new_stack\n            return new_stack\n        return cast(list[Token[Any]], stack)\n\n    @contextmanager\n    def _resolution_guard(self, token: Token[Any]):\n        stack = self._resolution_stack()\n        if token in stack:\n            raise CircularDependencyError(token, list(stack))\n        stack.append(token)\n        try:\n            yield\n        finally:\n            stack.pop()\n\n    # ============= Registration Methods =============\n\n    def register(\n        self,\n        token: Token[Any] | type[Any],\n        provider: Provider,\n        scope: Scope | None = None,\n        *,\n        tags: tuple[str, ...] = (),\n    ) -&gt; Container:\n        \"\"\"Register a provider for a token.\n\n        Args:\n            token: A ``Token[T]`` or a concrete ``type[T]``. If a type is\n                provided, a token is created automatically.\n            provider: Callable that returns the dependency instance.\n            scope: Optional lifecycle override (defaults to token.scope or TRANSIENT).\n            tags: Optional tags for discovery/metadata.\n\n        Returns:\n            Self, to allow method chaining.\n\n        Example:\n            container.register(Token[DB](\"db\"), create_db, scope=Scope.SINGLETON)\n        \"\"\"\n        # Convert to Token if needed\n        if isinstance(token, type):\n            token = self.tokens.create(\n                token.__name__, token, scope=scope or Scope.TRANSIENT, tags=tags\n            )\n        elif scope is not None:\n            # Record desired scope without changing the token identity\n            self._token_scopes[token] = scope\n\n        # Validate provider\n        if not callable(provider):\n            raise TypeError(\n                f\"Provider must be callable, got {type(provider).__name__}\\n\"\n                f\"  Fix: Pass a function or lambda that returns an instance\\n\"\n                f\"  Example: container.register(token, lambda: {token.type_.__name__}())\"\n            )\n\n        with self._lock:\n            self._providers[token] = provider\n\n        return self  # Enable chaining\n\n    def register_singleton(\n        self, token: Token[Any] | type[Any], provider: Provider\n    ) -&gt; Container:\n        \"\"\"Register a singleton-scoped dependency.\"\"\"\n        return self.register(token, provider, scope=Scope.SINGLETON)\n\n    def register_request(\n        self, token: Token[Any] | type[Any], provider: Provider\n    ) -&gt; Container:\n        \"\"\"Register a request-scoped dependency.\"\"\"\n        return self.register(token, provider, scope=Scope.REQUEST)\n\n    def register_transient(\n        self, token: Token[Any] | type[Any], provider: Provider\n    ) -&gt; Container:\n        \"\"\"Register a transient-scoped dependency.\"\"\"\n        return self.register(token, provider, scope=Scope.TRANSIENT)\n\n    def register_value(self, token: Token[Any] | type[Any], value: Any) -&gt; Container:\n        \"\"\"Register a pre-created value as a singleton.\"\"\"\n        if isinstance(token, type):\n            token = self.tokens.singleton(token.__name__, token)\n        # token is now a Token[Any]\n\n        # Store directly as singleton\n        self._singletons[token] = value\n        return self\n\n    def override(self, token: Token[Any], value: Any) -&gt; None:\n        \"\"\"Override a dependency with a specific value for this container.\n\n        Prefer the ``use_overrides`` context manager for scoped overrides\n        in concurrent test scenarios.\n        \"\"\"\n        self._singletons[token] = value\n\n    # ============= Given Instances (Scala-inspired) =============\n\n    def given(self, type_: type[Any], provider: Provider | Any) -&gt; Container:\n        \"\"\"Register a given instance for a type (Scala-style).\"\"\"\n        if callable(provider):\n            self._given_providers[type_] = provider\n        else:\n            # Wrap value in lambda\n            self._given_providers[type_] = lambda p=provider: p\n\n        return self\n\n    def resolve_given(self, type_: type[T]) -&gt; T | None:\n        \"\"\"Resolve a given instance by type.\"\"\"\n        provider = self._given_providers.get(type_)\n        if provider:\n            return provider()\n        return None\n\n    @contextmanager\n    def using(self, **givens: Any) -&gt; Iterator[Container]:\n        \"\"\"Scala-style using clause for temporary givens.\"\"\"\n        old_givens = self._given_providers.copy()\n\n        # Add temporary givens\n        for type_name, instance in givens.items():\n            if isinstance(type_name, type):\n                self.given(type_name, instance)\n\n        try:\n            yield self\n        finally:\n            self._given_providers = old_givens\n\n    # ============= Resolution Methods =============\n\n    def get(self, token: Token[Any] | type[Any]) -&gt; Any:\n        \"\"\"Resolve a dependency synchronously.\n\n        Args:\n            token: The ``Token[T]`` or ``type[T]`` to resolve.\n\n        Returns:\n            The resolved instance.\n\n        Raises:\n            ResolutionError: If no provider is registered or resolution fails.\n        \"\"\"\n        # Convert to token if needed and handle givens\n        if isinstance(token, type):\n            given = self.resolve_given(token)\n            if given is not None:\n                return given\n        token = self._coerce_to_token(token)\n\n        # Check per-context overrides first\n        override = self._get_override(token)\n        if override is not None:\n            self._cache_hits += 1\n            return override\n\n        # Check context first\n        instance = self.resolve_from_context(token)\n        if instance is not None:\n            self._cache_hits += 1\n            return instance\n\n        self._cache_misses += 1\n\n        with self._resolution_guard(token):\n            # Get provider\n            provider = self._providers.get(token)\n            if provider is None:\n                raise ResolutionError(\n                    token, [], f\"No provider registered for token '{token.name}'\"\n                )\n\n            # Create instance based on scope\n            effective_scope = self._token_scopes.get(token, token.scope)\n            if effective_scope == Scope.SINGLETON:\n                with self._singleton_locks[token]:\n                    if token in self._singletons:\n                        return self._singletons[token]\n                    if asyncio.iscoroutinefunction(provider):\n                        raise ResolutionError(\n                            token,\n                            [],\n                            \"Provider is async; use aget() for async providers\",\n                        )\n                    instance = provider()\n                    self._validate_and_track(token, instance)\n                    self._singletons[token] = instance\n                    return instance\n            else:\n                if asyncio.iscoroutinefunction(provider):\n                    raise ResolutionError(\n                        token,\n                        [],\n                        \"Provider is async; use aget() for async providers\",\n                    )\n                instance = provider()\n                self._validate_and_track(token, instance)\n                self.store_in_context(token, instance)\n                return instance\n\n    async def aget(self, token: Token[Any] | type[Any]) -&gt; Any:\n        \"\"\"Resolve a dependency asynchronously.\n\n        Equivalent to :meth:`get` but awaits async providers and uses\n        async locks for singleton initialization.\n        \"\"\"\n        # Convert to token if needed\n        if isinstance(token, type):\n            given = self.resolve_given(token)\n            if given is not None:\n                return given\n        token = self._coerce_to_token(token)\n\n        # Check per-context overrides first\n        override = self._get_override(token)\n        if override is not None:\n            self._cache_hits += 1\n            return override\n\n        # Check context first\n        instance = self.resolve_from_context(token)\n        if instance is not None:\n            self._cache_hits += 1\n            return instance\n\n        self._cache_misses += 1\n\n        with self._resolution_guard(token):\n            # Get provider\n            provider = self._providers.get(token)\n            if provider is None:\n                raise ResolutionError(\n                    token, [], f\"No provider registered for token '{token.name}'\"\n                )\n\n            # Create instance based on scope\n            effective_scope = self._token_scopes.get(token, token.scope)\n            if effective_scope == Scope.SINGLETON:\n                # Ensure async lock exists\n                if token not in self._async_locks:\n                    self._async_locks[token] = asyncio.Lock()\n\n                async with self._async_locks[token]:\n                    if token in self._singletons:\n                        return self._singletons[token]\n\n                    if asyncio.iscoroutinefunction(provider):\n                        instance = await provider()\n                    else:\n                        instance = provider()\n                    self._validate_and_track(token, instance)\n\n                    self._singletons[token] = instance\n                    return instance\n            else:\n                if asyncio.iscoroutinefunction(provider):\n                    instance = await provider()\n                else:\n                    instance = provider()\n                self._validate_and_track(token, instance)\n\n                self.store_in_context(token, instance)\n                return instance\n\n    # ============= Batch Operations =============\n\n    def batch_register(\n        self, registrations: list[tuple[Token[Any], Provider]]\n    ) -&gt; Container:\n        \"\"\"Register multiple dependencies at once.\"\"\"\n        for token, provider in registrations:\n            self.register(token, provider)\n        return self\n\n    def batch_resolve(self, tokens: list[Token[Any]]) -&gt; dict[Token[Any], Any]:\n        \"\"\"Resolve multiple dependencies efficiently (sync).\"\"\"\n        sorted_tokens = sorted(tokens, key=lambda t: t.scope.value)\n        results: dict[Token[Any], Any] = {}\n        for _scope, group in groupby(sorted_tokens, key=lambda t: t.scope):\n            group_list = list(group)\n            for tk in group_list:\n                results[tk] = self.get(tk)\n        return results\n\n    async def batch_resolve_async(\n        self, tokens: list[Token[Any]]\n    ) -&gt; dict[Token[Any], Any]:\n        \"\"\"Async batch resolution with parallel execution.\"\"\"\n        tasks = {token: self.aget(token) for token in tokens}\n        results_list: list[Any] = await asyncio.gather(*tasks.values())\n        return dict(zip(tasks.keys(), results_list, strict=True))\n\n    # (Provider graph analysis intentionally omitted; can be added behind a feature flag.)\n\n    @lru_cache(maxsize=512)\n    def _get_resolution_path(self, token: Token[Any]) -&gt; tuple[Token[Any], ...]:\n        \"\"\"Get resolution path for a token (cached).\"\"\"\n        return (token,)\n\n    @property\n    def cache_hit_rate(self) -&gt; float:\n        total = self._cache_hits + self._cache_misses\n        return 0.0 if total == 0 else self._cache_hits / total\n\n    def get_stats(self) -&gt; dict[str, Any]:\n        return {\n            \"total_providers\": len(self._providers),\n            \"singletons\": len(self._singletons),\n            \"cache_hits\": self._cache_hits,\n            \"cache_misses\": self._cache_misses,\n            \"cache_hit_rate\": self.cache_hit_rate,\n            \"avg_resolution_time\": (\n                sum(self._resolution_times) / len(self._resolution_times)\n                if self._resolution_times\n                else 0\n            ),\n        }\n\n    # ============= Utilities =============\n\n    def get_providers_view(self) -&gt; MappingProxyType:\n        \"\"\"Return a read-only view of registered providers.\"\"\"\n        return MappingProxyType(self._providers)\n\n    def has(self, token: Token[Any] | type[Any]) -&gt; bool:\n        \"\"\"Return True if the token/type is known to the container.\"\"\"\n        if isinstance(token, type):\n            if token in self._given_providers:\n                return True\n            token = Token(token.__name__, token)\n        return token in self._providers or token in self._singletons\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear providers, caches, and statistics. Does not affect docs or code.\"\"\"\n        with self._lock:\n            self._providers.clear()\n            self._singletons.clear()\n            self._transients.clear()\n            self._given_providers.clear()\n            self._dependencies.clear()\n            self._cache_hits = 0\n            self._cache_misses = 0\n            self._resolution_times.clear()\n        self.clear_all_contexts()\n\n    def __repr__(self) -&gt; str:\n        return (\n            \"Container(\"\n            f\"providers={len(self._providers)}, \"\n            f\"singletons={len(self._singletons)}, \"\n            f\"cache_hit_rate={self.cache_hit_rate:.2%})\"\n        )\n\n    # ============= Decorator Alias =============\n\n    def inject(self, func: Callable[..., Any] | None = None, *, cache: bool = True) -&gt; Callable[..., Any]:\n        \"\"\"Alias to :func:`pyinj.injection.inject` bound to this container.\n\n        Enables ``@container.inject`` usage in addition to ``@inject(container=container)``.\n        \"\"\"\n        from .injection import inject as _inject\n\n        if func is None:\n            return _inject(container=self, cache=cache)\n        return _inject(func, container=self, cache=cache)\n\n    # ============= Context Managers &amp; Cleanup =============\n\n    def __enter__(self) -&gt; Container:  # pragma: no cover - trivial\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:  # pragma: no cover - trivial\n        for resource in reversed(self._resources):\n            try:\n                if hasattr(resource, \"close\"):\n                    resource.close()\n            except Exception:\n                pass\n\n    async def __aenter__(self) -&gt; Container:  # pragma: no cover - trivial\n        return self\n\n    async def __aexit__(\n        self, exc_type, exc_val, exc_tb\n    ) -&gt; None:  # pragma: no cover - trivial\n        tasks = []\n        for resource in reversed(self._resources):\n            if hasattr(resource, \"aclose\"):\n                tasks.append(resource.aclose())\n        if tasks:\n            await asyncio.gather(*tasks, return_exceptions=True)\n\n    async def aclose(self) -&gt; None:\n        \"\"\"Async close: close tracked resources and clear caches.\"\"\"\n        await self.__aexit__(None, None, None)\n        self.clear()\n\n    async def dispose(self) -&gt; None:\n        \"\"\"Alias for aclose to align with tests and docs.\"\"\"\n        await self.aclose()\n\n    @contextmanager\n    def use_overrides(self, mapping: dict[Token[Any], Any]) -&gt; Any:\n        \"\"\"Temporarily override tokens for this concurrent context.\n\n        Example:\n            with container.use_overrides({LOGGER: fake_logger}):\n                svc = container.get(SERVICE)\n                ...\n        \"\"\"\n        parent = self._overrides.get()\n        merged: dict[Token[Any], Any] = dict(parent) if parent else {}\n        merged.update(mapping)\n        token: CtxToken = self._overrides.set(merged)\n        try:\n            yield\n        finally:\n            self._overrides.reset(token)\n\n    def clear_overrides(self) -&gt; None:\n        \"\"\"Clear all overrides for the current context.\"\"\"\n        if self._overrides.get() is not None:\n            self._overrides.set(None)\n\n    # ============= Validation &amp; Resource Tracking =============\n\n    def _validate_and_track(self, token: Token[Any], instance: Any) -&gt; None:\n        if not token.validate(instance):\n            raise TypeError(\n                f\"Provider for token '{token.name}' returned {type(instance).__name__}, expected {token.type_.__name__}\"\n            )\n        if isinstance(instance, (SupportsClose, SupportsAsyncClose)):\n            # track for later cleanup\n            self._resources.append(instance)\n</code></pre>"},{"location":"api/#pyinj.Container.__init__","title":"<code>__init__()</code>","text":"<p>Initialize enhanced container.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize enhanced container.\"\"\"\n    super().__init__()\n\n    # Token factory for convenient creation\n    self.tokens: TokenFactory = TokenFactory()\n\n    # Given instances (Scala-inspired)\n    self._given_providers: dict[type[Any], Provider] = {}\n\n    # Override less-precise base attributes with typed variants\n    self._providers: dict[Token[Any], Provider] = {}\n    self._token_scopes: dict[Token[Any], Scope] = {}\n    self._singletons: dict[Token[Any], Any] = {}\n    self._async_locks: dict[Token[Any], asyncio.Lock] = {}\n\n    # Performance metrics\n    self._resolution_times: deque[float] = deque(maxlen=1000)\n    self._cache_hits: int = 0\n    self._cache_misses: int = 0\n\n    # Thread safety\n    self._lock: threading.RLock = threading.RLock()\n    self._singleton_locks: dict[Token[Any], threading.Lock] = defaultdict(\n        threading.Lock\n    )\n\n    # Track dependencies for graph\n    self._dependencies: dict[Token[Any], set[Token[Any]]] = defaultdict(set)\n\n    # Per-context overrides (DI_SPEC requirement)\n    self._overrides: ContextVar[dict[Token[Any], Any] | None] = ContextVar(\n        \"pyinj_overrides\",\n        default=None,\n    )\n\n    # Thread-local resolution tracking for cycle detection\n    self._local = threading.local()\n</code></pre>"},{"location":"api/#pyinj.Container.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Async close: close tracked resources and clear caches.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"Async close: close tracked resources and clear caches.\"\"\"\n    await self.__aexit__(None, None, None)\n    self.clear()\n</code></pre>"},{"location":"api/#pyinj.Container.aget","title":"<code>aget(token)</code>  <code>async</code>","text":"<p>Resolve a dependency asynchronously.</p> <p>Equivalent to :meth:<code>get</code> but awaits async providers and uses async locks for singleton initialization.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def aget(self, token: Token[Any] | type[Any]) -&gt; Any:\n    \"\"\"Resolve a dependency asynchronously.\n\n    Equivalent to :meth:`get` but awaits async providers and uses\n    async locks for singleton initialization.\n    \"\"\"\n    # Convert to token if needed\n    if isinstance(token, type):\n        given = self.resolve_given(token)\n        if given is not None:\n            return given\n    token = self._coerce_to_token(token)\n\n    # Check per-context overrides first\n    override = self._get_override(token)\n    if override is not None:\n        self._cache_hits += 1\n        return override\n\n    # Check context first\n    instance = self.resolve_from_context(token)\n    if instance is not None:\n        self._cache_hits += 1\n        return instance\n\n    self._cache_misses += 1\n\n    with self._resolution_guard(token):\n        # Get provider\n        provider = self._providers.get(token)\n        if provider is None:\n            raise ResolutionError(\n                token, [], f\"No provider registered for token '{token.name}'\"\n            )\n\n        # Create instance based on scope\n        effective_scope = self._token_scopes.get(token, token.scope)\n        if effective_scope == Scope.SINGLETON:\n            # Ensure async lock exists\n            if token not in self._async_locks:\n                self._async_locks[token] = asyncio.Lock()\n\n            async with self._async_locks[token]:\n                if token in self._singletons:\n                    return self._singletons[token]\n\n                if asyncio.iscoroutinefunction(provider):\n                    instance = await provider()\n                else:\n                    instance = provider()\n                self._validate_and_track(token, instance)\n\n                self._singletons[token] = instance\n                return instance\n        else:\n            if asyncio.iscoroutinefunction(provider):\n                instance = await provider()\n            else:\n                instance = provider()\n            self._validate_and_track(token, instance)\n\n            self.store_in_context(token, instance)\n            return instance\n</code></pre>"},{"location":"api/#pyinj.Container.batch_register","title":"<code>batch_register(registrations)</code>","text":"<p>Register multiple dependencies at once.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def batch_register(\n    self, registrations: list[tuple[Token[Any], Provider]]\n) -&gt; Container:\n    \"\"\"Register multiple dependencies at once.\"\"\"\n    for token, provider in registrations:\n        self.register(token, provider)\n    return self\n</code></pre>"},{"location":"api/#pyinj.Container.batch_resolve","title":"<code>batch_resolve(tokens)</code>","text":"<p>Resolve multiple dependencies efficiently (sync).</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def batch_resolve(self, tokens: list[Token[Any]]) -&gt; dict[Token[Any], Any]:\n    \"\"\"Resolve multiple dependencies efficiently (sync).\"\"\"\n    sorted_tokens = sorted(tokens, key=lambda t: t.scope.value)\n    results: dict[Token[Any], Any] = {}\n    for _scope, group in groupby(sorted_tokens, key=lambda t: t.scope):\n        group_list = list(group)\n        for tk in group_list:\n            results[tk] = self.get(tk)\n    return results\n</code></pre>"},{"location":"api/#pyinj.Container.batch_resolve_async","title":"<code>batch_resolve_async(tokens)</code>  <code>async</code>","text":"<p>Async batch resolution with parallel execution.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def batch_resolve_async(\n    self, tokens: list[Token[Any]]\n) -&gt; dict[Token[Any], Any]:\n    \"\"\"Async batch resolution with parallel execution.\"\"\"\n    tasks = {token: self.aget(token) for token in tokens}\n    results_list: list[Any] = await asyncio.gather(*tasks.values())\n    return dict(zip(tasks.keys(), results_list, strict=True))\n</code></pre>"},{"location":"api/#pyinj.Container.clear","title":"<code>clear()</code>","text":"<p>Clear providers, caches, and statistics. Does not affect docs or code.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear providers, caches, and statistics. Does not affect docs or code.\"\"\"\n    with self._lock:\n        self._providers.clear()\n        self._singletons.clear()\n        self._transients.clear()\n        self._given_providers.clear()\n        self._dependencies.clear()\n        self._cache_hits = 0\n        self._cache_misses = 0\n        self._resolution_times.clear()\n    self.clear_all_contexts()\n</code></pre>"},{"location":"api/#pyinj.Container.clear_overrides","title":"<code>clear_overrides()</code>","text":"<p>Clear all overrides for the current context.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def clear_overrides(self) -&gt; None:\n    \"\"\"Clear all overrides for the current context.\"\"\"\n    if self._overrides.get() is not None:\n        self._overrides.set(None)\n</code></pre>"},{"location":"api/#pyinj.Container.dispose","title":"<code>dispose()</code>  <code>async</code>","text":"<p>Alias for aclose to align with tests and docs.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def dispose(self) -&gt; None:\n    \"\"\"Alias for aclose to align with tests and docs.\"\"\"\n    await self.aclose()\n</code></pre>"},{"location":"api/#pyinj.Container.get","title":"<code>get(token)</code>","text":"<p>Resolve a dependency synchronously.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[Any] | type[Any]</code> <p>The <code>Token[T]</code> or <code>type[T]</code> to resolve.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The resolved instance.</p> <p>Raises:</p> Type Description <code>ResolutionError</code> <p>If no provider is registered or resolution fails.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def get(self, token: Token[Any] | type[Any]) -&gt; Any:\n    \"\"\"Resolve a dependency synchronously.\n\n    Args:\n        token: The ``Token[T]`` or ``type[T]`` to resolve.\n\n    Returns:\n        The resolved instance.\n\n    Raises:\n        ResolutionError: If no provider is registered or resolution fails.\n    \"\"\"\n    # Convert to token if needed and handle givens\n    if isinstance(token, type):\n        given = self.resolve_given(token)\n        if given is not None:\n            return given\n    token = self._coerce_to_token(token)\n\n    # Check per-context overrides first\n    override = self._get_override(token)\n    if override is not None:\n        self._cache_hits += 1\n        return override\n\n    # Check context first\n    instance = self.resolve_from_context(token)\n    if instance is not None:\n        self._cache_hits += 1\n        return instance\n\n    self._cache_misses += 1\n\n    with self._resolution_guard(token):\n        # Get provider\n        provider = self._providers.get(token)\n        if provider is None:\n            raise ResolutionError(\n                token, [], f\"No provider registered for token '{token.name}'\"\n            )\n\n        # Create instance based on scope\n        effective_scope = self._token_scopes.get(token, token.scope)\n        if effective_scope == Scope.SINGLETON:\n            with self._singleton_locks[token]:\n                if token in self._singletons:\n                    return self._singletons[token]\n                if asyncio.iscoroutinefunction(provider):\n                    raise ResolutionError(\n                        token,\n                        [],\n                        \"Provider is async; use aget() for async providers\",\n                    )\n                instance = provider()\n                self._validate_and_track(token, instance)\n                self._singletons[token] = instance\n                return instance\n        else:\n            if asyncio.iscoroutinefunction(provider):\n                raise ResolutionError(\n                    token,\n                    [],\n                    \"Provider is async; use aget() for async providers\",\n                )\n            instance = provider()\n            self._validate_and_track(token, instance)\n            self.store_in_context(token, instance)\n            return instance\n</code></pre>"},{"location":"api/#pyinj.Container.get_providers_view","title":"<code>get_providers_view()</code>","text":"<p>Return a read-only view of registered providers.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def get_providers_view(self) -&gt; MappingProxyType:\n    \"\"\"Return a read-only view of registered providers.\"\"\"\n    return MappingProxyType(self._providers)\n</code></pre>"},{"location":"api/#pyinj.Container.given","title":"<code>given(type_, provider)</code>","text":"<p>Register a given instance for a type (Scala-style).</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def given(self, type_: type[Any], provider: Provider | Any) -&gt; Container:\n    \"\"\"Register a given instance for a type (Scala-style).\"\"\"\n    if callable(provider):\n        self._given_providers[type_] = provider\n    else:\n        # Wrap value in lambda\n        self._given_providers[type_] = lambda p=provider: p\n\n    return self\n</code></pre>"},{"location":"api/#pyinj.Container.has","title":"<code>has(token)</code>","text":"<p>Return True if the token/type is known to the container.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def has(self, token: Token[Any] | type[Any]) -&gt; bool:\n    \"\"\"Return True if the token/type is known to the container.\"\"\"\n    if isinstance(token, type):\n        if token in self._given_providers:\n            return True\n        token = Token(token.__name__, token)\n    return token in self._providers or token in self._singletons\n</code></pre>"},{"location":"api/#pyinj.Container.inject","title":"<code>inject(func=None, *, cache=True)</code>","text":"<p>Alias to :func:<code>pyinj.injection.inject</code> bound to this container.</p> <p>Enables <code>@container.inject</code> usage in addition to <code>@inject(container=container)</code>.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def inject(self, func: Callable[..., Any] | None = None, *, cache: bool = True) -&gt; Callable[..., Any]:\n    \"\"\"Alias to :func:`pyinj.injection.inject` bound to this container.\n\n    Enables ``@container.inject`` usage in addition to ``@inject(container=container)``.\n    \"\"\"\n    from .injection import inject as _inject\n\n    if func is None:\n        return _inject(container=self, cache=cache)\n    return _inject(func, container=self, cache=cache)\n</code></pre>"},{"location":"api/#pyinj.Container.override","title":"<code>override(token, value)</code>","text":"<p>Override a dependency with a specific value for this container.</p> <p>Prefer the <code>use_overrides</code> context manager for scoped overrides in concurrent test scenarios.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def override(self, token: Token[Any], value: Any) -&gt; None:\n    \"\"\"Override a dependency with a specific value for this container.\n\n    Prefer the ``use_overrides`` context manager for scoped overrides\n    in concurrent test scenarios.\n    \"\"\"\n    self._singletons[token] = value\n</code></pre>"},{"location":"api/#pyinj.Container.register","title":"<code>register(token, provider, scope=None, *, tags=())</code>","text":"<p>Register a provider for a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[Any] | type[Any]</code> <p>A <code>Token[T]</code> or a concrete <code>type[T]</code>. If a type is provided, a token is created automatically.</p> required <code>provider</code> <code>Provider</code> <p>Callable that returns the dependency instance.</p> required <code>scope</code> <code>Scope | None</code> <p>Optional lifecycle override (defaults to token.scope or TRANSIENT).</p> <code>None</code> <code>tags</code> <code>tuple[str, ...]</code> <p>Optional tags for discovery/metadata.</p> <code>()</code> <p>Returns:</p> Type Description <code>Container</code> <p>Self, to allow method chaining.</p> Example <p>container.register(TokenDB, create_db, scope=Scope.SINGLETON)</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register(\n    self,\n    token: Token[Any] | type[Any],\n    provider: Provider,\n    scope: Scope | None = None,\n    *,\n    tags: tuple[str, ...] = (),\n) -&gt; Container:\n    \"\"\"Register a provider for a token.\n\n    Args:\n        token: A ``Token[T]`` or a concrete ``type[T]``. If a type is\n            provided, a token is created automatically.\n        provider: Callable that returns the dependency instance.\n        scope: Optional lifecycle override (defaults to token.scope or TRANSIENT).\n        tags: Optional tags for discovery/metadata.\n\n    Returns:\n        Self, to allow method chaining.\n\n    Example:\n        container.register(Token[DB](\"db\"), create_db, scope=Scope.SINGLETON)\n    \"\"\"\n    # Convert to Token if needed\n    if isinstance(token, type):\n        token = self.tokens.create(\n            token.__name__, token, scope=scope or Scope.TRANSIENT, tags=tags\n        )\n    elif scope is not None:\n        # Record desired scope without changing the token identity\n        self._token_scopes[token] = scope\n\n    # Validate provider\n    if not callable(provider):\n        raise TypeError(\n            f\"Provider must be callable, got {type(provider).__name__}\\n\"\n            f\"  Fix: Pass a function or lambda that returns an instance\\n\"\n            f\"  Example: container.register(token, lambda: {token.type_.__name__}())\"\n        )\n\n    with self._lock:\n        self._providers[token] = provider\n\n    return self  # Enable chaining\n</code></pre>"},{"location":"api/#pyinj.Container.register_request","title":"<code>register_request(token, provider)</code>","text":"<p>Register a request-scoped dependency.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_request(\n    self, token: Token[Any] | type[Any], provider: Provider\n) -&gt; Container:\n    \"\"\"Register a request-scoped dependency.\"\"\"\n    return self.register(token, provider, scope=Scope.REQUEST)\n</code></pre>"},{"location":"api/#pyinj.Container.register_singleton","title":"<code>register_singleton(token, provider)</code>","text":"<p>Register a singleton-scoped dependency.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_singleton(\n    self, token: Token[Any] | type[Any], provider: Provider\n) -&gt; Container:\n    \"\"\"Register a singleton-scoped dependency.\"\"\"\n    return self.register(token, provider, scope=Scope.SINGLETON)\n</code></pre>"},{"location":"api/#pyinj.Container.register_transient","title":"<code>register_transient(token, provider)</code>","text":"<p>Register a transient-scoped dependency.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_transient(\n    self, token: Token[Any] | type[Any], provider: Provider\n) -&gt; Container:\n    \"\"\"Register a transient-scoped dependency.\"\"\"\n    return self.register(token, provider, scope=Scope.TRANSIENT)\n</code></pre>"},{"location":"api/#pyinj.Container.register_value","title":"<code>register_value(token, value)</code>","text":"<p>Register a pre-created value as a singleton.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_value(self, token: Token[Any] | type[Any], value: Any) -&gt; Container:\n    \"\"\"Register a pre-created value as a singleton.\"\"\"\n    if isinstance(token, type):\n        token = self.tokens.singleton(token.__name__, token)\n    # token is now a Token[Any]\n\n    # Store directly as singleton\n    self._singletons[token] = value\n    return self\n</code></pre>"},{"location":"api/#pyinj.Container.resolve_given","title":"<code>resolve_given(type_)</code>","text":"<p>Resolve a given instance by type.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def resolve_given(self, type_: type[T]) -&gt; T | None:\n    \"\"\"Resolve a given instance by type.\"\"\"\n    provider = self._given_providers.get(type_)\n    if provider:\n        return provider()\n    return None\n</code></pre>"},{"location":"api/#pyinj.Container.use_overrides","title":"<code>use_overrides(mapping)</code>","text":"<p>Temporarily override tokens for this concurrent context.</p> Example <p>with container.use_overrides({LOGGER: fake_logger}):     svc = container.get(SERVICE)     ...</p> Source code in <code>src/pyinj/container.py</code> <pre><code>@contextmanager\ndef use_overrides(self, mapping: dict[Token[Any], Any]) -&gt; Any:\n    \"\"\"Temporarily override tokens for this concurrent context.\n\n    Example:\n        with container.use_overrides({LOGGER: fake_logger}):\n            svc = container.get(SERVICE)\n            ...\n    \"\"\"\n    parent = self._overrides.get()\n    merged: dict[Token[Any], Any] = dict(parent) if parent else {}\n    merged.update(mapping)\n    token: CtxToken = self._overrides.set(merged)\n    try:\n        yield\n    finally:\n        self._overrides.reset(token)\n</code></pre>"},{"location":"api/#pyinj.Container.using","title":"<code>using(**givens)</code>","text":"<p>Scala-style using clause for temporary givens.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>@contextmanager\ndef using(self, **givens: Any) -&gt; Iterator[Container]:\n    \"\"\"Scala-style using clause for temporary givens.\"\"\"\n    old_givens = self._given_providers.copy()\n\n    # Add temporary givens\n    for type_name, instance in givens.items():\n        if isinstance(type_name, type):\n            self.given(type_name, instance)\n\n    try:\n        yield self\n    finally:\n        self._given_providers = old_givens\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer","title":"<code>ContextualContainer</code>","text":"<p>Base container adding request/session context via <code>contextvars</code>.</p> <p>Context flows implicitly across awaits; request/session lifetimes are enforced by the :class:<code>ScopeManager</code>.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>class ContextualContainer:\n    \"\"\"Base container adding request/session context via ``contextvars``.\n\n    Context flows implicitly across awaits; request/session lifetimes\n    are enforced by the :class:`ScopeManager`.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize contextual container.\"\"\"\n        # Singleton cache (process-wide)\n        self._singletons: dict[Token, Any] = {}\n\n        # Weak cache for transients (auto-cleanup)\n        self._transients: WeakValueDictionary = WeakValueDictionary()\n\n        # Providers registry\n        self._providers: dict[Token, Any] = {}\n\n        # Async locks for thread-safe singleton creation\n        self._async_locks: dict[Token, asyncio.Lock] = {}\n\n        # Track resources for cleanup\n        self._resources: list[Any] = []\n\n        # Scope manager (RAII contexts, precedence enforcement)\n        self._scope_manager = ScopeManager(self)\n\n    def _put_in_current_request_cache(self, token: Token[T], instance: T) -&gt; None:\n        \"\"\"Insert a value into the current request cache unconditionally.\n\n        This bypasses scope checks and is intended for temporary overrides\n        that should only affect the current context.\n        \"\"\"\n        context = _context_stack.get()\n        if context and hasattr(context, \"maps\") and context.maps:\n            context.maps[0][token] = instance\n\n    @contextmanager\n    def request_scope(self) -&gt; Iterator[ContextualContainer]:\n        \"\"\"Create a request scope (similar to a web request lifecycle).\n\n        Example:\n            with container.request_scope():\n                service = container.get(ServiceToken)\n\n        Yields:\n            Self for chaining.\n        \"\"\"\n        with self._scope_manager.request_scope():\n            yield self\n\n    @asynccontextmanager\n    async def async_request_scope(self) -&gt; AsyncIterator[ContextualContainer]:\n        \"\"\"Async context manager variant of :meth:`request_scope`.\n\n        Example:\n            async with container.async_request_scope():\n                service = await container.aget(ServiceToken)\n        \"\"\"\n        async with self._scope_manager.async_request_scope():\n            yield self\n\n    @contextmanager\n    def session_scope(self) -&gt; Iterator[ContextualContainer]:\n        \"\"\"\n        Create a session scope (longer-lived than request).\n\n        Session scopes persist across multiple requests but are\n        isolated between different sessions (e.g., users).\n        \"\"\"\n        with self._scope_manager.session_scope():\n            yield self\n\n    def _cleanup_scope(self, cache: dict[Token, Any]) -&gt; None:\n        \"\"\"\n        Clean up resources in LIFO order.\n\n        Args:\n            cache: Cache of resources to clean up\n        \"\"\"\n        for resource in reversed(list(cache.values())):\n            try:\n                if hasattr(resource, \"close\"):\n                    resource.close()\n                elif hasattr(resource, \"__exit__\"):\n                    resource.__exit__(None, None, None)\n            except Exception:\n                # Log but don't fail cleanup\n                pass\n\n    async def _async_cleanup_scope(self, cache: dict[Token, Any]) -&gt; None:\n        \"\"\"\n        Async cleanup of resources.\n\n        Args:\n            cache: Cache of resources to clean up\n        \"\"\"\n        tasks = []\n\n        for resource in reversed(list(cache.values())):\n            if hasattr(resource, \"aclose\"):\n                tasks.append(resource.aclose())\n            elif hasattr(resource, \"__aexit__\"):\n                tasks.append(resource.__aexit__(None, None, None))\n            elif hasattr(resource, \"close\"):\n                # Sync cleanup in executor\n                loop = asyncio.get_event_loop()\n                tasks.append(loop.run_in_executor(None, resource.close))\n\n        if tasks:\n            # Gather with return_exceptions to prevent one failure from stopping others\n            await asyncio.gather(*tasks, return_exceptions=True)\n\n    def resolve_from_context(self, token: Token[T]) -&gt; T | None:\n        \"\"\"\n        Resolve dependency from current context.\n\n        Args:\n            token: Token to resolve\n\n        Returns:\n            Resolved instance or None if not in context\n        \"\"\"\n        return self._scope_manager.resolve_from_context(token)\n\n    def store_in_context(self, token: Token[T], instance: T) -&gt; None:\n        \"\"\"\n        Store instance in appropriate context.\n\n        Args:\n            token: Token for the instance\n            instance: Instance to store\n        \"\"\"\n        self._scope_manager.store_in_context(token, instance)\n\n    def clear_request_context(self) -&gt; None:\n        \"\"\"Clear current request context.\"\"\"\n        self._scope_manager.clear_request_context()\n\n    def clear_session_context(self) -&gt; None:\n        \"\"\"Clear current session context.\"\"\"\n        self._scope_manager.clear_session_context()\n\n    def clear_all_contexts(self) -&gt; None:\n        \"\"\"Clear all contexts including singletons.\"\"\"\n        self._scope_manager.clear_all_contexts()\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.__init__","title":"<code>__init__()</code>","text":"<p>Initialize contextual container.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize contextual container.\"\"\"\n    # Singleton cache (process-wide)\n    self._singletons: dict[Token, Any] = {}\n\n    # Weak cache for transients (auto-cleanup)\n    self._transients: WeakValueDictionary = WeakValueDictionary()\n\n    # Providers registry\n    self._providers: dict[Token, Any] = {}\n\n    # Async locks for thread-safe singleton creation\n    self._async_locks: dict[Token, asyncio.Lock] = {}\n\n    # Track resources for cleanup\n    self._resources: list[Any] = []\n\n    # Scope manager (RAII contexts, precedence enforcement)\n    self._scope_manager = ScopeManager(self)\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.async_request_scope","title":"<code>async_request_scope()</code>  <code>async</code>","text":"<p>Async context manager variant of :meth:<code>request_scope</code>.</p> Example <p>async with container.async_request_scope():     service = await container.aget(ServiceToken)</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>@asynccontextmanager\nasync def async_request_scope(self) -&gt; AsyncIterator[ContextualContainer]:\n    \"\"\"Async context manager variant of :meth:`request_scope`.\n\n    Example:\n        async with container.async_request_scope():\n            service = await container.aget(ServiceToken)\n    \"\"\"\n    async with self._scope_manager.async_request_scope():\n        yield self\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.clear_all_contexts","title":"<code>clear_all_contexts()</code>","text":"<p>Clear all contexts including singletons.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def clear_all_contexts(self) -&gt; None:\n    \"\"\"Clear all contexts including singletons.\"\"\"\n    self._scope_manager.clear_all_contexts()\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.clear_request_context","title":"<code>clear_request_context()</code>","text":"<p>Clear current request context.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def clear_request_context(self) -&gt; None:\n    \"\"\"Clear current request context.\"\"\"\n    self._scope_manager.clear_request_context()\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.clear_session_context","title":"<code>clear_session_context()</code>","text":"<p>Clear current session context.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def clear_session_context(self) -&gt; None:\n    \"\"\"Clear current session context.\"\"\"\n    self._scope_manager.clear_session_context()\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.request_scope","title":"<code>request_scope()</code>","text":"<p>Create a request scope (similar to a web request lifecycle).</p> Example <p>with container.request_scope():     service = container.get(ServiceToken)</p> <p>Yields:</p> Type Description <code>ContextualContainer</code> <p>Self for chaining.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>@contextmanager\ndef request_scope(self) -&gt; Iterator[ContextualContainer]:\n    \"\"\"Create a request scope (similar to a web request lifecycle).\n\n    Example:\n        with container.request_scope():\n            service = container.get(ServiceToken)\n\n    Yields:\n        Self for chaining.\n    \"\"\"\n    with self._scope_manager.request_scope():\n        yield self\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.resolve_from_context","title":"<code>resolve_from_context(token)</code>","text":"<p>Resolve dependency from current context.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[T]</code> <p>Token to resolve</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>Resolved instance or None if not in context</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def resolve_from_context(self, token: Token[T]) -&gt; T | None:\n    \"\"\"\n    Resolve dependency from current context.\n\n    Args:\n        token: Token to resolve\n\n    Returns:\n        Resolved instance or None if not in context\n    \"\"\"\n    return self._scope_manager.resolve_from_context(token)\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.session_scope","title":"<code>session_scope()</code>","text":"<p>Create a session scope (longer-lived than request).</p> <p>Session scopes persist across multiple requests but are isolated between different sessions (e.g., users).</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>@contextmanager\ndef session_scope(self) -&gt; Iterator[ContextualContainer]:\n    \"\"\"\n    Create a session scope (longer-lived than request).\n\n    Session scopes persist across multiple requests but are\n    isolated between different sessions (e.g., users).\n    \"\"\"\n    with self._scope_manager.session_scope():\n        yield self\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.store_in_context","title":"<code>store_in_context(token, instance)</code>","text":"<p>Store instance in appropriate context.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[T]</code> <p>Token for the instance</p> required <code>instance</code> <code>T</code> <p>Instance to store</p> required Source code in <code>src/pyinj/contextual.py</code> <pre><code>def store_in_context(self, token: Token[T], instance: T) -&gt; None:\n    \"\"\"\n    Store instance in appropriate context.\n\n    Args:\n        token: Token for the instance\n        instance: Instance to store\n    \"\"\"\n    self._scope_manager.store_in_context(token, instance)\n</code></pre>"},{"location":"api/#pyinj.Given","title":"<code>Given</code>","text":"<p>Scala-style given marker for implicit dependencies.</p> Usage <p>def handler(db: Given[Database]):     # db is resolved from given instances     ...</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>class Given:\n    \"\"\"\n    Scala-style given marker for implicit dependencies.\n\n    Usage:\n        def handler(db: Given[Database]):\n            # db is resolved from given instances\n            ...\n    \"\"\"\n\n    def __class_getitem__(cls, item: type[T]) -&gt; Inject:\n        \"\"\"Support Given[Type] syntax by delegating to Inject.\"\"\"\n        return Inject[item]\n</code></pre>"},{"location":"api/#pyinj.Given.__class_getitem__","title":"<code>__class_getitem__(item)</code>","text":"<p>Support Given[Type] syntax by delegating to Inject.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __class_getitem__(cls, item: type[T]) -&gt; Inject:\n    \"\"\"Support Given[Type] syntax by delegating to Inject.\"\"\"\n    return Inject[item]\n</code></pre>"},{"location":"api/#pyinj.Inject","title":"<code>Inject</code>","text":"<p>Marker for injected dependencies (similar to FastAPI's <code>Depends</code>).</p> Usage <p>def handler(db: Inject[Database]):     # db is auto-injected     ...</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>class Inject:\n    \"\"\"\n    Marker for injected dependencies (similar to FastAPI's ``Depends``).\n\n    Usage:\n        def handler(db: Inject[Database]):\n            # db is auto-injected\n            ...\n\n        # Or with default provider\n        def handler(db: Inject[Database] = Inject(create_db)):\n            ...\n    \"\"\"\n\n    def __init__(self, provider: Callable | None = None) -&gt; None:\n        \"\"\"\n        Initialize an injection marker optionally carrying a provider.\n\n        Args:\n            provider: Optional provider function\n        \"\"\"\n        self.provider = provider\n        self._type: type | None = None\n\n    def __class_getitem__(cls, item: builtins.type[T]) -&gt; builtins.type[Inject]:\n        \"\"\"\n        Support Inject[Type] syntax.\n\n        This allows type checkers to understand the type.\n        \"\"\"\n\n        # Create a new class that remembers the type\n        class TypedInject(cls):\n            _inject_type = item\n\n        return TypedInject\n\n    @property\n    def type(self) -&gt; builtins.type | None:\n        \"\"\"Get the injected type if available.\"\"\"\n        if hasattr(self.__class__, \"_inject_type\"):\n            return self.__class__._inject_type\n        return self._type\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Readable representation.\"\"\"\n        if self.type:\n            return f\"Inject[{self.type.__name__}]\"\n        return \"Inject()\"\n</code></pre>"},{"location":"api/#pyinj.Inject--or-with-default-provider","title":"Or with default provider","text":"<p>def handler(db: Inject[Database] = Inject(create_db)):     ...</p>"},{"location":"api/#pyinj.Inject.type","title":"<code>type</code>  <code>property</code>","text":"<p>Get the injected type if available.</p>"},{"location":"api/#pyinj.Inject.__class_getitem__","title":"<code>__class_getitem__(item)</code>","text":"<p>Support Inject[Type] syntax.</p> <p>This allows type checkers to understand the type.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __class_getitem__(cls, item: builtins.type[T]) -&gt; builtins.type[Inject]:\n    \"\"\"\n    Support Inject[Type] syntax.\n\n    This allows type checkers to understand the type.\n    \"\"\"\n\n    # Create a new class that remembers the type\n    class TypedInject(cls):\n        _inject_type = item\n\n    return TypedInject\n</code></pre>"},{"location":"api/#pyinj.Inject.__init__","title":"<code>__init__(provider=None)</code>","text":"<p>Initialize an injection marker optionally carrying a provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>Callable | None</code> <p>Optional provider function</p> <code>None</code> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __init__(self, provider: Callable | None = None) -&gt; None:\n    \"\"\"\n    Initialize an injection marker optionally carrying a provider.\n\n    Args:\n        provider: Optional provider function\n    \"\"\"\n    self.provider = provider\n    self._type: type | None = None\n</code></pre>"},{"location":"api/#pyinj.Inject.__repr__","title":"<code>__repr__()</code>","text":"<p>Readable representation.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Readable representation.\"\"\"\n    if self.type:\n        return f\"Inject[{self.type.__name__}]\"\n    return \"Inject()\"\n</code></pre>"},{"location":"api/#pyinj.Injectable","title":"<code>Injectable</code>","text":"<p>               Bases: <code>ABCMeta</code></p> <p>Metaclass for automatic dependency registration.</p> <p>Classes using this metaclass can be automatically registered in the container by setting class attributes:</p> Example <p>class DatabaseService(metaclass=Injectable):     injectable = True     token_name = \"database\"     scope = Scope.SINGLETON</p> Source code in <code>src/pyinj/metaclasses.py</code> <pre><code>class Injectable(ABCMeta):\n    \"\"\"Metaclass for automatic dependency registration.\n\n    Classes using this metaclass can be automatically registered in\n    the container by setting class attributes:\n\n    Example:\n        class DatabaseService(metaclass=Injectable):\n            __injectable__ = True\n            __token_name__ = \"database\"\n            __scope__ = Scope.SINGLETON\n    \"\"\"\n\n    _registry: ClassVar[dict[type[Any], Token[Any]]] = {}\n\n    def __new__(\n        mcs,\n        name: str,\n        bases: tuple[type, ...],\n        namespace: dict[str, Any],\n        **kwargs: Any,\n    ) -&gt; Injectable:\n        \"\"\"Create a new class and optionally register it for injection.\n\n        Args:\n            name: The class name\n            bases: Base classes\n            namespace: Class namespace dictionary\n            **kwargs: Additional keyword arguments\n\n        Returns:\n            The newly created class\n        \"\"\"\n        cls = super().__new__(mcs, name, bases, namespace)\n\n        # Only register if explicitly marked as injectable\n        if namespace.get(\"__injectable__\", False):\n            token_name = namespace.get(\"__token_name__\", name.lower())\n            scope = namespace.get(\"__scope__\", Scope.TRANSIENT)\n\n            # Create type-safe token\n            token = Token(name=token_name, type_=cls)\n\n            # Store in registry\n            mcs._registry[cls] = token\n\n            # Add metadata to class\n            cls.__token__ = token  # type: ignore[attr-defined]\n            cls.__scope__ = scope  # type: ignore[attr-defined]\n\n        return cls\n\n    @classmethod\n    def get_registry(cls) -&gt; dict[type[Any], Token[Any]]:\n        \"\"\"Get a copy of the injection registry.\n\n        Returns:\n            Dictionary mapping class types to their tokens\n        \"\"\"\n        return cls._registry.copy()\n</code></pre>"},{"location":"api/#pyinj.Injectable.__new__","title":"<code>__new__(mcs, name, bases, namespace, **kwargs)</code>","text":"<p>Create a new class and optionally register it for injection.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The class name</p> required <code>bases</code> <code>tuple[type, ...]</code> <p>Base classes</p> required <code>namespace</code> <code>dict[str, Any]</code> <p>Class namespace dictionary</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>Injectable</code> <p>The newly created class</p> Source code in <code>src/pyinj/metaclasses.py</code> <pre><code>def __new__(\n    mcs,\n    name: str,\n    bases: tuple[type, ...],\n    namespace: dict[str, Any],\n    **kwargs: Any,\n) -&gt; Injectable:\n    \"\"\"Create a new class and optionally register it for injection.\n\n    Args:\n        name: The class name\n        bases: Base classes\n        namespace: Class namespace dictionary\n        **kwargs: Additional keyword arguments\n\n    Returns:\n        The newly created class\n    \"\"\"\n    cls = super().__new__(mcs, name, bases, namespace)\n\n    # Only register if explicitly marked as injectable\n    if namespace.get(\"__injectable__\", False):\n        token_name = namespace.get(\"__token_name__\", name.lower())\n        scope = namespace.get(\"__scope__\", Scope.TRANSIENT)\n\n        # Create type-safe token\n        token = Token(name=token_name, type_=cls)\n\n        # Store in registry\n        mcs._registry[cls] = token\n\n        # Add metadata to class\n        cls.__token__ = token  # type: ignore[attr-defined]\n        cls.__scope__ = scope  # type: ignore[attr-defined]\n\n    return cls\n</code></pre>"},{"location":"api/#pyinj.Injectable.get_registry","title":"<code>get_registry()</code>  <code>classmethod</code>","text":"<p>Get a copy of the injection registry.</p> <p>Returns:</p> Type Description <code>dict[type[Any], Token[Any]]</code> <p>Dictionary mapping class types to their tokens</p> Source code in <code>src/pyinj/metaclasses.py</code> <pre><code>@classmethod\ndef get_registry(cls) -&gt; dict[type[Any], Token[Any]]:\n    \"\"\"Get a copy of the injection registry.\n\n    Returns:\n        Dictionary mapping class types to their tokens\n    \"\"\"\n    return cls._registry.copy()\n</code></pre>"},{"location":"api/#pyinj.PyInjError","title":"<code>PyInjError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all pyinj errors.</p> Source code in <code>src/pyinj/exceptions.py</code> <pre><code>class PyInjError(Exception):\n    \"\"\"Base exception for all pyinj errors.\"\"\"\n</code></pre>"},{"location":"api/#pyinj.RequestScope","title":"<code>RequestScope</code>","text":"<p>Helper class for request-scoped dependencies.</p> Example <p>async with RequestScope(container) as scope:     service = scope.resolve(ServiceToken)</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>class RequestScope:\n    \"\"\"\n    Helper class for request-scoped dependencies.\n\n    Example:\n        async with RequestScope(container) as scope:\n            service = scope.resolve(ServiceToken)\n    \"\"\"\n\n    def __init__(self, container: ContextualContainer):\n        \"\"\"Initialize request scope.\"\"\"\n        self.container = container\n        self._context_manager = None\n        self._async_context_manager = None\n\n    def __enter__(self) -&gt; RequestScope:\n        \"\"\"Enter request scope.\"\"\"\n        self._context_manager = self.container.request_scope()\n        self._context_manager.__enter__()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        \"\"\"Exit request scope.\"\"\"\n        if self._context_manager:\n            self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n\n    async def __aenter__(self) -&gt; RequestScope:\n        \"\"\"Async enter request scope.\"\"\"\n        self._async_context_manager = self.container.async_request_scope()\n        await self._async_context_manager.__aenter__()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        \"\"\"Async exit request scope.\"\"\"\n        if self._async_context_manager:\n            await self._async_context_manager.__aexit__(exc_type, exc_val, exc_tb)\n\n    def resolve(self, token: Token[T]) -&gt; T | None:\n        \"\"\"Resolve dependency in this scope.\"\"\"\n        return self.container.resolve_from_context(token)\n</code></pre>"},{"location":"api/#pyinj.RequestScope.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Async enter request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>async def __aenter__(self) -&gt; RequestScope:\n    \"\"\"Async enter request scope.\"\"\"\n    self._async_context_manager = self.container.async_request_scope()\n    await self._async_context_manager.__aenter__()\n    return self\n</code></pre>"},{"location":"api/#pyinj.RequestScope.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Async exit request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n    \"\"\"Async exit request scope.\"\"\"\n    if self._async_context_manager:\n        await self._async_context_manager.__aexit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.RequestScope.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __enter__(self) -&gt; RequestScope:\n    \"\"\"Enter request scope.\"\"\"\n    self._context_manager = self.container.request_scope()\n    self._context_manager.__enter__()\n    return self\n</code></pre>"},{"location":"api/#pyinj.RequestScope.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n    \"\"\"Exit request scope.\"\"\"\n    if self._context_manager:\n        self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.RequestScope.__init__","title":"<code>__init__(container)</code>","text":"<p>Initialize request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __init__(self, container: ContextualContainer):\n    \"\"\"Initialize request scope.\"\"\"\n    self.container = container\n    self._context_manager = None\n    self._async_context_manager = None\n</code></pre>"},{"location":"api/#pyinj.RequestScope.resolve","title":"<code>resolve(token)</code>","text":"<p>Resolve dependency in this scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def resolve(self, token: Token[T]) -&gt; T | None:\n    \"\"\"Resolve dependency in this scope.\"\"\"\n    return self.container.resolve_from_context(token)\n</code></pre>"},{"location":"api/#pyinj.ResolutionError","title":"<code>ResolutionError</code>","text":"<p>               Bases: <code>PyInjError</code></p> <p>Raised when a dependency cannot be resolved.</p> Source code in <code>src/pyinj/exceptions.py</code> <pre><code>class ResolutionError(PyInjError):\n    \"\"\"Raised when a dependency cannot be resolved.\"\"\"\n\n    def __init__(self, token: Token, chain: list[Token], cause: str) -&gt; None:\n        \"\"\"Initialize resolution error with context.\n\n        Args:\n            token: The token that couldn't be resolved\n            chain: The current resolution chain\n            cause: Human-readable cause description\n        \"\"\"\n        self.token = token\n        self.chain = chain\n        self.cause = cause\n\n        chain_str = \" -&gt; \".join(t.name for t in chain) if chain else \"root\"\n        super().__init__(\n            f\"Cannot resolve token '{token.name}':\\n\"\n            f\"  Resolution chain: {chain_str}\\n\"\n            f\"  Cause: {cause}\"\n        )\n</code></pre>"},{"location":"api/#pyinj.ResolutionError.__init__","title":"<code>__init__(token, chain, cause)</code>","text":"<p>Initialize resolution error with context.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>The token that couldn't be resolved</p> required <code>chain</code> <code>list[Token]</code> <p>The current resolution chain</p> required <code>cause</code> <code>str</code> <p>Human-readable cause description</p> required Source code in <code>src/pyinj/exceptions.py</code> <pre><code>def __init__(self, token: Token, chain: list[Token], cause: str) -&gt; None:\n    \"\"\"Initialize resolution error with context.\n\n    Args:\n        token: The token that couldn't be resolved\n        chain: The current resolution chain\n        cause: Human-readable cause description\n    \"\"\"\n    self.token = token\n    self.chain = chain\n    self.cause = cause\n\n    chain_str = \" -&gt; \".join(t.name for t in chain) if chain else \"root\"\n    super().__init__(\n        f\"Cannot resolve token '{token.name}':\\n\"\n        f\"  Resolution chain: {chain_str}\\n\"\n        f\"  Cause: {cause}\"\n    )\n</code></pre>"},{"location":"api/#pyinj.Scope","title":"<code>Scope</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Lifecycle scope for dependencies.</p> Values <p>SINGLETON: One instance for the process/container. REQUEST: One instance per request context. SESSION: One instance per longer-lived session context. TRANSIENT: A new instance for every resolution.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>class Scope(Enum):\n    \"\"\"Lifecycle scope for dependencies.\n\n    Values:\n        SINGLETON: One instance for the process/container.\n        REQUEST: One instance per request context.\n        SESSION: One instance per longer-lived session context.\n        TRANSIENT: A new instance for every resolution.\n    \"\"\"\n\n    SINGLETON = auto()  # Process-wide singleton\n    REQUEST = auto()  # Request/context scoped\n    SESSION = auto()  # Session scoped\n    TRANSIENT = auto()  # New instance every time\n</code></pre>"},{"location":"api/#pyinj.SessionScope","title":"<code>SessionScope</code>","text":"<p>Helper class for session-scoped dependencies.</p> Example <p>with SessionScope(container) as scope:     user = scope.resolve(UserToken)</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>class SessionScope:\n    \"\"\"\n    Helper class for session-scoped dependencies.\n\n    Example:\n        with SessionScope(container) as scope:\n            user = scope.resolve(UserToken)\n    \"\"\"\n\n    def __init__(self, container: ContextualContainer):\n        \"\"\"Initialize session scope.\"\"\"\n        self.container = container\n        self._context_manager = None\n\n    def __enter__(self) -&gt; SessionScope:\n        \"\"\"Enter session scope.\"\"\"\n        self._context_manager = self.container.session_scope()\n        self._context_manager.__enter__()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        \"\"\"Exit session scope.\"\"\"\n        if self._context_manager:\n            self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.SessionScope.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter session scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __enter__(self) -&gt; SessionScope:\n    \"\"\"Enter session scope.\"\"\"\n    self._context_manager = self.container.session_scope()\n    self._context_manager.__enter__()\n    return self\n</code></pre>"},{"location":"api/#pyinj.SessionScope.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit session scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n    \"\"\"Exit session scope.\"\"\"\n    if self._context_manager:\n        self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.SessionScope.__init__","title":"<code>__init__(container)</code>","text":"<p>Initialize session scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __init__(self, container: ContextualContainer):\n    \"\"\"Initialize session scope.\"\"\"\n    self.container = container\n    self._context_manager = None\n</code></pre>"},{"location":"api/#pyinj.Token","title":"<code>Token</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Immutable, hashable identifier for a typed dependency.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Human-readable name for the binding.</p> required <code>type_</code> <code>type[T]</code> <p>The expected Python type of the dependency.</p> required <code>scope</code> <code>Scope</code> <p>Lifecycle scope. Defaults to TRANSIENT.</p> <code>TRANSIENT</code> <code>qualifier</code> <code>str | None</code> <p>Optional qualifier to differentiate multiple bindings of the same type.</p> <code>None</code> <code>tags</code> <code>tuple[str, ...]</code> <p>Optional tags for discovery/metadata.</p> <code>tuple()</code> Example <p>LOGGER = TokenLogger</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass Token(Generic[T]):\n    \"\"\"Immutable, hashable identifier for a typed dependency.\n\n    Args:\n        name: Human-readable name for the binding.\n        type_: The expected Python type of the dependency.\n        scope: Lifecycle scope. Defaults to TRANSIENT.\n        qualifier: Optional qualifier to differentiate multiple bindings of the same type.\n        tags: Optional tags for discovery/metadata.\n\n    Example:\n        LOGGER = Token[Logger](\"logger\", scope=Scope.SINGLETON)\n    \"\"\"\n\n    name: str\n    type_: type[T]\n    scope: Scope = Scope.TRANSIENT\n    qualifier: str | None = None\n    tags: tuple[str, ...] = field(default_factory=tuple)\n    _hash: int = field(init=False, repr=False, compare=False)\n    _metadata: dict[str, Any] = field(default_factory=dict, repr=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        # Pre-compute hash for performance\n        hash_tuple = (\n            self.name,\n            self.type_.__module__ if hasattr(self.type_, \"__module__\") else \"\",\n            self.type_.__name__ if hasattr(self.type_, \"__name__\") else str(self.type_),\n            self.scope.value,\n            self.qualifier,\n            self.tags,\n        )\n        object.__setattr__(self, \"_hash\", hash(hash_tuple))\n\n        # Make metadata immutable\n        if self._metadata:\n            object.__setattr__(self, \"_metadata\", MappingProxyType(self._metadata))\n\n    def __hash__(self) -&gt; int:  # pragma: no cover - trivial\n        return self._hash\n\n    def __eq__(self, other: object) -&gt; bool:  # pragma: no cover - trivial\n        if not isinstance(other, Token):\n            return False\n        if self._hash != other._hash:\n            return False\n        return (\n            self.name == other.name\n            and self.type_ == other.type_\n            and self.scope == other.scope\n            and self.qualifier == other.qualifier\n            and self.tags == other.tags\n        )\n\n    @property\n    def metadata(self) -&gt; MappingProxyType[str, Any]:\n        \"\"\"Read-only view of metadata.\"\"\"\n        return self._metadata  # type: ignore[return-value]\n\n    @property\n    def qualified_name(self) -&gt; str:\n        \"\"\"Fully qualified name including module, type, qualifier, and token name.\"\"\"\n        parts: list[str] = []\n        if hasattr(self.type_, \"__module__\"):\n            parts.append(self.type_.__module__)  # type: ignore[arg-type]\n        parts.append(getattr(self.type_, \"__name__\", str(self.type_)))\n        if self.qualifier:\n            parts.append(self.qualifier)\n        parts.append(self.name)\n        return \".\".join(parts)\n\n    def with_scope(self, scope: Scope) -&gt; Token[T]:\n        \"\"\"Return a copy of this token with a different scope.\"\"\"\n        return Token(\n            name=self.name,\n            type_=self.type_,\n            scope=scope,\n            qualifier=self.qualifier,\n            tags=self.tags,\n            _metadata=dict(self._metadata) if self._metadata else {},\n        )\n\n    def with_qualifier(self, qualifier: str) -&gt; Token[T]:\n        \"\"\"Return a copy of this token with a qualifier.\"\"\"\n        return Token(\n            name=self.name,\n            type_=self.type_,\n            scope=self.scope,\n            qualifier=qualifier,\n            tags=self.tags,\n            _metadata=dict(self._metadata) if self._metadata else {},\n        )\n\n    def with_tags(self, *tags: str) -&gt; Token[T]:\n        \"\"\"Return a copy of this token with tags merged in (set semantics).\"\"\"\n        return Token(\n            name=self.name,\n            type_=self.type_,\n            scope=self.scope,\n            qualifier=self.qualifier,\n            tags=tuple(set(self.tags) | set(tags)),\n            _metadata=dict(self._metadata) if self._metadata else {},\n        )\n\n    def __repr__(self) -&gt; str:  # pragma: no cover - representation\n        type_name = getattr(self.type_, \"__name__\", str(self.type_))\n        parts = [f\"Token('{self.name}', {type_name}\"]\n        if self.scope != Scope.TRANSIENT:\n            parts.append(f\", scope={self.scope.name}\")\n        if self.qualifier:\n            parts.append(f\", qualifier='{self.qualifier}'\")\n        if self.tags:\n            parts.append(f\", tags={self.tags}\")\n        return \"\".join(parts) + \")\"\n\n    def validate(self, instance: Any) -&gt; bool:\n        \"\"\"Validate instance type against the token's expected type.\n\n        Returns False only when ``isinstance(instance, type_)`` is definitively False.\n        If runtime type information is insufficient, returns True.\n        \"\"\"\n        try:\n            return isinstance(instance, self.type_)\n        except Exception:\n            return True\n</code></pre>"},{"location":"api/#pyinj.Token.metadata","title":"<code>metadata</code>  <code>property</code>","text":"<p>Read-only view of metadata.</p>"},{"location":"api/#pyinj.Token.qualified_name","title":"<code>qualified_name</code>  <code>property</code>","text":"<p>Fully qualified name including module, type, qualifier, and token name.</p>"},{"location":"api/#pyinj.Token.validate","title":"<code>validate(instance)</code>","text":"<p>Validate instance type against the token's expected type.</p> <p>Returns False only when <code>isinstance(instance, type_)</code> is definitively False. If runtime type information is insufficient, returns True.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def validate(self, instance: Any) -&gt; bool:\n    \"\"\"Validate instance type against the token's expected type.\n\n    Returns False only when ``isinstance(instance, type_)`` is definitively False.\n    If runtime type information is insufficient, returns True.\n    \"\"\"\n    try:\n        return isinstance(instance, self.type_)\n    except Exception:\n        return True\n</code></pre>"},{"location":"api/#pyinj.Token.with_qualifier","title":"<code>with_qualifier(qualifier)</code>","text":"<p>Return a copy of this token with a qualifier.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def with_qualifier(self, qualifier: str) -&gt; Token[T]:\n    \"\"\"Return a copy of this token with a qualifier.\"\"\"\n    return Token(\n        name=self.name,\n        type_=self.type_,\n        scope=self.scope,\n        qualifier=qualifier,\n        tags=self.tags,\n        _metadata=dict(self._metadata) if self._metadata else {},\n    )\n</code></pre>"},{"location":"api/#pyinj.Token.with_scope","title":"<code>with_scope(scope)</code>","text":"<p>Return a copy of this token with a different scope.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def with_scope(self, scope: Scope) -&gt; Token[T]:\n    \"\"\"Return a copy of this token with a different scope.\"\"\"\n    return Token(\n        name=self.name,\n        type_=self.type_,\n        scope=scope,\n        qualifier=self.qualifier,\n        tags=self.tags,\n        _metadata=dict(self._metadata) if self._metadata else {},\n    )\n</code></pre>"},{"location":"api/#pyinj.Token.with_tags","title":"<code>with_tags(*tags)</code>","text":"<p>Return a copy of this token with tags merged in (set semantics).</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def with_tags(self, *tags: str) -&gt; Token[T]:\n    \"\"\"Return a copy of this token with tags merged in (set semantics).\"\"\"\n    return Token(\n        name=self.name,\n        type_=self.type_,\n        scope=self.scope,\n        qualifier=self.qualifier,\n        tags=tuple(set(self.tags) | set(tags)),\n        _metadata=dict(self._metadata) if self._metadata else {},\n    )\n</code></pre>"},{"location":"api/#pyinj.TokenFactory","title":"<code>TokenFactory</code>","text":"<p>Factory for creating and caching commonly used tokens.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>class TokenFactory:\n    \"\"\"Factory for creating and caching commonly used tokens.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._cache: dict[tuple[str, type[Any], Scope, str | None], Token[Any]] = {}\n\n    def create(\n        self,\n        name: str,\n        type_: type[T],\n        scope: Scope = Scope.TRANSIENT,\n        qualifier: str | None = None,\n        tags: tuple[str, ...] = (),\n    ) -&gt; Token[T]:\n        \"\"\"Create a token, with a small internal cache for common shapes.\"\"\"\n        cache_key = (name, type_, scope, qualifier)\n        if not tags and cache_key in self._cache:\n            return cast(Token[T], self._cache[cache_key])\n        token: Token[T] = Token(\n            name=name, type_=type_, scope=scope, qualifier=qualifier, tags=tags\n        )\n        if not tags:\n            self._cache[cache_key] = cast(Token[Any], token)\n        return token\n\n    def singleton(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a singleton-scoped token.\"\"\"\n        return self.create(name, type_, scope=Scope.SINGLETON)\n\n    def request(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a request-scoped token.\"\"\"\n        return self.create(name, type_, scope=Scope.REQUEST)\n\n    def session(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a session-scoped token.\"\"\"\n        return self.create(name, type_, scope=Scope.SESSION)\n\n    def transient(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a transient-scoped token (default).\"\"\"\n        return self.create(name, type_, scope=Scope.TRANSIENT)\n\n    def qualified(\n        self, qualifier: str, type_: type[T], scope: Scope = Scope.TRANSIENT\n    ) -&gt; Token[T]:\n        \"\"\"Create a qualified token for the given type and scope.\"\"\"\n        name = getattr(type_, \"__name__\", str(type_))\n        return self.create(name, type_, scope=scope, qualifier=qualifier)\n\n    def clear_cache(self) -&gt; None:\n        \"\"\"Clear the internal token cache (harmless).\"\"\"\n        self._cache.clear()\n\n    @property\n    def cache_size(self) -&gt; int:\n        \"\"\"Number of cached token shapes currently held.\"\"\"\n        return len(self._cache)\n</code></pre>"},{"location":"api/#pyinj.TokenFactory.cache_size","title":"<code>cache_size</code>  <code>property</code>","text":"<p>Number of cached token shapes currently held.</p>"},{"location":"api/#pyinj.TokenFactory.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear the internal token cache (harmless).</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear the internal token cache (harmless).\"\"\"\n    self._cache.clear()\n</code></pre>"},{"location":"api/#pyinj.TokenFactory.create","title":"<code>create(name, type_, scope=Scope.TRANSIENT, qualifier=None, tags=())</code>","text":"<p>Create a token, with a small internal cache for common shapes.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def create(\n    self,\n    name: str,\n    type_: type[T],\n    scope: Scope = Scope.TRANSIENT,\n    qualifier: str | None = None,\n    tags: tuple[str, ...] = (),\n) -&gt; Token[T]:\n    \"\"\"Create a token, with a small internal cache for common shapes.\"\"\"\n    cache_key = (name, type_, scope, qualifier)\n    if not tags and cache_key in self._cache:\n        return cast(Token[T], self._cache[cache_key])\n    token: Token[T] = Token(\n        name=name, type_=type_, scope=scope, qualifier=qualifier, tags=tags\n    )\n    if not tags:\n        self._cache[cache_key] = cast(Token[Any], token)\n    return token\n</code></pre>"},{"location":"api/#pyinj.TokenFactory.qualified","title":"<code>qualified(qualifier, type_, scope=Scope.TRANSIENT)</code>","text":"<p>Create a qualified token for the given type and scope.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def qualified(\n    self, qualifier: str, type_: type[T], scope: Scope = Scope.TRANSIENT\n) -&gt; Token[T]:\n    \"\"\"Create a qualified token for the given type and scope.\"\"\"\n    name = getattr(type_, \"__name__\", str(type_))\n    return self.create(name, type_, scope=scope, qualifier=qualifier)\n</code></pre>"},{"location":"api/#pyinj.TokenFactory.request","title":"<code>request(name, type_)</code>","text":"<p>Create a request-scoped token.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def request(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a request-scoped token.\"\"\"\n    return self.create(name, type_, scope=Scope.REQUEST)\n</code></pre>"},{"location":"api/#pyinj.TokenFactory.session","title":"<code>session(name, type_)</code>","text":"<p>Create a session-scoped token.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def session(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a session-scoped token.\"\"\"\n    return self.create(name, type_, scope=Scope.SESSION)\n</code></pre>"},{"location":"api/#pyinj.TokenFactory.singleton","title":"<code>singleton(name, type_)</code>","text":"<p>Create a singleton-scoped token.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def singleton(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a singleton-scoped token.\"\"\"\n    return self.create(name, type_, scope=Scope.SINGLETON)\n</code></pre>"},{"location":"api/#pyinj.TokenFactory.transient","title":"<code>transient(name, type_)</code>","text":"<p>Create a transient-scoped token (default).</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def transient(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a transient-scoped token (default).\"\"\"\n    return self.create(name, type_, scope=Scope.TRANSIENT)\n</code></pre>"},{"location":"api/#pyinj.Depends","title":"<code>Depends(provider)</code>","text":"<p>FastAPI-compatible <code>Depends</code> marker.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>Callable[..., T]</code> <p>Provider function for the dependency</p> required <p>Returns:</p> Name Type Description <code>An</code> <code>T</code> <p>class:<code>Inject</code> marker usable as a default parameter value.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def Depends[T](provider: Callable[..., T]) -&gt; T:  # noqa: N802\n    \"\"\"\n    FastAPI-compatible ``Depends`` marker.\n\n    Args:\n        provider: Provider function for the dependency\n\n    Returns:\n        An :class:`Inject` marker usable as a default parameter value.\n    \"\"\"\n    return Inject(provider)  # type: ignore\n</code></pre>"},{"location":"api/#pyinj.get_default_container","title":"<code>get_default_container()</code>","text":"<p>Get the global default container.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def get_default_container() -&gt; Container:\n    \"\"\"Get the global default container.\"\"\"\n    global _default_container\n    if _default_container is None:\n        _default_container = Container()\n    return _default_container\n</code></pre>"},{"location":"api/#pyinj.inject","title":"<code>inject(func=None, *, container=None, cache=True)</code>","text":"<p>Decorator that injects dependencies into function parameters.</p> <p>This is the main entry point for dependency injection, inspired by FastAPI's dependency injection system.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any] | None</code> <p>Function to decorate (or None if using with parameters)</p> <code>None</code> <code>container</code> <code>Any | None</code> <p>Container to resolve dependencies from</p> <code>None</code> <code>cache</code> <code>bool</code> <p>Whether to cache dependency analysis</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>Decorated function with automatic dependency injection</p> <p>Examples:</p> <p>@inject def service(db: Inject[Database]):     return db.query()</p> <p>@inject(container=my_container) async def handler(cache: Inject[Cache]):     return await cache.get(\"key\")</p> <p>@inject async def endpoint(     user_id: int,     db: Inject[Database],     cache: Given[Cache],     settings: Settings = Inject() ):     # Mixed regular and injected parameters     pass</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def inject(\n    func: Callable[..., Any] | None = None,\n    *,\n    container: Any | None = None,\n    cache: bool = True,\n) -&gt; Callable[..., Any]:\n    \"\"\"\n    Decorator that injects dependencies into function parameters.\n\n    This is the main entry point for dependency injection, inspired by\n    FastAPI's dependency injection system.\n\n    Args:\n        func: Function to decorate (or None if using with parameters)\n        container: Container to resolve dependencies from\n        cache: Whether to cache dependency analysis\n\n    Returns:\n        Decorated function with automatic dependency injection\n\n    Examples:\n        @inject\n        def service(db: Inject[Database]):\n            return db.query()\n\n        @inject(container=my_container)\n        async def handler(cache: Inject[Cache]):\n            return await cache.get(\"key\")\n\n        @inject\n        async def endpoint(\n            user_id: int,\n            db: Inject[Database],\n            cache: Given[Cache],\n            settings: Settings = Inject()\n        ):\n            # Mixed regular and injected parameters\n            pass\n    \"\"\"\n\n    def decorator(fn: Callable[..., Any]) -&gt; Callable[..., Any]:\n        # Analyze dependencies (cached if cache=True)\n        deps = InjectionAnalyzer.build_plan(fn) if cache else None\n\n        if iscoroutinefunction(fn):\n\n            @wraps(fn)\n            async def async_wrapper(*args: object, **kwargs: object) -&gt; Any:\n                # Get dependencies if not cached\n                nonlocal deps\n                if deps is None:\n                    deps = InjectionAnalyzer.build_plan(fn)\n\n                if not deps:\n                    # No dependencies, call original\n                    return await fn(*args, **kwargs)\n\n                # Get container\n                nonlocal container\n                if container is None:\n                    # Try to get default container without import cycle\n                    from .container import get_default_container\n\n                    container = get_default_container()\n\n                # Extract overrides from kwargs\n                overrides: dict[str, Any] = {}\n                for name in deps:\n                    if name in kwargs:  # type: ignore[operator]\n                        overrides[name] = cast(Any, kwargs.pop(name))  # type: ignore[call-arg]\n\n                # Resolve dependencies\n                resolved = await resolve_dependencies_async(deps, container, overrides)\n\n                # Merge with kwargs\n                kwargs.update(resolved)\n\n                return await fn(*args, **kwargs)  # type: ignore[misc]\n\n            return async_wrapper\n\n        else:\n\n            @wraps(fn)\n            def sync_wrapper(*args: object, **kwargs: object) -&gt; Any:\n                # Get dependencies if not cached\n                nonlocal deps\n                if deps is None:\n                    deps = InjectionAnalyzer.build_plan(fn)\n\n                if not deps:\n                    # No dependencies, call original\n                    return fn(*args, **kwargs)\n\n                # Get container\n                nonlocal container\n                if container is None:\n                    from .container import get_default_container\n\n                    container = get_default_container()\n\n                # Extract overrides from kwargs\n                overrides: dict[str, Any] = {}\n                for name in deps:\n                    if name in kwargs:  # type: ignore[operator]\n                        overrides[name] = cast(Any, kwargs.pop(name))  # type: ignore[call-arg]\n\n                # Resolve dependencies\n                resolved = resolve_dependencies(deps, container, overrides)\n\n                # Merge with kwargs\n                kwargs.update(resolved)\n\n                return fn(*args, **kwargs)  # type: ignore[misc]\n\n            return sync_wrapper\n\n    # Handle both @inject and @inject(...) syntax\n    if func is None:\n        # Called with parameters: @inject(container=...)\n        return decorator\n    else:\n        # Called without parameters: @inject\n        return decorator(func)\n</code></pre>"},{"location":"api/#pyinj.set_default_container","title":"<code>set_default_container(container)</code>","text":"<p>Set the global default container.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def set_default_container(container: Container) -&gt; None:\n    \"\"\"Set the global default container.\"\"\"\n    global _default_container\n    _default_container = container\n</code></pre>"},{"location":"api/#container","title":"Container","text":"<p>               Bases: <code>ContextualContainer</code></p> <p>Ergonomic, type-safe DI container with async support.</p> <p>Features: - O(1) lookups with a compact registry - Thread/async-safe singleton initialization - Contextual scoping using <code>contextvars</code> (request/session) - Scala-inspired \"given\" instances for testability - Method chaining for concise setup and batch operations</p> Example <p>container = Container() LOGGER = TokenLogger container.register_singleton(LOGGER, ConsoleLogger)</p> <p>@inject def handler(logger: Inject[Logger]):     logger.info(\"hello\")</p> Source code in <code>src/pyinj/container.py</code> <pre><code>class Container(ContextualContainer):\n    \"\"\"Ergonomic, type-safe DI container with async support.\n\n    Features:\n    - O(1) lookups with a compact registry\n    - Thread/async-safe singleton initialization\n    - Contextual scoping using ``contextvars`` (request/session)\n    - Scala-inspired \"given\" instances for testability\n    - Method chaining for concise setup and batch operations\n\n    Example:\n        container = Container()\n        LOGGER = Token[Logger](\"logger\")\n        container.register_singleton(LOGGER, ConsoleLogger)\n\n        @inject\n        def handler(logger: Inject[Logger]):\n            logger.info(\"hello\")\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize enhanced container.\"\"\"\n        super().__init__()\n\n        # Token factory for convenient creation\n        self.tokens: TokenFactory = TokenFactory()\n\n        # Given instances (Scala-inspired)\n        self._given_providers: dict[type[Any], Provider] = {}\n\n        # Override less-precise base attributes with typed variants\n        self._providers: dict[Token[Any], Provider] = {}\n        self._token_scopes: dict[Token[Any], Scope] = {}\n        self._singletons: dict[Token[Any], Any] = {}\n        self._async_locks: dict[Token[Any], asyncio.Lock] = {}\n\n        # Performance metrics\n        self._resolution_times: deque[float] = deque(maxlen=1000)\n        self._cache_hits: int = 0\n        self._cache_misses: int = 0\n\n        # Thread safety\n        self._lock: threading.RLock = threading.RLock()\n        self._singleton_locks: dict[Token[Any], threading.Lock] = defaultdict(\n            threading.Lock\n        )\n\n        # Track dependencies for graph\n        self._dependencies: dict[Token[Any], set[Token[Any]]] = defaultdict(set)\n\n        # Per-context overrides (DI_SPEC requirement)\n        self._overrides: ContextVar[dict[Token[Any], Any] | None] = ContextVar(\n            \"pyinj_overrides\",\n            default=None,\n        )\n\n        # Thread-local resolution tracking for cycle detection\n        self._local = threading.local()\n\n    # ============= Internal Helpers (Phase 1) =============\n\n    def _coerce_to_token(self, spec: Token[Any] | type[Any]) -&gt; Token[Any]:\n        if isinstance(spec, Token):\n            return spec\n        if isinstance(spec, type):\n            for registered in self._providers:\n                if registered.type_ == spec:\n                    return registered\n            return Token(spec.__name__, spec)\n        # Disallow string-based tokens for type safety\n        raise TypeError(\n            \"Token specification must be a Token or type; strings are not supported\"\n        )\n\n    def _get_override(self, token: Token[Any]) -&gt; Any | None:\n        current = self._overrides.get()\n        if current and token in current:\n            return current[token]\n        return None\n\n    def _resolution_stack(self) -&gt; list[Token[Any]]:\n        stack = getattr(self._local, \"resolving\", None)\n        if not isinstance(stack, list):\n            new_stack: list[Token[Any]] = []\n            self._local.resolving = new_stack\n            return new_stack\n        return cast(list[Token[Any]], stack)\n\n    @contextmanager\n    def _resolution_guard(self, token: Token[Any]):\n        stack = self._resolution_stack()\n        if token in stack:\n            raise CircularDependencyError(token, list(stack))\n        stack.append(token)\n        try:\n            yield\n        finally:\n            stack.pop()\n\n    # ============= Registration Methods =============\n\n    def register(\n        self,\n        token: Token[Any] | type[Any],\n        provider: Provider,\n        scope: Scope | None = None,\n        *,\n        tags: tuple[str, ...] = (),\n    ) -&gt; Container:\n        \"\"\"Register a provider for a token.\n\n        Args:\n            token: A ``Token[T]`` or a concrete ``type[T]``. If a type is\n                provided, a token is created automatically.\n            provider: Callable that returns the dependency instance.\n            scope: Optional lifecycle override (defaults to token.scope or TRANSIENT).\n            tags: Optional tags for discovery/metadata.\n\n        Returns:\n            Self, to allow method chaining.\n\n        Example:\n            container.register(Token[DB](\"db\"), create_db, scope=Scope.SINGLETON)\n        \"\"\"\n        # Convert to Token if needed\n        if isinstance(token, type):\n            token = self.tokens.create(\n                token.__name__, token, scope=scope or Scope.TRANSIENT, tags=tags\n            )\n        elif scope is not None:\n            # Record desired scope without changing the token identity\n            self._token_scopes[token] = scope\n\n        # Validate provider\n        if not callable(provider):\n            raise TypeError(\n                f\"Provider must be callable, got {type(provider).__name__}\\n\"\n                f\"  Fix: Pass a function or lambda that returns an instance\\n\"\n                f\"  Example: container.register(token, lambda: {token.type_.__name__}())\"\n            )\n\n        with self._lock:\n            self._providers[token] = provider\n\n        return self  # Enable chaining\n\n    def register_singleton(\n        self, token: Token[Any] | type[Any], provider: Provider\n    ) -&gt; Container:\n        \"\"\"Register a singleton-scoped dependency.\"\"\"\n        return self.register(token, provider, scope=Scope.SINGLETON)\n\n    def register_request(\n        self, token: Token[Any] | type[Any], provider: Provider\n    ) -&gt; Container:\n        \"\"\"Register a request-scoped dependency.\"\"\"\n        return self.register(token, provider, scope=Scope.REQUEST)\n\n    def register_transient(\n        self, token: Token[Any] | type[Any], provider: Provider\n    ) -&gt; Container:\n        \"\"\"Register a transient-scoped dependency.\"\"\"\n        return self.register(token, provider, scope=Scope.TRANSIENT)\n\n    def register_value(self, token: Token[Any] | type[Any], value: Any) -&gt; Container:\n        \"\"\"Register a pre-created value as a singleton.\"\"\"\n        if isinstance(token, type):\n            token = self.tokens.singleton(token.__name__, token)\n        # token is now a Token[Any]\n\n        # Store directly as singleton\n        self._singletons[token] = value\n        return self\n\n    def override(self, token: Token[Any], value: Any) -&gt; None:\n        \"\"\"Override a dependency with a specific value for this container.\n\n        Prefer the ``use_overrides`` context manager for scoped overrides\n        in concurrent test scenarios.\n        \"\"\"\n        self._singletons[token] = value\n\n    # ============= Given Instances (Scala-inspired) =============\n\n    def given(self, type_: type[Any], provider: Provider | Any) -&gt; Container:\n        \"\"\"Register a given instance for a type (Scala-style).\"\"\"\n        if callable(provider):\n            self._given_providers[type_] = provider\n        else:\n            # Wrap value in lambda\n            self._given_providers[type_] = lambda p=provider: p\n\n        return self\n\n    def resolve_given(self, type_: type[T]) -&gt; T | None:\n        \"\"\"Resolve a given instance by type.\"\"\"\n        provider = self._given_providers.get(type_)\n        if provider:\n            return provider()\n        return None\n\n    @contextmanager\n    def using(self, **givens: Any) -&gt; Iterator[Container]:\n        \"\"\"Scala-style using clause for temporary givens.\"\"\"\n        old_givens = self._given_providers.copy()\n\n        # Add temporary givens\n        for type_name, instance in givens.items():\n            if isinstance(type_name, type):\n                self.given(type_name, instance)\n\n        try:\n            yield self\n        finally:\n            self._given_providers = old_givens\n\n    # ============= Resolution Methods =============\n\n    def get(self, token: Token[Any] | type[Any]) -&gt; Any:\n        \"\"\"Resolve a dependency synchronously.\n\n        Args:\n            token: The ``Token[T]`` or ``type[T]`` to resolve.\n\n        Returns:\n            The resolved instance.\n\n        Raises:\n            ResolutionError: If no provider is registered or resolution fails.\n        \"\"\"\n        # Convert to token if needed and handle givens\n        if isinstance(token, type):\n            given = self.resolve_given(token)\n            if given is not None:\n                return given\n        token = self._coerce_to_token(token)\n\n        # Check per-context overrides first\n        override = self._get_override(token)\n        if override is not None:\n            self._cache_hits += 1\n            return override\n\n        # Check context first\n        instance = self.resolve_from_context(token)\n        if instance is not None:\n            self._cache_hits += 1\n            return instance\n\n        self._cache_misses += 1\n\n        with self._resolution_guard(token):\n            # Get provider\n            provider = self._providers.get(token)\n            if provider is None:\n                raise ResolutionError(\n                    token, [], f\"No provider registered for token '{token.name}'\"\n                )\n\n            # Create instance based on scope\n            effective_scope = self._token_scopes.get(token, token.scope)\n            if effective_scope == Scope.SINGLETON:\n                with self._singleton_locks[token]:\n                    if token in self._singletons:\n                        return self._singletons[token]\n                    if asyncio.iscoroutinefunction(provider):\n                        raise ResolutionError(\n                            token,\n                            [],\n                            \"Provider is async; use aget() for async providers\",\n                        )\n                    instance = provider()\n                    self._validate_and_track(token, instance)\n                    self._singletons[token] = instance\n                    return instance\n            else:\n                if asyncio.iscoroutinefunction(provider):\n                    raise ResolutionError(\n                        token,\n                        [],\n                        \"Provider is async; use aget() for async providers\",\n                    )\n                instance = provider()\n                self._validate_and_track(token, instance)\n                self.store_in_context(token, instance)\n                return instance\n\n    async def aget(self, token: Token[Any] | type[Any]) -&gt; Any:\n        \"\"\"Resolve a dependency asynchronously.\n\n        Equivalent to :meth:`get` but awaits async providers and uses\n        async locks for singleton initialization.\n        \"\"\"\n        # Convert to token if needed\n        if isinstance(token, type):\n            given = self.resolve_given(token)\n            if given is not None:\n                return given\n        token = self._coerce_to_token(token)\n\n        # Check per-context overrides first\n        override = self._get_override(token)\n        if override is not None:\n            self._cache_hits += 1\n            return override\n\n        # Check context first\n        instance = self.resolve_from_context(token)\n        if instance is not None:\n            self._cache_hits += 1\n            return instance\n\n        self._cache_misses += 1\n\n        with self._resolution_guard(token):\n            # Get provider\n            provider = self._providers.get(token)\n            if provider is None:\n                raise ResolutionError(\n                    token, [], f\"No provider registered for token '{token.name}'\"\n                )\n\n            # Create instance based on scope\n            effective_scope = self._token_scopes.get(token, token.scope)\n            if effective_scope == Scope.SINGLETON:\n                # Ensure async lock exists\n                if token not in self._async_locks:\n                    self._async_locks[token] = asyncio.Lock()\n\n                async with self._async_locks[token]:\n                    if token in self._singletons:\n                        return self._singletons[token]\n\n                    if asyncio.iscoroutinefunction(provider):\n                        instance = await provider()\n                    else:\n                        instance = provider()\n                    self._validate_and_track(token, instance)\n\n                    self._singletons[token] = instance\n                    return instance\n            else:\n                if asyncio.iscoroutinefunction(provider):\n                    instance = await provider()\n                else:\n                    instance = provider()\n                self._validate_and_track(token, instance)\n\n                self.store_in_context(token, instance)\n                return instance\n\n    # ============= Batch Operations =============\n\n    def batch_register(\n        self, registrations: list[tuple[Token[Any], Provider]]\n    ) -&gt; Container:\n        \"\"\"Register multiple dependencies at once.\"\"\"\n        for token, provider in registrations:\n            self.register(token, provider)\n        return self\n\n    def batch_resolve(self, tokens: list[Token[Any]]) -&gt; dict[Token[Any], Any]:\n        \"\"\"Resolve multiple dependencies efficiently (sync).\"\"\"\n        sorted_tokens = sorted(tokens, key=lambda t: t.scope.value)\n        results: dict[Token[Any], Any] = {}\n        for _scope, group in groupby(sorted_tokens, key=lambda t: t.scope):\n            group_list = list(group)\n            for tk in group_list:\n                results[tk] = self.get(tk)\n        return results\n\n    async def batch_resolve_async(\n        self, tokens: list[Token[Any]]\n    ) -&gt; dict[Token[Any], Any]:\n        \"\"\"Async batch resolution with parallel execution.\"\"\"\n        tasks = {token: self.aget(token) for token in tokens}\n        results_list: list[Any] = await asyncio.gather(*tasks.values())\n        return dict(zip(tasks.keys(), results_list, strict=True))\n\n    # (Provider graph analysis intentionally omitted; can be added behind a feature flag.)\n\n    @lru_cache(maxsize=512)\n    def _get_resolution_path(self, token: Token[Any]) -&gt; tuple[Token[Any], ...]:\n        \"\"\"Get resolution path for a token (cached).\"\"\"\n        return (token,)\n\n    @property\n    def cache_hit_rate(self) -&gt; float:\n        total = self._cache_hits + self._cache_misses\n        return 0.0 if total == 0 else self._cache_hits / total\n\n    def get_stats(self) -&gt; dict[str, Any]:\n        return {\n            \"total_providers\": len(self._providers),\n            \"singletons\": len(self._singletons),\n            \"cache_hits\": self._cache_hits,\n            \"cache_misses\": self._cache_misses,\n            \"cache_hit_rate\": self.cache_hit_rate,\n            \"avg_resolution_time\": (\n                sum(self._resolution_times) / len(self._resolution_times)\n                if self._resolution_times\n                else 0\n            ),\n        }\n\n    # ============= Utilities =============\n\n    def get_providers_view(self) -&gt; MappingProxyType:\n        \"\"\"Return a read-only view of registered providers.\"\"\"\n        return MappingProxyType(self._providers)\n\n    def has(self, token: Token[Any] | type[Any]) -&gt; bool:\n        \"\"\"Return True if the token/type is known to the container.\"\"\"\n        if isinstance(token, type):\n            if token in self._given_providers:\n                return True\n            token = Token(token.__name__, token)\n        return token in self._providers or token in self._singletons\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear providers, caches, and statistics. Does not affect docs or code.\"\"\"\n        with self._lock:\n            self._providers.clear()\n            self._singletons.clear()\n            self._transients.clear()\n            self._given_providers.clear()\n            self._dependencies.clear()\n            self._cache_hits = 0\n            self._cache_misses = 0\n            self._resolution_times.clear()\n        self.clear_all_contexts()\n\n    def __repr__(self) -&gt; str:\n        return (\n            \"Container(\"\n            f\"providers={len(self._providers)}, \"\n            f\"singletons={len(self._singletons)}, \"\n            f\"cache_hit_rate={self.cache_hit_rate:.2%})\"\n        )\n\n    # ============= Decorator Alias =============\n\n    def inject(self, func: Callable[..., Any] | None = None, *, cache: bool = True) -&gt; Callable[..., Any]:\n        \"\"\"Alias to :func:`pyinj.injection.inject` bound to this container.\n\n        Enables ``@container.inject`` usage in addition to ``@inject(container=container)``.\n        \"\"\"\n        from .injection import inject as _inject\n\n        if func is None:\n            return _inject(container=self, cache=cache)\n        return _inject(func, container=self, cache=cache)\n\n    # ============= Context Managers &amp; Cleanup =============\n\n    def __enter__(self) -&gt; Container:  # pragma: no cover - trivial\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:  # pragma: no cover - trivial\n        for resource in reversed(self._resources):\n            try:\n                if hasattr(resource, \"close\"):\n                    resource.close()\n            except Exception:\n                pass\n\n    async def __aenter__(self) -&gt; Container:  # pragma: no cover - trivial\n        return self\n\n    async def __aexit__(\n        self, exc_type, exc_val, exc_tb\n    ) -&gt; None:  # pragma: no cover - trivial\n        tasks = []\n        for resource in reversed(self._resources):\n            if hasattr(resource, \"aclose\"):\n                tasks.append(resource.aclose())\n        if tasks:\n            await asyncio.gather(*tasks, return_exceptions=True)\n\n    async def aclose(self) -&gt; None:\n        \"\"\"Async close: close tracked resources and clear caches.\"\"\"\n        await self.__aexit__(None, None, None)\n        self.clear()\n\n    async def dispose(self) -&gt; None:\n        \"\"\"Alias for aclose to align with tests and docs.\"\"\"\n        await self.aclose()\n\n    @contextmanager\n    def use_overrides(self, mapping: dict[Token[Any], Any]) -&gt; Any:\n        \"\"\"Temporarily override tokens for this concurrent context.\n\n        Example:\n            with container.use_overrides({LOGGER: fake_logger}):\n                svc = container.get(SERVICE)\n                ...\n        \"\"\"\n        parent = self._overrides.get()\n        merged: dict[Token[Any], Any] = dict(parent) if parent else {}\n        merged.update(mapping)\n        token: CtxToken = self._overrides.set(merged)\n        try:\n            yield\n        finally:\n            self._overrides.reset(token)\n\n    def clear_overrides(self) -&gt; None:\n        \"\"\"Clear all overrides for the current context.\"\"\"\n        if self._overrides.get() is not None:\n            self._overrides.set(None)\n\n    # ============= Validation &amp; Resource Tracking =============\n\n    def _validate_and_track(self, token: Token[Any], instance: Any) -&gt; None:\n        if not token.validate(instance):\n            raise TypeError(\n                f\"Provider for token '{token.name}' returned {type(instance).__name__}, expected {token.type_.__name__}\"\n            )\n        if isinstance(instance, (SupportsClose, SupportsAsyncClose)):\n            # track for later cleanup\n            self._resources.append(instance)\n</code></pre>"},{"location":"api/#pyinj.container.Container.__init__","title":"<code>__init__()</code>","text":"<p>Initialize enhanced container.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize enhanced container.\"\"\"\n    super().__init__()\n\n    # Token factory for convenient creation\n    self.tokens: TokenFactory = TokenFactory()\n\n    # Given instances (Scala-inspired)\n    self._given_providers: dict[type[Any], Provider] = {}\n\n    # Override less-precise base attributes with typed variants\n    self._providers: dict[Token[Any], Provider] = {}\n    self._token_scopes: dict[Token[Any], Scope] = {}\n    self._singletons: dict[Token[Any], Any] = {}\n    self._async_locks: dict[Token[Any], asyncio.Lock] = {}\n\n    # Performance metrics\n    self._resolution_times: deque[float] = deque(maxlen=1000)\n    self._cache_hits: int = 0\n    self._cache_misses: int = 0\n\n    # Thread safety\n    self._lock: threading.RLock = threading.RLock()\n    self._singleton_locks: dict[Token[Any], threading.Lock] = defaultdict(\n        threading.Lock\n    )\n\n    # Track dependencies for graph\n    self._dependencies: dict[Token[Any], set[Token[Any]]] = defaultdict(set)\n\n    # Per-context overrides (DI_SPEC requirement)\n    self._overrides: ContextVar[dict[Token[Any], Any] | None] = ContextVar(\n        \"pyinj_overrides\",\n        default=None,\n    )\n\n    # Thread-local resolution tracking for cycle detection\n    self._local = threading.local()\n</code></pre>"},{"location":"api/#pyinj.container.Container.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Async close: close tracked resources and clear caches.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"Async close: close tracked resources and clear caches.\"\"\"\n    await self.__aexit__(None, None, None)\n    self.clear()\n</code></pre>"},{"location":"api/#pyinj.container.Container.aget","title":"<code>aget(token)</code>  <code>async</code>","text":"<p>Resolve a dependency asynchronously.</p> <p>Equivalent to :meth:<code>get</code> but awaits async providers and uses async locks for singleton initialization.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def aget(self, token: Token[Any] | type[Any]) -&gt; Any:\n    \"\"\"Resolve a dependency asynchronously.\n\n    Equivalent to :meth:`get` but awaits async providers and uses\n    async locks for singleton initialization.\n    \"\"\"\n    # Convert to token if needed\n    if isinstance(token, type):\n        given = self.resolve_given(token)\n        if given is not None:\n            return given\n    token = self._coerce_to_token(token)\n\n    # Check per-context overrides first\n    override = self._get_override(token)\n    if override is not None:\n        self._cache_hits += 1\n        return override\n\n    # Check context first\n    instance = self.resolve_from_context(token)\n    if instance is not None:\n        self._cache_hits += 1\n        return instance\n\n    self._cache_misses += 1\n\n    with self._resolution_guard(token):\n        # Get provider\n        provider = self._providers.get(token)\n        if provider is None:\n            raise ResolutionError(\n                token, [], f\"No provider registered for token '{token.name}'\"\n            )\n\n        # Create instance based on scope\n        effective_scope = self._token_scopes.get(token, token.scope)\n        if effective_scope == Scope.SINGLETON:\n            # Ensure async lock exists\n            if token not in self._async_locks:\n                self._async_locks[token] = asyncio.Lock()\n\n            async with self._async_locks[token]:\n                if token in self._singletons:\n                    return self._singletons[token]\n\n                if asyncio.iscoroutinefunction(provider):\n                    instance = await provider()\n                else:\n                    instance = provider()\n                self._validate_and_track(token, instance)\n\n                self._singletons[token] = instance\n                return instance\n        else:\n            if asyncio.iscoroutinefunction(provider):\n                instance = await provider()\n            else:\n                instance = provider()\n            self._validate_and_track(token, instance)\n\n            self.store_in_context(token, instance)\n            return instance\n</code></pre>"},{"location":"api/#pyinj.container.Container.batch_register","title":"<code>batch_register(registrations)</code>","text":"<p>Register multiple dependencies at once.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def batch_register(\n    self, registrations: list[tuple[Token[Any], Provider]]\n) -&gt; Container:\n    \"\"\"Register multiple dependencies at once.\"\"\"\n    for token, provider in registrations:\n        self.register(token, provider)\n    return self\n</code></pre>"},{"location":"api/#pyinj.container.Container.batch_resolve","title":"<code>batch_resolve(tokens)</code>","text":"<p>Resolve multiple dependencies efficiently (sync).</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def batch_resolve(self, tokens: list[Token[Any]]) -&gt; dict[Token[Any], Any]:\n    \"\"\"Resolve multiple dependencies efficiently (sync).\"\"\"\n    sorted_tokens = sorted(tokens, key=lambda t: t.scope.value)\n    results: dict[Token[Any], Any] = {}\n    for _scope, group in groupby(sorted_tokens, key=lambda t: t.scope):\n        group_list = list(group)\n        for tk in group_list:\n            results[tk] = self.get(tk)\n    return results\n</code></pre>"},{"location":"api/#pyinj.container.Container.batch_resolve_async","title":"<code>batch_resolve_async(tokens)</code>  <code>async</code>","text":"<p>Async batch resolution with parallel execution.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def batch_resolve_async(\n    self, tokens: list[Token[Any]]\n) -&gt; dict[Token[Any], Any]:\n    \"\"\"Async batch resolution with parallel execution.\"\"\"\n    tasks = {token: self.aget(token) for token in tokens}\n    results_list: list[Any] = await asyncio.gather(*tasks.values())\n    return dict(zip(tasks.keys(), results_list, strict=True))\n</code></pre>"},{"location":"api/#pyinj.container.Container.clear","title":"<code>clear()</code>","text":"<p>Clear providers, caches, and statistics. Does not affect docs or code.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear providers, caches, and statistics. Does not affect docs or code.\"\"\"\n    with self._lock:\n        self._providers.clear()\n        self._singletons.clear()\n        self._transients.clear()\n        self._given_providers.clear()\n        self._dependencies.clear()\n        self._cache_hits = 0\n        self._cache_misses = 0\n        self._resolution_times.clear()\n    self.clear_all_contexts()\n</code></pre>"},{"location":"api/#pyinj.container.Container.clear_overrides","title":"<code>clear_overrides()</code>","text":"<p>Clear all overrides for the current context.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def clear_overrides(self) -&gt; None:\n    \"\"\"Clear all overrides for the current context.\"\"\"\n    if self._overrides.get() is not None:\n        self._overrides.set(None)\n</code></pre>"},{"location":"api/#pyinj.container.Container.dispose","title":"<code>dispose()</code>  <code>async</code>","text":"<p>Alias for aclose to align with tests and docs.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def dispose(self) -&gt; None:\n    \"\"\"Alias for aclose to align with tests and docs.\"\"\"\n    await self.aclose()\n</code></pre>"},{"location":"api/#pyinj.container.Container.get","title":"<code>get(token)</code>","text":"<p>Resolve a dependency synchronously.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[Any] | type[Any]</code> <p>The <code>Token[T]</code> or <code>type[T]</code> to resolve.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The resolved instance.</p> <p>Raises:</p> Type Description <code>ResolutionError</code> <p>If no provider is registered or resolution fails.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def get(self, token: Token[Any] | type[Any]) -&gt; Any:\n    \"\"\"Resolve a dependency synchronously.\n\n    Args:\n        token: The ``Token[T]`` or ``type[T]`` to resolve.\n\n    Returns:\n        The resolved instance.\n\n    Raises:\n        ResolutionError: If no provider is registered or resolution fails.\n    \"\"\"\n    # Convert to token if needed and handle givens\n    if isinstance(token, type):\n        given = self.resolve_given(token)\n        if given is not None:\n            return given\n    token = self._coerce_to_token(token)\n\n    # Check per-context overrides first\n    override = self._get_override(token)\n    if override is not None:\n        self._cache_hits += 1\n        return override\n\n    # Check context first\n    instance = self.resolve_from_context(token)\n    if instance is not None:\n        self._cache_hits += 1\n        return instance\n\n    self._cache_misses += 1\n\n    with self._resolution_guard(token):\n        # Get provider\n        provider = self._providers.get(token)\n        if provider is None:\n            raise ResolutionError(\n                token, [], f\"No provider registered for token '{token.name}'\"\n            )\n\n        # Create instance based on scope\n        effective_scope = self._token_scopes.get(token, token.scope)\n        if effective_scope == Scope.SINGLETON:\n            with self._singleton_locks[token]:\n                if token in self._singletons:\n                    return self._singletons[token]\n                if asyncio.iscoroutinefunction(provider):\n                    raise ResolutionError(\n                        token,\n                        [],\n                        \"Provider is async; use aget() for async providers\",\n                    )\n                instance = provider()\n                self._validate_and_track(token, instance)\n                self._singletons[token] = instance\n                return instance\n        else:\n            if asyncio.iscoroutinefunction(provider):\n                raise ResolutionError(\n                    token,\n                    [],\n                    \"Provider is async; use aget() for async providers\",\n                )\n            instance = provider()\n            self._validate_and_track(token, instance)\n            self.store_in_context(token, instance)\n            return instance\n</code></pre>"},{"location":"api/#pyinj.container.Container.get_providers_view","title":"<code>get_providers_view()</code>","text":"<p>Return a read-only view of registered providers.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def get_providers_view(self) -&gt; MappingProxyType:\n    \"\"\"Return a read-only view of registered providers.\"\"\"\n    return MappingProxyType(self._providers)\n</code></pre>"},{"location":"api/#pyinj.container.Container.given","title":"<code>given(type_, provider)</code>","text":"<p>Register a given instance for a type (Scala-style).</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def given(self, type_: type[Any], provider: Provider | Any) -&gt; Container:\n    \"\"\"Register a given instance for a type (Scala-style).\"\"\"\n    if callable(provider):\n        self._given_providers[type_] = provider\n    else:\n        # Wrap value in lambda\n        self._given_providers[type_] = lambda p=provider: p\n\n    return self\n</code></pre>"},{"location":"api/#pyinj.container.Container.has","title":"<code>has(token)</code>","text":"<p>Return True if the token/type is known to the container.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def has(self, token: Token[Any] | type[Any]) -&gt; bool:\n    \"\"\"Return True if the token/type is known to the container.\"\"\"\n    if isinstance(token, type):\n        if token in self._given_providers:\n            return True\n        token = Token(token.__name__, token)\n    return token in self._providers or token in self._singletons\n</code></pre>"},{"location":"api/#pyinj.container.Container.inject","title":"<code>inject(func=None, *, cache=True)</code>","text":"<p>Alias to :func:<code>pyinj.injection.inject</code> bound to this container.</p> <p>Enables <code>@container.inject</code> usage in addition to <code>@inject(container=container)</code>.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def inject(self, func: Callable[..., Any] | None = None, *, cache: bool = True) -&gt; Callable[..., Any]:\n    \"\"\"Alias to :func:`pyinj.injection.inject` bound to this container.\n\n    Enables ``@container.inject`` usage in addition to ``@inject(container=container)``.\n    \"\"\"\n    from .injection import inject as _inject\n\n    if func is None:\n        return _inject(container=self, cache=cache)\n    return _inject(func, container=self, cache=cache)\n</code></pre>"},{"location":"api/#pyinj.container.Container.override","title":"<code>override(token, value)</code>","text":"<p>Override a dependency with a specific value for this container.</p> <p>Prefer the <code>use_overrides</code> context manager for scoped overrides in concurrent test scenarios.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def override(self, token: Token[Any], value: Any) -&gt; None:\n    \"\"\"Override a dependency with a specific value for this container.\n\n    Prefer the ``use_overrides`` context manager for scoped overrides\n    in concurrent test scenarios.\n    \"\"\"\n    self._singletons[token] = value\n</code></pre>"},{"location":"api/#pyinj.container.Container.register","title":"<code>register(token, provider, scope=None, *, tags=())</code>","text":"<p>Register a provider for a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[Any] | type[Any]</code> <p>A <code>Token[T]</code> or a concrete <code>type[T]</code>. If a type is provided, a token is created automatically.</p> required <code>provider</code> <code>Provider</code> <p>Callable that returns the dependency instance.</p> required <code>scope</code> <code>Scope | None</code> <p>Optional lifecycle override (defaults to token.scope or TRANSIENT).</p> <code>None</code> <code>tags</code> <code>tuple[str, ...]</code> <p>Optional tags for discovery/metadata.</p> <code>()</code> <p>Returns:</p> Type Description <code>Container</code> <p>Self, to allow method chaining.</p> Example <p>container.register(TokenDB, create_db, scope=Scope.SINGLETON)</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register(\n    self,\n    token: Token[Any] | type[Any],\n    provider: Provider,\n    scope: Scope | None = None,\n    *,\n    tags: tuple[str, ...] = (),\n) -&gt; Container:\n    \"\"\"Register a provider for a token.\n\n    Args:\n        token: A ``Token[T]`` or a concrete ``type[T]``. If a type is\n            provided, a token is created automatically.\n        provider: Callable that returns the dependency instance.\n        scope: Optional lifecycle override (defaults to token.scope or TRANSIENT).\n        tags: Optional tags for discovery/metadata.\n\n    Returns:\n        Self, to allow method chaining.\n\n    Example:\n        container.register(Token[DB](\"db\"), create_db, scope=Scope.SINGLETON)\n    \"\"\"\n    # Convert to Token if needed\n    if isinstance(token, type):\n        token = self.tokens.create(\n            token.__name__, token, scope=scope or Scope.TRANSIENT, tags=tags\n        )\n    elif scope is not None:\n        # Record desired scope without changing the token identity\n        self._token_scopes[token] = scope\n\n    # Validate provider\n    if not callable(provider):\n        raise TypeError(\n            f\"Provider must be callable, got {type(provider).__name__}\\n\"\n            f\"  Fix: Pass a function or lambda that returns an instance\\n\"\n            f\"  Example: container.register(token, lambda: {token.type_.__name__}())\"\n        )\n\n    with self._lock:\n        self._providers[token] = provider\n\n    return self  # Enable chaining\n</code></pre>"},{"location":"api/#pyinj.container.Container.register_request","title":"<code>register_request(token, provider)</code>","text":"<p>Register a request-scoped dependency.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_request(\n    self, token: Token[Any] | type[Any], provider: Provider\n) -&gt; Container:\n    \"\"\"Register a request-scoped dependency.\"\"\"\n    return self.register(token, provider, scope=Scope.REQUEST)\n</code></pre>"},{"location":"api/#pyinj.container.Container.register_singleton","title":"<code>register_singleton(token, provider)</code>","text":"<p>Register a singleton-scoped dependency.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_singleton(\n    self, token: Token[Any] | type[Any], provider: Provider\n) -&gt; Container:\n    \"\"\"Register a singleton-scoped dependency.\"\"\"\n    return self.register(token, provider, scope=Scope.SINGLETON)\n</code></pre>"},{"location":"api/#pyinj.container.Container.register_transient","title":"<code>register_transient(token, provider)</code>","text":"<p>Register a transient-scoped dependency.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_transient(\n    self, token: Token[Any] | type[Any], provider: Provider\n) -&gt; Container:\n    \"\"\"Register a transient-scoped dependency.\"\"\"\n    return self.register(token, provider, scope=Scope.TRANSIENT)\n</code></pre>"},{"location":"api/#pyinj.container.Container.register_value","title":"<code>register_value(token, value)</code>","text":"<p>Register a pre-created value as a singleton.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_value(self, token: Token[Any] | type[Any], value: Any) -&gt; Container:\n    \"\"\"Register a pre-created value as a singleton.\"\"\"\n    if isinstance(token, type):\n        token = self.tokens.singleton(token.__name__, token)\n    # token is now a Token[Any]\n\n    # Store directly as singleton\n    self._singletons[token] = value\n    return self\n</code></pre>"},{"location":"api/#pyinj.container.Container.resolve_given","title":"<code>resolve_given(type_)</code>","text":"<p>Resolve a given instance by type.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def resolve_given(self, type_: type[T]) -&gt; T | None:\n    \"\"\"Resolve a given instance by type.\"\"\"\n    provider = self._given_providers.get(type_)\n    if provider:\n        return provider()\n    return None\n</code></pre>"},{"location":"api/#pyinj.container.Container.use_overrides","title":"<code>use_overrides(mapping)</code>","text":"<p>Temporarily override tokens for this concurrent context.</p> Example <p>with container.use_overrides({LOGGER: fake_logger}):     svc = container.get(SERVICE)     ...</p> Source code in <code>src/pyinj/container.py</code> <pre><code>@contextmanager\ndef use_overrides(self, mapping: dict[Token[Any], Any]) -&gt; Any:\n    \"\"\"Temporarily override tokens for this concurrent context.\n\n    Example:\n        with container.use_overrides({LOGGER: fake_logger}):\n            svc = container.get(SERVICE)\n            ...\n    \"\"\"\n    parent = self._overrides.get()\n    merged: dict[Token[Any], Any] = dict(parent) if parent else {}\n    merged.update(mapping)\n    token: CtxToken = self._overrides.set(merged)\n    try:\n        yield\n    finally:\n        self._overrides.reset(token)\n</code></pre>"},{"location":"api/#pyinj.container.Container.using","title":"<code>using(**givens)</code>","text":"<p>Scala-style using clause for temporary givens.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>@contextmanager\ndef using(self, **givens: Any) -&gt; Iterator[Container]:\n    \"\"\"Scala-style using clause for temporary givens.\"\"\"\n    old_givens = self._given_providers.copy()\n\n    # Add temporary givens\n    for type_name, instance in givens.items():\n        if isinstance(type_name, type):\n            self.given(type_name, instance)\n\n    try:\n        yield self\n    finally:\n        self._given_providers = old_givens\n</code></pre>"},{"location":"api/#contextual-scopes","title":"Contextual Scopes","text":"<p>Contextual abstractions for dependency injection using contextvars.</p>"},{"location":"api/#pyinj.contextual.ContextualContainer","title":"<code>ContextualContainer</code>","text":"<p>Base container adding request/session context via <code>contextvars</code>.</p> <p>Context flows implicitly across awaits; request/session lifetimes are enforced by the :class:<code>ScopeManager</code>.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>class ContextualContainer:\n    \"\"\"Base container adding request/session context via ``contextvars``.\n\n    Context flows implicitly across awaits; request/session lifetimes\n    are enforced by the :class:`ScopeManager`.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize contextual container.\"\"\"\n        # Singleton cache (process-wide)\n        self._singletons: dict[Token, Any] = {}\n\n        # Weak cache for transients (auto-cleanup)\n        self._transients: WeakValueDictionary = WeakValueDictionary()\n\n        # Providers registry\n        self._providers: dict[Token, Any] = {}\n\n        # Async locks for thread-safe singleton creation\n        self._async_locks: dict[Token, asyncio.Lock] = {}\n\n        # Track resources for cleanup\n        self._resources: list[Any] = []\n\n        # Scope manager (RAII contexts, precedence enforcement)\n        self._scope_manager = ScopeManager(self)\n\n    def _put_in_current_request_cache(self, token: Token[T], instance: T) -&gt; None:\n        \"\"\"Insert a value into the current request cache unconditionally.\n\n        This bypasses scope checks and is intended for temporary overrides\n        that should only affect the current context.\n        \"\"\"\n        context = _context_stack.get()\n        if context and hasattr(context, \"maps\") and context.maps:\n            context.maps[0][token] = instance\n\n    @contextmanager\n    def request_scope(self) -&gt; Iterator[ContextualContainer]:\n        \"\"\"Create a request scope (similar to a web request lifecycle).\n\n        Example:\n            with container.request_scope():\n                service = container.get(ServiceToken)\n\n        Yields:\n            Self for chaining.\n        \"\"\"\n        with self._scope_manager.request_scope():\n            yield self\n\n    @asynccontextmanager\n    async def async_request_scope(self) -&gt; AsyncIterator[ContextualContainer]:\n        \"\"\"Async context manager variant of :meth:`request_scope`.\n\n        Example:\n            async with container.async_request_scope():\n                service = await container.aget(ServiceToken)\n        \"\"\"\n        async with self._scope_manager.async_request_scope():\n            yield self\n\n    @contextmanager\n    def session_scope(self) -&gt; Iterator[ContextualContainer]:\n        \"\"\"\n        Create a session scope (longer-lived than request).\n\n        Session scopes persist across multiple requests but are\n        isolated between different sessions (e.g., users).\n        \"\"\"\n        with self._scope_manager.session_scope():\n            yield self\n\n    def _cleanup_scope(self, cache: dict[Token, Any]) -&gt; None:\n        \"\"\"\n        Clean up resources in LIFO order.\n\n        Args:\n            cache: Cache of resources to clean up\n        \"\"\"\n        for resource in reversed(list(cache.values())):\n            try:\n                if hasattr(resource, \"close\"):\n                    resource.close()\n                elif hasattr(resource, \"__exit__\"):\n                    resource.__exit__(None, None, None)\n            except Exception:\n                # Log but don't fail cleanup\n                pass\n\n    async def _async_cleanup_scope(self, cache: dict[Token, Any]) -&gt; None:\n        \"\"\"\n        Async cleanup of resources.\n\n        Args:\n            cache: Cache of resources to clean up\n        \"\"\"\n        tasks = []\n\n        for resource in reversed(list(cache.values())):\n            if hasattr(resource, \"aclose\"):\n                tasks.append(resource.aclose())\n            elif hasattr(resource, \"__aexit__\"):\n                tasks.append(resource.__aexit__(None, None, None))\n            elif hasattr(resource, \"close\"):\n                # Sync cleanup in executor\n                loop = asyncio.get_event_loop()\n                tasks.append(loop.run_in_executor(None, resource.close))\n\n        if tasks:\n            # Gather with return_exceptions to prevent one failure from stopping others\n            await asyncio.gather(*tasks, return_exceptions=True)\n\n    def resolve_from_context(self, token: Token[T]) -&gt; T | None:\n        \"\"\"\n        Resolve dependency from current context.\n\n        Args:\n            token: Token to resolve\n\n        Returns:\n            Resolved instance or None if not in context\n        \"\"\"\n        return self._scope_manager.resolve_from_context(token)\n\n    def store_in_context(self, token: Token[T], instance: T) -&gt; None:\n        \"\"\"\n        Store instance in appropriate context.\n\n        Args:\n            token: Token for the instance\n            instance: Instance to store\n        \"\"\"\n        self._scope_manager.store_in_context(token, instance)\n\n    def clear_request_context(self) -&gt; None:\n        \"\"\"Clear current request context.\"\"\"\n        self._scope_manager.clear_request_context()\n\n    def clear_session_context(self) -&gt; None:\n        \"\"\"Clear current session context.\"\"\"\n        self._scope_manager.clear_session_context()\n\n    def clear_all_contexts(self) -&gt; None:\n        \"\"\"Clear all contexts including singletons.\"\"\"\n        self._scope_manager.clear_all_contexts()\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.__init__","title":"<code>__init__()</code>","text":"<p>Initialize contextual container.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize contextual container.\"\"\"\n    # Singleton cache (process-wide)\n    self._singletons: dict[Token, Any] = {}\n\n    # Weak cache for transients (auto-cleanup)\n    self._transients: WeakValueDictionary = WeakValueDictionary()\n\n    # Providers registry\n    self._providers: dict[Token, Any] = {}\n\n    # Async locks for thread-safe singleton creation\n    self._async_locks: dict[Token, asyncio.Lock] = {}\n\n    # Track resources for cleanup\n    self._resources: list[Any] = []\n\n    # Scope manager (RAII contexts, precedence enforcement)\n    self._scope_manager = ScopeManager(self)\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.async_request_scope","title":"<code>async_request_scope()</code>  <code>async</code>","text":"<p>Async context manager variant of :meth:<code>request_scope</code>.</p> Example <p>async with container.async_request_scope():     service = await container.aget(ServiceToken)</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>@asynccontextmanager\nasync def async_request_scope(self) -&gt; AsyncIterator[ContextualContainer]:\n    \"\"\"Async context manager variant of :meth:`request_scope`.\n\n    Example:\n        async with container.async_request_scope():\n            service = await container.aget(ServiceToken)\n    \"\"\"\n    async with self._scope_manager.async_request_scope():\n        yield self\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.clear_all_contexts","title":"<code>clear_all_contexts()</code>","text":"<p>Clear all contexts including singletons.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def clear_all_contexts(self) -&gt; None:\n    \"\"\"Clear all contexts including singletons.\"\"\"\n    self._scope_manager.clear_all_contexts()\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.clear_request_context","title":"<code>clear_request_context()</code>","text":"<p>Clear current request context.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def clear_request_context(self) -&gt; None:\n    \"\"\"Clear current request context.\"\"\"\n    self._scope_manager.clear_request_context()\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.clear_session_context","title":"<code>clear_session_context()</code>","text":"<p>Clear current session context.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def clear_session_context(self) -&gt; None:\n    \"\"\"Clear current session context.\"\"\"\n    self._scope_manager.clear_session_context()\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.request_scope","title":"<code>request_scope()</code>","text":"<p>Create a request scope (similar to a web request lifecycle).</p> Example <p>with container.request_scope():     service = container.get(ServiceToken)</p> <p>Yields:</p> Type Description <code>ContextualContainer</code> <p>Self for chaining.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>@contextmanager\ndef request_scope(self) -&gt; Iterator[ContextualContainer]:\n    \"\"\"Create a request scope (similar to a web request lifecycle).\n\n    Example:\n        with container.request_scope():\n            service = container.get(ServiceToken)\n\n    Yields:\n        Self for chaining.\n    \"\"\"\n    with self._scope_manager.request_scope():\n        yield self\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.resolve_from_context","title":"<code>resolve_from_context(token)</code>","text":"<p>Resolve dependency from current context.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[T]</code> <p>Token to resolve</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>Resolved instance or None if not in context</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def resolve_from_context(self, token: Token[T]) -&gt; T | None:\n    \"\"\"\n    Resolve dependency from current context.\n\n    Args:\n        token: Token to resolve\n\n    Returns:\n        Resolved instance or None if not in context\n    \"\"\"\n    return self._scope_manager.resolve_from_context(token)\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.session_scope","title":"<code>session_scope()</code>","text":"<p>Create a session scope (longer-lived than request).</p> <p>Session scopes persist across multiple requests but are isolated between different sessions (e.g., users).</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>@contextmanager\ndef session_scope(self) -&gt; Iterator[ContextualContainer]:\n    \"\"\"\n    Create a session scope (longer-lived than request).\n\n    Session scopes persist across multiple requests but are\n    isolated between different sessions (e.g., users).\n    \"\"\"\n    with self._scope_manager.session_scope():\n        yield self\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.store_in_context","title":"<code>store_in_context(token, instance)</code>","text":"<p>Store instance in appropriate context.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[T]</code> <p>Token for the instance</p> required <code>instance</code> <code>T</code> <p>Instance to store</p> required Source code in <code>src/pyinj/contextual.py</code> <pre><code>def store_in_context(self, token: Token[T], instance: T) -&gt; None:\n    \"\"\"\n    Store instance in appropriate context.\n\n    Args:\n        token: Token for the instance\n        instance: Instance to store\n    \"\"\"\n    self._scope_manager.store_in_context(token, instance)\n</code></pre>"},{"location":"api/#pyinj.contextual.RequestScope","title":"<code>RequestScope</code>","text":"<p>Helper class for request-scoped dependencies.</p> Example <p>async with RequestScope(container) as scope:     service = scope.resolve(ServiceToken)</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>class RequestScope:\n    \"\"\"\n    Helper class for request-scoped dependencies.\n\n    Example:\n        async with RequestScope(container) as scope:\n            service = scope.resolve(ServiceToken)\n    \"\"\"\n\n    def __init__(self, container: ContextualContainer):\n        \"\"\"Initialize request scope.\"\"\"\n        self.container = container\n        self._context_manager = None\n        self._async_context_manager = None\n\n    def __enter__(self) -&gt; RequestScope:\n        \"\"\"Enter request scope.\"\"\"\n        self._context_manager = self.container.request_scope()\n        self._context_manager.__enter__()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        \"\"\"Exit request scope.\"\"\"\n        if self._context_manager:\n            self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n\n    async def __aenter__(self) -&gt; RequestScope:\n        \"\"\"Async enter request scope.\"\"\"\n        self._async_context_manager = self.container.async_request_scope()\n        await self._async_context_manager.__aenter__()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        \"\"\"Async exit request scope.\"\"\"\n        if self._async_context_manager:\n            await self._async_context_manager.__aexit__(exc_type, exc_val, exc_tb)\n\n    def resolve(self, token: Token[T]) -&gt; T | None:\n        \"\"\"Resolve dependency in this scope.\"\"\"\n        return self.container.resolve_from_context(token)\n</code></pre>"},{"location":"api/#pyinj.contextual.RequestScope.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Async enter request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>async def __aenter__(self) -&gt; RequestScope:\n    \"\"\"Async enter request scope.\"\"\"\n    self._async_context_manager = self.container.async_request_scope()\n    await self._async_context_manager.__aenter__()\n    return self\n</code></pre>"},{"location":"api/#pyinj.contextual.RequestScope.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Async exit request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n    \"\"\"Async exit request scope.\"\"\"\n    if self._async_context_manager:\n        await self._async_context_manager.__aexit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.contextual.RequestScope.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __enter__(self) -&gt; RequestScope:\n    \"\"\"Enter request scope.\"\"\"\n    self._context_manager = self.container.request_scope()\n    self._context_manager.__enter__()\n    return self\n</code></pre>"},{"location":"api/#pyinj.contextual.RequestScope.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n    \"\"\"Exit request scope.\"\"\"\n    if self._context_manager:\n        self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.contextual.RequestScope.__init__","title":"<code>__init__(container)</code>","text":"<p>Initialize request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __init__(self, container: ContextualContainer):\n    \"\"\"Initialize request scope.\"\"\"\n    self.container = container\n    self._context_manager = None\n    self._async_context_manager = None\n</code></pre>"},{"location":"api/#pyinj.contextual.RequestScope.resolve","title":"<code>resolve(token)</code>","text":"<p>Resolve dependency in this scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def resolve(self, token: Token[T]) -&gt; T | None:\n    \"\"\"Resolve dependency in this scope.\"\"\"\n    return self.container.resolve_from_context(token)\n</code></pre>"},{"location":"api/#pyinj.contextual.ScopeManager","title":"<code>ScopeManager</code>","text":"<p>Scope orchestration with RAII managers and explicit precedence.</p> <p>Precedence: REQUEST &gt; SESSION &gt; SINGLETON. Uses ContextVars for async safety.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>class ScopeManager:\n    \"\"\"Scope orchestration with RAII managers and explicit precedence.\n\n    Precedence: REQUEST &gt; SESSION &gt; SINGLETON. Uses ContextVars for async safety.\n    \"\"\"\n\n    def __init__(self, container: ContextualContainer) -&gt; None:\n        self._container = container\n\n    @contextmanager\n    def request_scope(self) -&gt; Iterator[None]:\n        request_cache: dict[Token, Any] = {}\n        current = _context_stack.get()\n        if current is None:\n            new_context = ChainMap(request_cache, self._container._singletons)\n        else:\n            new_context = ChainMap(request_cache, current)\n        token = _context_stack.set(new_context)\n        try:\n            yield\n        finally:\n            self._container._cleanup_scope(request_cache)\n            _context_stack.reset(token)\n\n    @asynccontextmanager\n    async def async_request_scope(self) -&gt; AsyncIterator[None]:\n        request_cache: dict[Token, Any] = {}\n        current = _context_stack.get()\n        if current is None:\n            new_context = ChainMap(request_cache, self._container._singletons)\n        else:\n            new_context = ChainMap(request_cache, current)\n        token = _context_stack.set(new_context)\n        try:\n            yield\n        finally:\n            await self._container._async_cleanup_scope(request_cache)\n            _context_stack.reset(token)\n\n    @contextmanager\n    def session_scope(self) -&gt; Iterator[None]:\n        session_cache = _session_context.get()\n        if session_cache is None:\n            session_cache = {}\n            session_token = _session_context.set(session_cache)\n        else:\n            session_token = None\n        current = _context_stack.get()\n        if current is None:\n            new_context = ChainMap(session_cache, self._container._singletons)\n        else:\n            new_context = ChainMap(\n                current.maps[0], session_cache, self._container._singletons\n            )\n        context_token = _context_stack.set(new_context)\n        try:\n            yield\n        finally:\n            _context_stack.reset(context_token)\n            if session_token:\n                _session_context.reset(session_token)\n\n    def resolve_from_context(self, token: Token[T]) -&gt; T | None:\n        context = _context_stack.get()\n        if context and token in context:\n            return context[token]\n        if token.scope == Scope.SESSION:\n            session = _session_context.get()\n            if session and token in session:\n                return session[token]\n        if token.scope == Scope.SINGLETON and token in self._container._singletons:\n            return self._container._singletons[token]\n        if token.scope == Scope.TRANSIENT and token in self._container._transients:\n            return self._container._transients[token]\n        return None\n\n    def store_in_context(self, token: Token[T], instance: T) -&gt; None:\n        if token.scope == Scope.SINGLETON:\n            self._container._singletons[token] = instance\n        elif token.scope == Scope.REQUEST:\n            self._container._put_in_current_request_cache(token, instance)\n        elif token.scope == Scope.SESSION:\n            session = _session_context.get()\n            if session is not None:\n                session[token] = instance\n        elif token.scope == Scope.TRANSIENT:\n            try:\n                self._container._transients[token] = instance\n            except TypeError:\n                pass\n\n    def clear_request_context(self) -&gt; None:\n        context = _context_stack.get()\n        if context and hasattr(context, \"maps\") and context.maps:\n            context.maps[0].clear()\n\n    def clear_session_context(self) -&gt; None:\n        session = _session_context.get()\n        if session is not None:\n            session.clear()\n\n    def clear_all_contexts(self) -&gt; None:\n        self._container._singletons.clear()\n        self._container._transients.clear()\n        self.clear_request_context()\n        self.clear_session_context()\n</code></pre>"},{"location":"api/#pyinj.contextual.SessionScope","title":"<code>SessionScope</code>","text":"<p>Helper class for session-scoped dependencies.</p> Example <p>with SessionScope(container) as scope:     user = scope.resolve(UserToken)</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>class SessionScope:\n    \"\"\"\n    Helper class for session-scoped dependencies.\n\n    Example:\n        with SessionScope(container) as scope:\n            user = scope.resolve(UserToken)\n    \"\"\"\n\n    def __init__(self, container: ContextualContainer):\n        \"\"\"Initialize session scope.\"\"\"\n        self.container = container\n        self._context_manager = None\n\n    def __enter__(self) -&gt; SessionScope:\n        \"\"\"Enter session scope.\"\"\"\n        self._context_manager = self.container.session_scope()\n        self._context_manager.__enter__()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        \"\"\"Exit session scope.\"\"\"\n        if self._context_manager:\n            self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.contextual.SessionScope.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter session scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __enter__(self) -&gt; SessionScope:\n    \"\"\"Enter session scope.\"\"\"\n    self._context_manager = self.container.session_scope()\n    self._context_manager.__enter__()\n    return self\n</code></pre>"},{"location":"api/#pyinj.contextual.SessionScope.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit session scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n    \"\"\"Exit session scope.\"\"\"\n    if self._context_manager:\n        self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.contextual.SessionScope.__init__","title":"<code>__init__(container)</code>","text":"<p>Initialize session scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __init__(self, container: ContextualContainer):\n    \"\"\"Initialize session scope.\"\"\"\n    self.container = container\n    self._context_manager = None\n</code></pre>"},{"location":"api/#pyinj.contextual.get_current_context","title":"<code>get_current_context()</code>","text":"<p>Get current dependency context as read-only view.</p> <p>Returns:</p> Type Description <code>MappingProxyType | None</code> <p>Read-only mapping of current context or None</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def get_current_context() -&gt; MappingProxyType | None:\n    \"\"\"\n    Get current dependency context as read-only view.\n\n    Returns:\n        Read-only mapping of current context or None\n    \"\"\"\n    context = _context_stack.get()\n    if context is not None:\n        return MappingProxyType(context)\n    return None\n</code></pre>"},{"location":"api/#pyinj.contextual.set_context","title":"<code>set_context(context)</code>","text":"<p>Set the current dependency context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>ChainMap</code> <p>ChainMap of dependency caches</p> required <p>Returns:</p> Type Description <code>Token</code> <p>Token for resetting context</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def set_context(context: ChainMap) -&gt; ContextToken:\n    \"\"\"\n    Set the current dependency context.\n\n    Args:\n        context: ChainMap of dependency caches\n\n    Returns:\n        Token for resetting context\n    \"\"\"\n    return _context_stack.set(context)\n</code></pre>"},{"location":"api/#tokens-and-scope","title":"Tokens and Scope","text":"<p>Enhanced Token implementation with immutability and optimizations.</p>"},{"location":"api/#pyinj.tokens.Scope","title":"<code>Scope</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Lifecycle scope for dependencies.</p> Values <p>SINGLETON: One instance for the process/container. REQUEST: One instance per request context. SESSION: One instance per longer-lived session context. TRANSIENT: A new instance for every resolution.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>class Scope(Enum):\n    \"\"\"Lifecycle scope for dependencies.\n\n    Values:\n        SINGLETON: One instance for the process/container.\n        REQUEST: One instance per request context.\n        SESSION: One instance per longer-lived session context.\n        TRANSIENT: A new instance for every resolution.\n    \"\"\"\n\n    SINGLETON = auto()  # Process-wide singleton\n    REQUEST = auto()  # Request/context scoped\n    SESSION = auto()  # Session scoped\n    TRANSIENT = auto()  # New instance every time\n</code></pre>"},{"location":"api/#pyinj.tokens.Token","title":"<code>Token</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Immutable, hashable identifier for a typed dependency.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Human-readable name for the binding.</p> required <code>type_</code> <code>type[T]</code> <p>The expected Python type of the dependency.</p> required <code>scope</code> <code>Scope</code> <p>Lifecycle scope. Defaults to TRANSIENT.</p> <code>TRANSIENT</code> <code>qualifier</code> <code>str | None</code> <p>Optional qualifier to differentiate multiple bindings of the same type.</p> <code>None</code> <code>tags</code> <code>tuple[str, ...]</code> <p>Optional tags for discovery/metadata.</p> <code>tuple()</code> Example <p>LOGGER = TokenLogger</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass Token(Generic[T]):\n    \"\"\"Immutable, hashable identifier for a typed dependency.\n\n    Args:\n        name: Human-readable name for the binding.\n        type_: The expected Python type of the dependency.\n        scope: Lifecycle scope. Defaults to TRANSIENT.\n        qualifier: Optional qualifier to differentiate multiple bindings of the same type.\n        tags: Optional tags for discovery/metadata.\n\n    Example:\n        LOGGER = Token[Logger](\"logger\", scope=Scope.SINGLETON)\n    \"\"\"\n\n    name: str\n    type_: type[T]\n    scope: Scope = Scope.TRANSIENT\n    qualifier: str | None = None\n    tags: tuple[str, ...] = field(default_factory=tuple)\n    _hash: int = field(init=False, repr=False, compare=False)\n    _metadata: dict[str, Any] = field(default_factory=dict, repr=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        # Pre-compute hash for performance\n        hash_tuple = (\n            self.name,\n            self.type_.__module__ if hasattr(self.type_, \"__module__\") else \"\",\n            self.type_.__name__ if hasattr(self.type_, \"__name__\") else str(self.type_),\n            self.scope.value,\n            self.qualifier,\n            self.tags,\n        )\n        object.__setattr__(self, \"_hash\", hash(hash_tuple))\n\n        # Make metadata immutable\n        if self._metadata:\n            object.__setattr__(self, \"_metadata\", MappingProxyType(self._metadata))\n\n    def __hash__(self) -&gt; int:  # pragma: no cover - trivial\n        return self._hash\n\n    def __eq__(self, other: object) -&gt; bool:  # pragma: no cover - trivial\n        if not isinstance(other, Token):\n            return False\n        if self._hash != other._hash:\n            return False\n        return (\n            self.name == other.name\n            and self.type_ == other.type_\n            and self.scope == other.scope\n            and self.qualifier == other.qualifier\n            and self.tags == other.tags\n        )\n\n    @property\n    def metadata(self) -&gt; MappingProxyType[str, Any]:\n        \"\"\"Read-only view of metadata.\"\"\"\n        return self._metadata  # type: ignore[return-value]\n\n    @property\n    def qualified_name(self) -&gt; str:\n        \"\"\"Fully qualified name including module, type, qualifier, and token name.\"\"\"\n        parts: list[str] = []\n        if hasattr(self.type_, \"__module__\"):\n            parts.append(self.type_.__module__)  # type: ignore[arg-type]\n        parts.append(getattr(self.type_, \"__name__\", str(self.type_)))\n        if self.qualifier:\n            parts.append(self.qualifier)\n        parts.append(self.name)\n        return \".\".join(parts)\n\n    def with_scope(self, scope: Scope) -&gt; Token[T]:\n        \"\"\"Return a copy of this token with a different scope.\"\"\"\n        return Token(\n            name=self.name,\n            type_=self.type_,\n            scope=scope,\n            qualifier=self.qualifier,\n            tags=self.tags,\n            _metadata=dict(self._metadata) if self._metadata else {},\n        )\n\n    def with_qualifier(self, qualifier: str) -&gt; Token[T]:\n        \"\"\"Return a copy of this token with a qualifier.\"\"\"\n        return Token(\n            name=self.name,\n            type_=self.type_,\n            scope=self.scope,\n            qualifier=qualifier,\n            tags=self.tags,\n            _metadata=dict(self._metadata) if self._metadata else {},\n        )\n\n    def with_tags(self, *tags: str) -&gt; Token[T]:\n        \"\"\"Return a copy of this token with tags merged in (set semantics).\"\"\"\n        return Token(\n            name=self.name,\n            type_=self.type_,\n            scope=self.scope,\n            qualifier=self.qualifier,\n            tags=tuple(set(self.tags) | set(tags)),\n            _metadata=dict(self._metadata) if self._metadata else {},\n        )\n\n    def __repr__(self) -&gt; str:  # pragma: no cover - representation\n        type_name = getattr(self.type_, \"__name__\", str(self.type_))\n        parts = [f\"Token('{self.name}', {type_name}\"]\n        if self.scope != Scope.TRANSIENT:\n            parts.append(f\", scope={self.scope.name}\")\n        if self.qualifier:\n            parts.append(f\", qualifier='{self.qualifier}'\")\n        if self.tags:\n            parts.append(f\", tags={self.tags}\")\n        return \"\".join(parts) + \")\"\n\n    def validate(self, instance: Any) -&gt; bool:\n        \"\"\"Validate instance type against the token's expected type.\n\n        Returns False only when ``isinstance(instance, type_)`` is definitively False.\n        If runtime type information is insufficient, returns True.\n        \"\"\"\n        try:\n            return isinstance(instance, self.type_)\n        except Exception:\n            return True\n</code></pre>"},{"location":"api/#pyinj.tokens.Token.metadata","title":"<code>metadata</code>  <code>property</code>","text":"<p>Read-only view of metadata.</p>"},{"location":"api/#pyinj.tokens.Token.qualified_name","title":"<code>qualified_name</code>  <code>property</code>","text":"<p>Fully qualified name including module, type, qualifier, and token name.</p>"},{"location":"api/#pyinj.tokens.Token.validate","title":"<code>validate(instance)</code>","text":"<p>Validate instance type against the token's expected type.</p> <p>Returns False only when <code>isinstance(instance, type_)</code> is definitively False. If runtime type information is insufficient, returns True.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def validate(self, instance: Any) -&gt; bool:\n    \"\"\"Validate instance type against the token's expected type.\n\n    Returns False only when ``isinstance(instance, type_)`` is definitively False.\n    If runtime type information is insufficient, returns True.\n    \"\"\"\n    try:\n        return isinstance(instance, self.type_)\n    except Exception:\n        return True\n</code></pre>"},{"location":"api/#pyinj.tokens.Token.with_qualifier","title":"<code>with_qualifier(qualifier)</code>","text":"<p>Return a copy of this token with a qualifier.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def with_qualifier(self, qualifier: str) -&gt; Token[T]:\n    \"\"\"Return a copy of this token with a qualifier.\"\"\"\n    return Token(\n        name=self.name,\n        type_=self.type_,\n        scope=self.scope,\n        qualifier=qualifier,\n        tags=self.tags,\n        _metadata=dict(self._metadata) if self._metadata else {},\n    )\n</code></pre>"},{"location":"api/#pyinj.tokens.Token.with_scope","title":"<code>with_scope(scope)</code>","text":"<p>Return a copy of this token with a different scope.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def with_scope(self, scope: Scope) -&gt; Token[T]:\n    \"\"\"Return a copy of this token with a different scope.\"\"\"\n    return Token(\n        name=self.name,\n        type_=self.type_,\n        scope=scope,\n        qualifier=self.qualifier,\n        tags=self.tags,\n        _metadata=dict(self._metadata) if self._metadata else {},\n    )\n</code></pre>"},{"location":"api/#pyinj.tokens.Token.with_tags","title":"<code>with_tags(*tags)</code>","text":"<p>Return a copy of this token with tags merged in (set semantics).</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def with_tags(self, *tags: str) -&gt; Token[T]:\n    \"\"\"Return a copy of this token with tags merged in (set semantics).\"\"\"\n    return Token(\n        name=self.name,\n        type_=self.type_,\n        scope=self.scope,\n        qualifier=self.qualifier,\n        tags=tuple(set(self.tags) | set(tags)),\n        _metadata=dict(self._metadata) if self._metadata else {},\n    )\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory","title":"<code>TokenFactory</code>","text":"<p>Factory for creating and caching commonly used tokens.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>class TokenFactory:\n    \"\"\"Factory for creating and caching commonly used tokens.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._cache: dict[tuple[str, type[Any], Scope, str | None], Token[Any]] = {}\n\n    def create(\n        self,\n        name: str,\n        type_: type[T],\n        scope: Scope = Scope.TRANSIENT,\n        qualifier: str | None = None,\n        tags: tuple[str, ...] = (),\n    ) -&gt; Token[T]:\n        \"\"\"Create a token, with a small internal cache for common shapes.\"\"\"\n        cache_key = (name, type_, scope, qualifier)\n        if not tags and cache_key in self._cache:\n            return cast(Token[T], self._cache[cache_key])\n        token: Token[T] = Token(\n            name=name, type_=type_, scope=scope, qualifier=qualifier, tags=tags\n        )\n        if not tags:\n            self._cache[cache_key] = cast(Token[Any], token)\n        return token\n\n    def singleton(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a singleton-scoped token.\"\"\"\n        return self.create(name, type_, scope=Scope.SINGLETON)\n\n    def request(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a request-scoped token.\"\"\"\n        return self.create(name, type_, scope=Scope.REQUEST)\n\n    def session(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a session-scoped token.\"\"\"\n        return self.create(name, type_, scope=Scope.SESSION)\n\n    def transient(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a transient-scoped token (default).\"\"\"\n        return self.create(name, type_, scope=Scope.TRANSIENT)\n\n    def qualified(\n        self, qualifier: str, type_: type[T], scope: Scope = Scope.TRANSIENT\n    ) -&gt; Token[T]:\n        \"\"\"Create a qualified token for the given type and scope.\"\"\"\n        name = getattr(type_, \"__name__\", str(type_))\n        return self.create(name, type_, scope=scope, qualifier=qualifier)\n\n    def clear_cache(self) -&gt; None:\n        \"\"\"Clear the internal token cache (harmless).\"\"\"\n        self._cache.clear()\n\n    @property\n    def cache_size(self) -&gt; int:\n        \"\"\"Number of cached token shapes currently held.\"\"\"\n        return len(self._cache)\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory.cache_size","title":"<code>cache_size</code>  <code>property</code>","text":"<p>Number of cached token shapes currently held.</p>"},{"location":"api/#pyinj.tokens.TokenFactory.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear the internal token cache (harmless).</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear the internal token cache (harmless).\"\"\"\n    self._cache.clear()\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory.create","title":"<code>create(name, type_, scope=Scope.TRANSIENT, qualifier=None, tags=())</code>","text":"<p>Create a token, with a small internal cache for common shapes.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def create(\n    self,\n    name: str,\n    type_: type[T],\n    scope: Scope = Scope.TRANSIENT,\n    qualifier: str | None = None,\n    tags: tuple[str, ...] = (),\n) -&gt; Token[T]:\n    \"\"\"Create a token, with a small internal cache for common shapes.\"\"\"\n    cache_key = (name, type_, scope, qualifier)\n    if not tags and cache_key in self._cache:\n        return cast(Token[T], self._cache[cache_key])\n    token: Token[T] = Token(\n        name=name, type_=type_, scope=scope, qualifier=qualifier, tags=tags\n    )\n    if not tags:\n        self._cache[cache_key] = cast(Token[Any], token)\n    return token\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory.qualified","title":"<code>qualified(qualifier, type_, scope=Scope.TRANSIENT)</code>","text":"<p>Create a qualified token for the given type and scope.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def qualified(\n    self, qualifier: str, type_: type[T], scope: Scope = Scope.TRANSIENT\n) -&gt; Token[T]:\n    \"\"\"Create a qualified token for the given type and scope.\"\"\"\n    name = getattr(type_, \"__name__\", str(type_))\n    return self.create(name, type_, scope=scope, qualifier=qualifier)\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory.request","title":"<code>request(name, type_)</code>","text":"<p>Create a request-scoped token.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def request(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a request-scoped token.\"\"\"\n    return self.create(name, type_, scope=Scope.REQUEST)\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory.session","title":"<code>session(name, type_)</code>","text":"<p>Create a session-scoped token.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def session(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a session-scoped token.\"\"\"\n    return self.create(name, type_, scope=Scope.SESSION)\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory.singleton","title":"<code>singleton(name, type_)</code>","text":"<p>Create a singleton-scoped token.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def singleton(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a singleton-scoped token.\"\"\"\n    return self.create(name, type_, scope=Scope.SINGLETON)\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory.transient","title":"<code>transient(name, type_)</code>","text":"<p>Create a transient-scoped token (default).</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def transient(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a transient-scoped token (default).\"\"\"\n    return self.create(name, type_, scope=Scope.TRANSIENT)\n</code></pre>"},{"location":"api/#injection-utilities","title":"Injection Utilities","text":"<p>Lightweight decorators and markers for function parameter injection.</p> <p>These tools are inspired by FastAPI but remain framework-agnostic and work with synchronous and asynchronous callables.</p>"},{"location":"api/#pyinj.injection.Given","title":"<code>Given</code>","text":"<p>Scala-style given marker for implicit dependencies.</p> Usage <p>def handler(db: Given[Database]):     # db is resolved from given instances     ...</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>class Given:\n    \"\"\"\n    Scala-style given marker for implicit dependencies.\n\n    Usage:\n        def handler(db: Given[Database]):\n            # db is resolved from given instances\n            ...\n    \"\"\"\n\n    def __class_getitem__(cls, item: type[T]) -&gt; Inject:\n        \"\"\"Support Given[Type] syntax by delegating to Inject.\"\"\"\n        return Inject[item]\n</code></pre>"},{"location":"api/#pyinj.injection.Given.__class_getitem__","title":"<code>__class_getitem__(item)</code>","text":"<p>Support Given[Type] syntax by delegating to Inject.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __class_getitem__(cls, item: type[T]) -&gt; Inject:\n    \"\"\"Support Given[Type] syntax by delegating to Inject.\"\"\"\n    return Inject[item]\n</code></pre>"},{"location":"api/#pyinj.injection.Inject","title":"<code>Inject</code>","text":"<p>Marker for injected dependencies (similar to FastAPI's <code>Depends</code>).</p> Usage <p>def handler(db: Inject[Database]):     # db is auto-injected     ...</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>class Inject:\n    \"\"\"\n    Marker for injected dependencies (similar to FastAPI's ``Depends``).\n\n    Usage:\n        def handler(db: Inject[Database]):\n            # db is auto-injected\n            ...\n\n        # Or with default provider\n        def handler(db: Inject[Database] = Inject(create_db)):\n            ...\n    \"\"\"\n\n    def __init__(self, provider: Callable | None = None) -&gt; None:\n        \"\"\"\n        Initialize an injection marker optionally carrying a provider.\n\n        Args:\n            provider: Optional provider function\n        \"\"\"\n        self.provider = provider\n        self._type: type | None = None\n\n    def __class_getitem__(cls, item: builtins.type[T]) -&gt; builtins.type[Inject]:\n        \"\"\"\n        Support Inject[Type] syntax.\n\n        This allows type checkers to understand the type.\n        \"\"\"\n\n        # Create a new class that remembers the type\n        class TypedInject(cls):\n            _inject_type = item\n\n        return TypedInject\n\n    @property\n    def type(self) -&gt; builtins.type | None:\n        \"\"\"Get the injected type if available.\"\"\"\n        if hasattr(self.__class__, \"_inject_type\"):\n            return self.__class__._inject_type\n        return self._type\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Readable representation.\"\"\"\n        if self.type:\n            return f\"Inject[{self.type.__name__}]\"\n        return \"Inject()\"\n</code></pre>"},{"location":"api/#pyinj.injection.Inject--or-with-default-provider","title":"Or with default provider","text":"<p>def handler(db: Inject[Database] = Inject(create_db)):     ...</p>"},{"location":"api/#pyinj.injection.Inject.type","title":"<code>type</code>  <code>property</code>","text":"<p>Get the injected type if available.</p>"},{"location":"api/#pyinj.injection.Inject.__class_getitem__","title":"<code>__class_getitem__(item)</code>","text":"<p>Support Inject[Type] syntax.</p> <p>This allows type checkers to understand the type.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __class_getitem__(cls, item: builtins.type[T]) -&gt; builtins.type[Inject]:\n    \"\"\"\n    Support Inject[Type] syntax.\n\n    This allows type checkers to understand the type.\n    \"\"\"\n\n    # Create a new class that remembers the type\n    class TypedInject(cls):\n        _inject_type = item\n\n    return TypedInject\n</code></pre>"},{"location":"api/#pyinj.injection.Inject.__init__","title":"<code>__init__(provider=None)</code>","text":"<p>Initialize an injection marker optionally carrying a provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>Callable | None</code> <p>Optional provider function</p> <code>None</code> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __init__(self, provider: Callable | None = None) -&gt; None:\n    \"\"\"\n    Initialize an injection marker optionally carrying a provider.\n\n    Args:\n        provider: Optional provider function\n    \"\"\"\n    self.provider = provider\n    self._type: type | None = None\n</code></pre>"},{"location":"api/#pyinj.injection.Inject.__repr__","title":"<code>__repr__()</code>","text":"<p>Readable representation.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Readable representation.\"\"\"\n    if self.type:\n        return f\"Inject[{self.type.__name__}]\"\n    return \"Inject()\"\n</code></pre>"},{"location":"api/#pyinj.injection.InjectionAnalyzer","title":"<code>InjectionAnalyzer</code>","text":"<p>Small analyzer facade to build dependency plans.</p> <p>This class enables decomposition and easier testing while remaining backward-compatible with analyze_dependencies.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>class InjectionAnalyzer:\n    \"\"\"Small analyzer facade to build dependency plans.\n\n    This class enables decomposition and easier testing while\n    remaining backward-compatible with analyze_dependencies.\n    \"\"\"\n\n    @staticmethod\n    def build_plan(func: Callable[..., Any]) -&gt; dict[str, type | Token | Inject]:\n        return analyze_dependencies(func)\n</code></pre>"},{"location":"api/#pyinj.injection.Depends","title":"<code>Depends(provider)</code>","text":"<p>FastAPI-compatible <code>Depends</code> marker.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>Callable[..., T]</code> <p>Provider function for the dependency</p> required <p>Returns:</p> Name Type Description <code>An</code> <code>T</code> <p>class:<code>Inject</code> marker usable as a default parameter value.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def Depends[T](provider: Callable[..., T]) -&gt; T:  # noqa: N802\n    \"\"\"\n    FastAPI-compatible ``Depends`` marker.\n\n    Args:\n        provider: Provider function for the dependency\n\n    Returns:\n        An :class:`Inject` marker usable as a default parameter value.\n    \"\"\"\n    return Inject(provider)  # type: ignore\n</code></pre>"},{"location":"api/#pyinj.injection.analyze_dependencies","title":"<code>analyze_dependencies(func)</code>  <code>cached</code>","text":"<p>Analyze function signature for injected dependencies.</p> <p>This is cached for performance as signature analysis is expensive.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>Function to analyze</p> required <p>Returns:</p> Type Description <code>dict[str, type | Token | Inject]</code> <p>Dictionary mapping parameter names to their injection specs</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>@lru_cache(maxsize=256)\ndef analyze_dependencies(func: Callable[..., Any]) -&gt; dict[str, type | Token | Inject]:\n    \"\"\"\n    Analyze function signature for injected dependencies.\n\n    This is cached for performance as signature analysis is expensive.\n\n    Args:\n        func: Function to analyze\n\n    Returns:\n        Dictionary mapping parameter names to their injection specs\n    \"\"\"\n    sig = signature(func)\n    # Resolve annotations (handles from __future__ import annotations)\n    try:\n        resolved = get_type_hints(func, include_extras=True)\n    except Exception:\n        resolved = {}\n    deps: dict[str, type | Token | Inject] = {}\n\n    for name, param in sig.parameters.items():\n        # Skip *args and **kwargs\n        if param.kind in (Parameter.VAR_POSITIONAL, Parameter.VAR_KEYWORD):\n            continue\n\n        annotation = resolved.get(name, param.annotation)\n\n        # Skip if no annotation\n        if annotation is Parameter.empty:\n            continue\n\n        # Check various injection patterns\n        if _is_inject_type(annotation):\n            # It's Inject[T] or Given[T]\n            deps[name] = _extract_inject_spec(annotation, param.default)\n\n        elif isinstance(param.default, Inject):\n            # Default value is Inject()\n            deps[name] = param.default\n            if annotation != Parameter.empty:\n                # Store the type from annotation\n                param.default._type = annotation\n\n        elif isinstance(annotation, Token):\n            # Direct Token annotation\n            deps[name] = annotation\n\n        elif hasattr(annotation, \"__metadata__\"):\n            # Annotated[Type, metadata] pattern\n            for metadata in annotation.__metadata__:\n                if isinstance(metadata, Inject | Token):\n                    deps[name] = metadata\n                    break\n\n        elif _is_plain_injectable_type(annotation):\n            # Fallback: plain type annotation (non-builtin class/protocol)\n            deps[name] = annotation\n\n        elif isinstance(param.annotation, str) and \"Inject[\" in param.annotation:\n            # Last-resort: parse string annotations from future annotations\n            inner = param.annotation.strip()\n            try:\n                inner_type_str = inner[inner.find(\"[\") + 1 : inner.rfind(\"]\")]\n                inner_type = eval(inner_type_str, func.__globals__, {})  # noqa: S307 (trusted test context)\n                marker = Inject()\n                marker._type = inner_type\n                deps[name] = marker\n            except Exception:\n                # Ignore if we cannot resolve\n                pass\n\n    return deps\n</code></pre>"},{"location":"api/#pyinj.injection.inject","title":"<code>inject(func=None, *, container=None, cache=True)</code>","text":"<p>Decorator that injects dependencies into function parameters.</p> <p>This is the main entry point for dependency injection, inspired by FastAPI's dependency injection system.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any] | None</code> <p>Function to decorate (or None if using with parameters)</p> <code>None</code> <code>container</code> <code>Any | None</code> <p>Container to resolve dependencies from</p> <code>None</code> <code>cache</code> <code>bool</code> <p>Whether to cache dependency analysis</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>Decorated function with automatic dependency injection</p> <p>Examples:</p> <p>@inject def service(db: Inject[Database]):     return db.query()</p> <p>@inject(container=my_container) async def handler(cache: Inject[Cache]):     return await cache.get(\"key\")</p> <p>@inject async def endpoint(     user_id: int,     db: Inject[Database],     cache: Given[Cache],     settings: Settings = Inject() ):     # Mixed regular and injected parameters     pass</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def inject(\n    func: Callable[..., Any] | None = None,\n    *,\n    container: Any | None = None,\n    cache: bool = True,\n) -&gt; Callable[..., Any]:\n    \"\"\"\n    Decorator that injects dependencies into function parameters.\n\n    This is the main entry point for dependency injection, inspired by\n    FastAPI's dependency injection system.\n\n    Args:\n        func: Function to decorate (or None if using with parameters)\n        container: Container to resolve dependencies from\n        cache: Whether to cache dependency analysis\n\n    Returns:\n        Decorated function with automatic dependency injection\n\n    Examples:\n        @inject\n        def service(db: Inject[Database]):\n            return db.query()\n\n        @inject(container=my_container)\n        async def handler(cache: Inject[Cache]):\n            return await cache.get(\"key\")\n\n        @inject\n        async def endpoint(\n            user_id: int,\n            db: Inject[Database],\n            cache: Given[Cache],\n            settings: Settings = Inject()\n        ):\n            # Mixed regular and injected parameters\n            pass\n    \"\"\"\n\n    def decorator(fn: Callable[..., Any]) -&gt; Callable[..., Any]:\n        # Analyze dependencies (cached if cache=True)\n        deps = InjectionAnalyzer.build_plan(fn) if cache else None\n\n        if iscoroutinefunction(fn):\n\n            @wraps(fn)\n            async def async_wrapper(*args: object, **kwargs: object) -&gt; Any:\n                # Get dependencies if not cached\n                nonlocal deps\n                if deps is None:\n                    deps = InjectionAnalyzer.build_plan(fn)\n\n                if not deps:\n                    # No dependencies, call original\n                    return await fn(*args, **kwargs)\n\n                # Get container\n                nonlocal container\n                if container is None:\n                    # Try to get default container without import cycle\n                    from .container import get_default_container\n\n                    container = get_default_container()\n\n                # Extract overrides from kwargs\n                overrides: dict[str, Any] = {}\n                for name in deps:\n                    if name in kwargs:  # type: ignore[operator]\n                        overrides[name] = cast(Any, kwargs.pop(name))  # type: ignore[call-arg]\n\n                # Resolve dependencies\n                resolved = await resolve_dependencies_async(deps, container, overrides)\n\n                # Merge with kwargs\n                kwargs.update(resolved)\n\n                return await fn(*args, **kwargs)  # type: ignore[misc]\n\n            return async_wrapper\n\n        else:\n\n            @wraps(fn)\n            def sync_wrapper(*args: object, **kwargs: object) -&gt; Any:\n                # Get dependencies if not cached\n                nonlocal deps\n                if deps is None:\n                    deps = InjectionAnalyzer.build_plan(fn)\n\n                if not deps:\n                    # No dependencies, call original\n                    return fn(*args, **kwargs)\n\n                # Get container\n                nonlocal container\n                if container is None:\n                    from .container import get_default_container\n\n                    container = get_default_container()\n\n                # Extract overrides from kwargs\n                overrides: dict[str, Any] = {}\n                for name in deps:\n                    if name in kwargs:  # type: ignore[operator]\n                        overrides[name] = cast(Any, kwargs.pop(name))  # type: ignore[call-arg]\n\n                # Resolve dependencies\n                resolved = resolve_dependencies(deps, container, overrides)\n\n                # Merge with kwargs\n                kwargs.update(resolved)\n\n                return fn(*args, **kwargs)  # type: ignore[misc]\n\n            return sync_wrapper\n\n    # Handle both @inject and @inject(...) syntax\n    if func is None:\n        # Called with parameters: @inject(container=...)\n        return decorator\n    else:\n        # Called without parameters: @inject\n        return decorator(func)\n</code></pre>"},{"location":"api/#pyinj.injection.resolve_dependencies","title":"<code>resolve_dependencies(deps, container, overrides=None)</code>","text":"<p>Resolve dependencies synchronously.</p> <p>Parameters:</p> Name Type Description Default <code>deps</code> <code>dict[str, type | Token | Inject]</code> <p>Dependencies to resolve</p> required <code>container</code> <code>Resolvable[Any]</code> <p>Container to resolve from</p> required <code>overrides</code> <code>dict[str, Any] | None</code> <p>Optional overrides for specific dependencies</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of resolved dependencies</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def resolve_dependencies(\n    deps: dict[str, type | Token | Inject],\n    container: Resolvable[Any],\n    overrides: dict[str, Any] | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Resolve dependencies synchronously.\n\n    Args:\n        deps: Dependencies to resolve\n        container: Container to resolve from\n        overrides: Optional overrides for specific dependencies\n\n    Returns:\n        Dictionary of resolved dependencies\n    \"\"\"\n    resolved: dict[str, Any] = {}\n    overrides = overrides or {}\n\n    for name, spec in deps.items():\n        # Check for override first\n        if name in overrides:\n            resolved[name] = overrides[name]\n            continue\n\n        # Resolve based on spec type\n        if isinstance(spec, Token):\n            # Direct token\n            resolved[name] = container.get(spec)\n\n        elif isinstance(spec, Inject):\n            # Inject with optional provider\n            if spec.provider:\n                # Call the provider\n                resolved[name] = spec.provider()\n            elif spec.type:\n                # Resolve by type\n                resolved[name] = container.get(spec.type)\n\n        elif isinstance(spec, type):\n            # Direct type annotation\n            resolved[name] = container.get(spec)\n\n    return resolved\n</code></pre>"},{"location":"api/#pyinj.injection.resolve_dependencies_async","title":"<code>resolve_dependencies_async(deps, container, overrides=None)</code>  <code>async</code>","text":"<p>Resolve dependencies asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>deps</code> <code>dict[str, type | Token | Inject]</code> <p>Dependencies to resolve</p> required <code>container</code> <code>Resolvable[Any]</code> <p>Container to resolve from</p> required <code>overrides</code> <code>dict[str, Any] | None</code> <p>Optional overrides for specific dependencies</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of resolved dependencies</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>async def resolve_dependencies_async(\n    deps: dict[str, type | Token | Inject],\n    container: Resolvable[Any],\n    overrides: dict[str, Any] | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Resolve dependencies asynchronously.\n\n    Args:\n        deps: Dependencies to resolve\n        container: Container to resolve from\n        overrides: Optional overrides for specific dependencies\n\n    Returns:\n        Dictionary of resolved dependencies\n    \"\"\"\n    resolved: dict[str, Any] = {}\n    overrides = overrides or {}\n    tasks: dict[str, asyncio.Task[Any]] = {}\n\n    for name, spec in deps.items():\n        # Check for override first\n        if name in overrides:\n            resolved[name] = overrides[name]\n            continue\n\n        # Create resolution task based on spec type\n        if isinstance(spec, Token):\n            if hasattr(container, \"aget\"):\n                tasks[name] = asyncio.create_task(container.aget(spec))\n            else:\n                # Fallback to sync in executor\n                loop = asyncio.get_event_loop()\n                tasks[name] = loop.run_in_executor(None, container.get, spec)\n\n        elif isinstance(spec, Inject):\n            if spec.provider:\n                if iscoroutinefunction(spec.provider):\n                    tasks[name] = asyncio.create_task(spec.provider())\n                else:\n                    loop = asyncio.get_event_loop()\n                    tasks[name] = loop.run_in_executor(None, spec.provider)\n            elif spec.type:\n                if hasattr(container, \"aget\"):\n                    tasks[name] = asyncio.create_task(container.aget(spec.type))\n                else:\n                    loop = asyncio.get_event_loop()\n                    tasks[name] = loop.run_in_executor(None, container.get, spec.type)\n\n        elif isinstance(spec, type):\n            if hasattr(container, \"aget\"):\n                tasks[name] = asyncio.create_task(container.aget(spec))\n            else:\n                loop = asyncio.get_event_loop()\n                tasks[name] = loop.run_in_executor(None, container.get, spec)\n\n    # Resolve all tasks in parallel\n    if tasks:\n        results: list[Any] = await asyncio.gather(*tasks.values())\n        for name, result in zip(tasks.keys(), results, strict=False):\n            resolved[name] = result\n\n    return resolved\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>We follow trunk-based development and Conventional Commits. See the full guide in CONTRIBUTING.md.</p> <p>Key points: - Short-lived branches, PRs into <code>main</code>, squash merge. - CI must pass (ruff, basedpyright, pytest). - Releases automated by Release Please and published to PyPI via GitHub Releases.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>uv add pyinj\n# or\npip install pyinj\n</code></pre>"},{"location":"getting-started/#basic-concepts","title":"Basic Concepts","text":"<ul> <li>Token: a typed identifier for a dependency.</li> <li>Provider: a function or class that creates the dependency.</li> <li>Scope: lifecycle (SINGLETON, TRANSIENT, REQUEST).</li> </ul>"},{"location":"getting-started/#example","title":"Example","text":"<pre><code>from pyinj import Container, Token, Scope\n\ncontainer = Container()\nLOGGER = Token[Logger](\"logger\")\n\ncontainer.register(LOGGER, ConsoleLogger, Scope.SINGLETON)\n\nlogger = container.get(LOGGER)\nlogger.info(\"Hello\")\n</code></pre>"},{"location":"getting-started/#cleanup","title":"Cleanup","text":"<p>Call <code>dispose()</code> to close resources (async-friendly):</p> <pre><code>await container.dispose()\n</code></pre>"},{"location":"performance/","title":"Performance","text":"<p>PyInj targets O(1) resolution and predictable overhead:</p> <ul> <li>O(1) type lookups via token tables</li> <li>Cached signatures to avoid repeated reflection</li> <li>Lock-free fast path for singletons</li> <li>Minimal per-binding memory footprint</li> </ul> <pre><code># Pseudo-benchmark\n# 1000 services registered\n# ~0.0001ms resolution, ~500 bytes/service\n</code></pre>"},{"location":"releases/","title":"Release Process","text":"<p>Releases are automated with Release Please:</p> <ol> <li>Merge Conventional Commits into <code>main</code>.</li> <li>Release Please opens a release PR with version bump and changelog.</li> <li>Merge the release PR to tag and publish a GitHub Release.</li> <li>The <code>publish.yml</code> workflow builds and publishes to PyPI.</li> </ol> <p>See also the maintainer notes in README and <code>CLAUDE.md</code>.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#type-safe-dependencies","title":"Type-Safe Dependencies","text":"<pre><code>from typing import Protocol, runtime_checkable\nfrom pyinj import Container, Token, Scope\n\n@runtime_checkable\nclass Logger(Protocol):\n    def info(self, message: str) -&gt; None: ...\n\nclass ConsoleLogger:\n    def info(self, message: str) -&gt; None:\n        print(message)\n\ncontainer = Container()\nlogger_token = Token[Logger](\"logger\", protocol=Logger)\ncontainer.register(logger_token, ConsoleLogger, Scope.SINGLETON)\n\nlogger = container.get(logger_token)  # Type: Logger\n</code></pre>"},{"location":"usage/#auto-registration-metaclass","title":"Auto-Registration (metaclass)","text":"<pre><code>from pyinj import Injectable\n\nclass EmailService(metaclass=Injectable):\n    __injectable__ = True\n    __token_name__ = \"email_service\"\n    __scope__ = Scope.SINGLETON\n    def __init__(self, logger: Logger):\n        self.logger = logger\n</code></pre>"},{"location":"usage/#async-providers-and-cleanup","title":"Async Providers and Cleanup","text":"<pre><code>class DatabaseConnection:\n    async def aclose(self) -&gt; None: ...\n\nDB = Token[DatabaseConnection](\"db\")\ncontainer.register(DB, DatabaseConnection, Scope.SINGLETON)\n\nconn = await container.aget(DB)\nawait container.dispose()\n</code></pre>"},{"location":"usage/#plain-type-injection-ergonomic-default","title":"Plain Type Injection (ergonomic default)","text":"<p>You can annotate parameters with concrete types and let <code>@inject</code> resolve them. Primitives and builtins like <code>str</code>/<code>int</code> are ignored; user-defined classes and protocols are eligible.</p> <pre><code>from pyinj import inject\n\n@inject\ndef service(logger: Logger, db: Database) -&gt; None:\n    logger.info(\"start\"); db.connect()\n</code></pre>"}]}