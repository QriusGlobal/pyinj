{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyInj - Type-Safe Dependency Injection","text":"<p>Status: Stable \u2014 Actively maintained. Breaking changes follow semantic versioning.</p> <p>A type-safe dependency injection container for Python 3.13+ that provides:</p> <ul> <li>\ud83d\ude80 Thread-safe and async-safe resolution (ContextVar-based; no cross-talk)  </li> <li>\u26a1 O(1) performance for type lookups with pre-computed hash tokens</li> <li>\ud83d\udd0d Circular dependency detection with detailed error chains</li> <li>\ud83e\uddf9 Automatic resource cleanup (LIFO order with proper async support)</li> <li>\ud83d\udee1\ufe0f Protocol-based type safety with full static type checking</li> <li>\ud83c\udfed Metaclass auto-registration for declarative DI patterns</li> <li>\ud83d\udce6 Zero external dependencies - pure Python implementation</li> <li>\ud83c\udfaf PEP 561 compliant with <code>py.typed</code> for mypy/basedpyright support</li> </ul>"},{"location":"#quick-install","title":"Quick Install","text":"<pre><code># Install with UV (recommended)\nuv add pyinj\n\n# Or with pip\npip install pyinj\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from typing import Protocol\nfrom pyinj import Container, Token, Scope, inject\n\n# Define interfaces\nclass Logger(Protocol):\n    def info(self, message: str) -&gt; None: ...\n\nclass Database(Protocol):\n    def query(self, sql: str) -&gt; list[dict[str, str]]: ...\n\n# Implementations\nclass ConsoleLogger:\n    def info(self, message: str) -&gt; None:\n        print(f\"INFO: {message}\")\n\nclass PostgreSQLDatabase:\n    def query(self, sql: str) -&gt; list[dict[str, str]]:\n        return [{\"result\": \"data\"}]\n\n# Create container and tokens\ncontainer = Container()\nLOGGER = Token[Logger](\"logger\", scope=Scope.SINGLETON)\nDATABASE = Token[Database](\"database\", scope=Scope.SINGLETON)\n\n# Register providers\ncontainer.register(LOGGER, ConsoleLogger)\ncontainer.register(DATABASE, PostgreSQLDatabase)\n\n# Use with @inject decorator (recommended)\n@inject\ndef process_users(logger: Logger, db: Database) -&gt; None:\n    \"\"\"Dependencies injected automatically via type annotations.\"\"\"\n    logger.info(\"Processing users\")\n    users = db.query(\"SELECT * FROM users\")\n    logger.info(f\"Found {len(users)} users\")\n\n# Call without arguments - dependencies auto-resolved\nprocess_users()\n</code></pre>"},{"location":"#why-pyinj","title":"Why PyInj?","text":"<p>Traditional DI libraries are over-engineered: - 20,000+ lines of code for simple dependency injection - Heavy frameworks with steep learning curves - Poor async support and race conditions - Memory leaks and thread safety issues</p> <p>PyInj is different: - ~200 lines of pure Python - easy to understand and debug - Designed specifically for Python 3.13+ with no-GIL support - Production-focused design patterns; stable and ready for production - Can be vendored directly or installed as a package</p>"},{"location":"#core-features","title":"Core Features","text":""},{"location":"#type-safe-injection-patterns","title":"Type-Safe Injection Patterns","text":"<p>PyInj provides clear guidance on injection patterns to prevent common mistakes:</p>"},{"location":"#recommended-plain-type-annotations","title":"\u2b50 Recommended: Plain Type Annotations","text":"<pre><code>@inject  # Uses default container\ndef business_logic(logger: Logger, db: Database, user_id: int) -&gt; None:\n    \"\"\"\n    \u2705 RECOMMENDED PATTERN:\n    - Clean type annotations \n    - Automatic dependency resolution\n    - Mixed injected/regular parameters\n    \"\"\"\n    logger.info(f\"Processing user {user_id}\")\n    db.query(\"SELECT * FROM users WHERE id = ?\", user_id)\n</code></pre>"},{"location":"#anti-patterns-to-avoid","title":"\u274c Anti-Patterns to Avoid","text":"<pre><code># \u274c WRONG - Don't do this!\ndef bad_handler(logger: Inject[Logger] = None) -&gt; None:\n    # This breaks type safety and static analysis\n    pass\n</code></pre>"},{"location":"#full-static-type-checking","title":"Full Static Type Checking","text":"<p>PyInj includes a <code>py.typed</code> marker file and works with all type checkers:</p> <pre><code># Works with all type checkers\nmypy your_code.py\nbasedpyright your_code.py\npyright your_code.py\n</code></pre>"},{"location":"#contextual-scoping","title":"Contextual Scoping","text":"<pre><code># Request scope - each request gets isolated dependencies\nwith container.request_scope():\n    user = container.get(USER_TOKEN)\n    # user is scoped to this request\n\n# Session scope - longer-lived than request\nwith container.session_scope():\n    session = container.get(SESSION_TOKEN)\n    # session persists across multiple requests\n</code></pre>"},{"location":"#async-safe-resource-management","title":"Async-Safe Resource Management","text":"<pre><code># Async context manager with automatic cleanup\n@asynccontextmanager\nasync def database_connection():\n    client = AsyncDatabaseClient()\n    try:\n        yield client\n    finally:\n        await client.aclose()\n\ncontainer.register_context_async(DB_TOKEN, database_connection)\n\n# Automatic cleanup in LIFO order\nawait container.aclose()\n</code></pre>"},{"location":"#framework-integration","title":"Framework Integration","text":"<p>PyInj integrates seamlessly with popular Python frameworks:</p> <ul> <li>FastAPI: Both FastAPI-style and PyInj-style injection</li> <li>Django: Global container with automatic injection</li> <li>Flask: Request-scoped dependencies</li> <li>Click: CLI applications with DI</li> </ul>"},{"location":"#performance","title":"Performance","text":"<p>PyInj is optimized for production workloads:</p> <ul> <li>O(1) type lookups - Constant time resolution regardless of container size</li> <li>Cached injection metadata - Function signatures parsed once at decoration time  </li> <li>Lock-free fast paths - Singletons use double-checked locking pattern</li> <li>Memory efficient - Minimal overhead per registered dependency</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to build type-safe applications? Continue with:</p> <ul> <li>Getting Started - Basic patterns and setup</li> <li>Type Safety - Static type checking and PEP 561 compliance</li> <li>Usage - Framework integration and real-world examples</li> <li>Advanced - Complex patterns and performance optimization</li> <li>API Reference - Complete API documentation</li> </ul> <p>Ready to simplify your Python dependency injection?</p> <pre><code>uv add pyinj\n</code></pre>"},{"location":"advanced/","title":"Advanced","text":""},{"location":"advanced/#protocol-based-resolution","title":"Protocol-Based Resolution","text":"<pre><code>@container.inject\ndef business_logic(logger: Logger, db: Database) -&gt; str:\n    logger.info(\"Processing\")\n    return db.query(\"SELECT 1\")\n</code></pre>"},{"location":"advanced/#scopes","title":"Scopes","text":"<ul> <li>SINGLETON: one instance per container</li> <li>TRANSIENT: new instance per resolve</li> <li>REQUEST: request-bound lifetime</li> </ul>"},{"location":"advanced/#testing-and-overrides","title":"Testing and Overrides","text":"<pre><code>mock = Mock(spec=Logger)\ncontainer.override(logger_token, mock)\n...\ncontainer.clear_overrides()\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>This page provides a comprehensive reference for all PyInj classes, functions, and constants.</p>"},{"location":"api/#core-classes","title":"Core Classes","text":""},{"location":"api/#container","title":"Container","text":"<p><code>pyinj.Container</code></p> <p>The main dependency injection container that manages services and their lifecycles.</p>"},{"location":"api/#methods","title":"Methods","text":"<p><code>register(token: Token[T], provider: Callable[[], T], scope: Scope = Scope.TRANSIENT) -&gt; None</code></p> <p>Register a provider function for a token.</p> <ul> <li><code>token</code>: Token identifying the dependency</li> <li><code>provider</code>: Function that creates instances</li> <li><code>scope</code>: Lifecycle scope (SINGLETON, REQUEST, SESSION, TRANSIENT)</li> </ul> <p><code>get(token: Token[T]) -&gt; T</code></p> <p>Synchronously resolve a dependency.</p> <ul> <li><code>token</code>: Token to resolve</li> <li>Returns: Instance of type T</li> <li>Raises: <code>ResolutionError</code> if dependency cannot be resolved</li> </ul> <p><code>aget(token: Token[T]) -&gt; Awaitable[T]</code></p> <p>Asynchronously resolve a dependency.</p> <ul> <li><code>token</code>: Token to resolve  </li> <li>Returns: Awaitable instance of type T</li> <li>Raises: <code>ResolutionError</code> if dependency cannot be resolved</li> </ul> <p><code>override(token: Token[T], instance: T) -&gt; None</code></p> <p>Override a registered dependency with a specific instance (useful for testing).</p> <ul> <li><code>token</code>: Token to override</li> <li><code>instance</code>: Instance to use instead of the registered provider</li> </ul> <p><code>clear_overrides() -&gt; None</code></p> <p>Clear all dependency overrides.</p> <p><code>register_context_sync(token: Token[T], context_provider: Callable[[], ContextManager[T]]) -&gt; None</code></p> <p>Register a synchronous context manager provider.</p> <ul> <li><code>token</code>: Token identifying the dependency</li> <li><code>context_provider</code>: Function returning a context manager</li> </ul> <p><code>register_context_async(token: Token[T], context_provider: Callable[[], AsyncContextManager[T]]) -&gt; None</code></p> <p>Register an asynchronous context manager provider.</p> <ul> <li><code>token</code>: Token identifying the dependency</li> <li><code>context_provider</code>: Function returning an async context manager</li> </ul> <p><code>request_scope() -&gt; ContextManager[Container]</code></p> <p>Create a synchronous request scope context manager.</p> <p><code>async_request_scope() -&gt; AsyncContextManager[Container]</code></p> <p>Create an asynchronous request scope context manager.</p> <p><code>session_scope() -&gt; ContextManager[Container]</code></p> <p>Create a session scope context manager.</p> <p><code>aclose() -&gt; Awaitable[None]</code></p> <p>Asynchronously clean up all managed resources.</p>"},{"location":"api/#token","title":"Token","text":"<p><code>pyinj.Token[T]</code></p> <p>A typed identifier for dependencies with pre-computed hash for O(1) lookups.</p>"},{"location":"api/#constructor","title":"Constructor","text":"<p><code>Token(name: str, type_: type[T], scope: Scope = Scope.TRANSIENT, qualifier: str | None = None, tags: tuple[str, ...] = ())</code></p> <ul> <li><code>name</code>: Human-readable name</li> <li><code>type_</code>: Expected Python type</li> <li><code>scope</code>: Default lifecycle scope</li> <li><code>qualifier</code>: Optional qualifier for multiple instances of same type</li> <li><code>tags</code>: Optional tags for discovery/metadata</li> </ul>"},{"location":"api/#properties","title":"Properties","text":"<p><code>name: str</code></p> <p>Human-readable name of the token.</p> <p><code>type_: type[T]</code></p> <p>The expected Python type for this token.</p> <p><code>scope: Scope</code></p> <p>Default lifecycle scope.</p> <p><code>qualifier: str | None</code></p> <p>Optional qualifier string.</p> <p><code>tags: tuple[str, ...]</code></p> <p>Immutable tuple of tags.</p> <p><code>qualified_name: str</code></p> <p>Fully qualified name including module, type, qualifier, and token name.</p>"},{"location":"api/#methods_1","title":"Methods","text":"<p><code>with_scope(scope: Scope) -&gt; Token[T]</code></p> <p>Return a copy with a different scope.</p> <p><code>with_qualifier(qualifier: str) -&gt; Token[T]</code></p> <p>Return a copy with a qualifier.</p> <p><code>with_tags(*tags: str) -&gt; Token[T]</code></p> <p>Return a copy with additional tags.</p> <p><code>validate(instance: object) -&gt; bool</code></p> <p>Validate that an instance matches the token's expected type.</p>"},{"location":"api/#tokenfactory","title":"TokenFactory","text":"<p><code>pyinj.TokenFactory</code></p> <p>Factory for creating and caching commonly used tokens.</p>"},{"location":"api/#methods_2","title":"Methods","text":"<p><code>create(name: str, type_: type[T], scope: Scope = Scope.TRANSIENT, qualifier: str | None = None, tags: tuple[str, ...] = ()) -&gt; Token[T]</code></p> <p>Create a token with caching for common patterns.</p> <p><code>singleton(name: str, type_: type[T]) -&gt; Token[T]</code></p> <p>Create a singleton-scoped token.</p> <p><code>request(name: str, type_: type[T]) -&gt; Token[T]</code></p> <p>Create a request-scoped token.</p> <p><code>session(name: str, type_: type[T]) -&gt; Token[T]</code></p> <p>Create a session-scoped token.</p> <p><code>transient(name: str, type_: type[T]) -&gt; Token[T]</code></p> <p>Create a transient-scoped token.</p> <p><code>qualified(qualifier: str, type_: type[T], scope: Scope = Scope.TRANSIENT) -&gt; Token[T]</code></p> <p>Create a qualified token.</p> <p><code>clear_cache() -&gt; None</code></p> <p>Clear the internal token cache.</p> <p><code>cache_size: int</code></p> <p>Number of cached tokens.</p>"},{"location":"api/#enums","title":"Enums","text":""},{"location":"api/#scope","title":"Scope","text":"<p><code>pyinj.Scope</code></p> <p>Enumeration of dependency lifecycle scopes.</p>"},{"location":"api/#values","title":"Values","text":"<p><code>SINGLETON</code></p> <p>One instance per container (process-wide).</p> <p><code>REQUEST</code></p> <p>One instance per request context.</p> <p><code>SESSION</code></p> <p>One instance per session context.</p> <p><code>TRANSIENT</code></p> <p>New instance for every resolution.</p>"},{"location":"api/#decorators-and-markers","title":"Decorators and Markers","text":""},{"location":"api/#inject","title":"inject","text":"<p><code>pyinj.inject(func: Callable = None, *, container: Container | None = None, cache: bool = True) -&gt; Callable</code></p> <p>Decorator that automatically injects dependencies based on type annotations.</p> <ul> <li><code>func</code>: Function to decorate</li> <li><code>container</code>: Container to use (uses default if None)</li> <li><code>cache</code>: Whether to cache dependency analysis</li> <li>Returns: Decorated function with dependency injection</li> </ul>"},{"location":"api/#usage","title":"Usage","text":"<pre><code>@inject\ndef handler(logger: Logger, db: Database) -&gt; None:\n    # Dependencies automatically injected\n    pass\n\n@inject(container=my_container)\nasync def async_handler(service: AsyncService) -&gt; None:\n    # Use specific container\n    pass\n</code></pre>"},{"location":"api/#inject_1","title":"Inject","text":"<p><code>pyinj.Inject[T]</code></p> <p>Marker class for explicit dependency injection.</p>"},{"location":"api/#usage_1","title":"Usage","text":"<pre><code>from typing import Annotated\n\n@inject\ndef handler(\n    logger: Logger,  # Simple injection\n    cache: Annotated[Cache, Inject(lambda: MockCache())]  # Custom provider\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/#given","title":"Given","text":"<p><code>pyinj.Given[T]</code></p> <p>Scala-style marker for implicit dependencies (alias for Inject[T]).</p>"},{"location":"api/#depends","title":"Depends","text":"<p><code>pyinj.Depends(provider: Callable[[], T]) -&gt; T</code></p> <p>FastAPI-compatible dependency marker.</p> <pre><code>def handler(service: Service = Depends(lambda: ServiceImpl())) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/#contextual-containers","title":"Contextual Containers","text":""},{"location":"api/#contextualcontainer","title":"ContextualContainer","text":"<p><code>pyinj.ContextualContainer</code></p> <p>Base class adding request/session context support via <code>contextvars</code>. The main <code>Container</code> class inherits from this.</p>"},{"location":"api/#methods_3","title":"Methods","text":"<p><code>resolve_from_context(token: Token[T]) -&gt; T | None</code></p> <p>Resolve dependency from current context without creating new instances.</p> <p><code>store_in_context(token: Token[T], instance: T) -&gt; None</code></p> <p>Store instance in appropriate context based on token scope.</p> <p><code>clear_request_context() -&gt; None</code></p> <p>Clear current request context.</p> <p><code>clear_session_context() -&gt; None</code></p> <p>Clear current session context.</p> <p><code>clear_all_contexts() -&gt; None</code></p> <p>Clear all contexts including singletons.</p>"},{"location":"api/#requestscope","title":"RequestScope","text":"<p><code>pyinj.RequestScope</code></p> <p>Helper class for managing request-scoped dependencies.</p>"},{"location":"api/#usage_2","title":"Usage","text":"<pre><code>async with RequestScope(container) as scope:\n    service = scope.resolve(ServiceToken)\n</code></pre>"},{"location":"api/#sessionscope","title":"SessionScope","text":"<p><code>pyinj.SessionScope</code></p> <p>Helper class for managing session-scoped dependencies.</p>"},{"location":"api/#exceptions","title":"Exceptions","text":""},{"location":"api/#pyinjerror","title":"PyInjError","text":"<p><code>pyinj.exceptions.PyInjError</code></p> <p>Base exception for all PyInj errors.</p>"},{"location":"api/#resolutionerror","title":"ResolutionError","text":"<p><code>pyinj.exceptions.ResolutionError</code></p> <p>Raised when a dependency cannot be resolved.</p>"},{"location":"api/#properties_1","title":"Properties","text":"<p><code>token: Token[Any]</code></p> <p>The token that couldn't be resolved.</p> <p><code>chain: list[Token[Any]]</code></p> <p>The resolution chain leading to the error.</p> <p><code>cause: str</code></p> <p>Human-readable cause description.</p>"},{"location":"api/#circulardependencyerror","title":"CircularDependencyError","text":"<p><code>pyinj.exceptions.CircularDependencyError</code></p> <p>Raised when circular dependency is detected. Inherits from <code>ResolutionError</code>.</p>"},{"location":"api/#asynccleanuprequirederror","title":"AsyncCleanupRequiredError","text":"<p><code>pyinj.exceptions.AsyncCleanupRequiredError</code></p> <p>Raised when synchronous cleanup is attempted on async-only resources.</p>"},{"location":"api/#container-management-functions","title":"Container Management Functions","text":""},{"location":"api/#get_default_container","title":"get_default_container","text":"<p><code>pyinj.get_default_container() -&gt; Container</code></p> <p>Get the global default container.</p> <ul> <li>Returns: The default container instance</li> <li>Raises: <code>RuntimeError</code> if no default container is set</li> </ul>"},{"location":"api/#set_default_container","title":"set_default_container","text":"<p><code>pyinj.set_default_container(container: Container) -&gt; None</code></p> <p>Set the global default container.</p> <ul> <li><code>container</code>: Container instance to use as default</li> </ul>"},{"location":"api/#metaclass-support","title":"Metaclass Support","text":""},{"location":"api/#injectable","title":"Injectable","text":"<p><code>pyinj.Injectable</code></p> <p>Metaclass for automatic service registration.</p>"},{"location":"api/#usage_3","title":"Usage","text":"<pre><code>class EmailService(metaclass=Injectable):\n    __injectable__ = True\n    __token_name__ = \"email_service\"\n    __scope__ = Scope.SINGLETON\n\n    def __init__(self, logger: Logger):\n        self.logger = logger\n</code></pre>"},{"location":"api/#type-annotations","title":"Type Annotations","text":""},{"location":"api/#protocols","title":"Protocols","text":"<p>PyInj works with Python's <code>Protocol</code> system for structural typing:</p> <pre><code>from typing import Protocol, runtime_checkable\n\n@runtime_checkable\nclass Logger(Protocol):\n    def info(self, message: str) -&gt; None: ...\n    def error(self, message: str) -&gt; None: ...\n</code></pre>"},{"location":"api/#generic-support","title":"Generic Support","text":"<p>PyInj fully supports generic types:</p> <pre><code>from typing import Generic, TypeVar\n\nT = TypeVar('T')\n\nclass Repository(Protocol, Generic[T]):\n    def save(self, entity: T) -&gt; None: ...\n    def find_by_id(self, id: int) -&gt; T | None: ...\n\nUSER_REPO = Token[Repository[User]](\"user_repo\")\n</code></pre>"},{"location":"api/#constants-and-configuration","title":"Constants and Configuration","text":""},{"location":"api/#version-information","title":"Version Information","text":"<p><code>pyinj.__version__</code></p> <p>String containing the current PyInj version.</p> <p><code>pyinj.__author__</code></p> <p>Author information.</p>"},{"location":"api/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Token resolution: O(1) time complexity due to pre-computed hashes</li> <li>Injection analysis: Cached for repeated use of <code>@inject</code></li> <li>Memory overhead: ~500 bytes per registered service</li> <li>Thread safety: Full thread and async safety via <code>contextvars</code></li> <li>Circular dependency detection: Early detection with detailed error chains</li> </ul>"},{"location":"api/#type-safety-features","title":"Type Safety Features","text":"<ul> <li>PEP 561 compliant: Includes <code>py.typed</code> marker file</li> <li>Full static analysis: Works with mypy, basedpyright, pyright</li> <li>Protocol validation: Runtime checking with <code>@runtime_checkable</code></li> <li>Generic preservation: Complete generic type support throughout the API</li> <li>Zero runtime type overhead: Type checking is compile-time only (unless explicitly requested)</li> </ul> <p>This API reference covers all public interfaces in PyInj. For examples and usage patterns, see the other documentation sections.</p>"},{"location":"concurrency/","title":"Concurrency","text":"<p>PyInj is designed for both threaded and async-concurrent programs.</p> <ul> <li>Thread-safe singletons: first creation is protected by locks.</li> <li>Async-safe singletons: first creation is protected by <code>asyncio.Lock</code>.</li> <li>Request/session scoping: implemented with <code>contextvars</code>, so context flows across awaits.</li> <li>Overrides: per-request overrides backed by <code>ContextVar</code> for isolation.</li> </ul>"},{"location":"concurrency/#threaded-programs","title":"Threaded programs","text":"<pre><code>from pyinj import Container, Token, Scope\nimport threading\n\ncontainer = Container()\nCACHE = Token[dict[str, str]](\"cache\", scope=Scope.SINGLETON)\ncontainer.register(CACHE, lambda: {\"a\": \"1\"})\n\n# Safe: every thread gets the same singleton\nvalues: list[dict[str, str]] = []\n\ndef worker() -&gt; None:\n    values.append(container.get(CACHE))\n\nthreads = [threading.Thread(target=worker) for _ in range(10)]\n[t.start() for t in threads]\n[t.join() for t in threads]\nassert all(v is values[0] for v in values)\n</code></pre>"},{"location":"concurrency/#async-programs","title":"Async programs","text":"<pre><code>import asyncio\nfrom typing import Awaitable\nfrom pyinj import Container, Token, Scope\n\ncontainer = Container()\n\nclass Client:\n    async def aclose(self) -&gt; None: ...\n\nCLIENT = Token[Client](\"client\", scope=Scope.SINGLETON)\n\nasync def make_client() -&gt; Client:\n    await asyncio.sleep(0)  # simulate I/O\n    return Client()\n\ncontainer.register(CLIENT, make_client)\n\nasync def main() -&gt; None:\n    # Safe: async singleton is created once under an asyncio.Lock\n    c1, c2 = await asyncio.gather(container.aget(CLIENT), container.aget(CLIENT))\n    assert c1 is c2\n\nasyncio.run(main())\n</code></pre>"},{"location":"concurrency/#request-session-scope-web-style-lifetimes","title":"Request / session scope (web-style lifetimes)","text":"<pre><code>from typing import Any\nfrom pyinj import Container, Token, Scope\n\ncontainer = Container()\nSESSION = Token[dict[str, Any]](\"session\", scope=Scope.SESSION)\nREQUEST = Token[dict[str, Any]](\"request\", scope=Scope.REQUEST)\n\ncontainer.register(SESSION, lambda: {\"s\": 1})\ncontainer.register(REQUEST, lambda: {\"r\": 1})\n\n# Request scope isolates per-request caches while sharing singletons\nwith container.request_scope():\n    assert container.get(REQUEST)[\"r\"] == 1\n    with container.request_scope():\n        assert container.get(REQUEST)[\"r\"] == 1  # new dict in inner scope\n\nNote: nested `request_scope` blocks are fully isolated; the inner scope does not inherit the parent request cache. This ensures deterministic lifetimes for per-request values.\n</code></pre>"},{"location":"concurrency/#overrides-per-request","title":"Overrides per request","text":"<pre><code>from typing import Any\n\nLOGGER = Token[object](\"logger\")\ncontainer.register(LOGGER, lambda: object())\n\nwith container.use_overrides({LOGGER: \"fake\"}):\n    assert container.get(LOGGER) == \"fake\"\n# Outside override, original provider is used\nassert container.get(LOGGER) != \"fake\"\n</code></pre>"},{"location":"concurrency/#cleanup","title":"Cleanup","text":"<ul> <li>Request/session scopes clean up resources stored in the scope when the scope exits.</li> <li>Container-level <code>dispose()</code> / <code>aclose()</code> cleans up resources registered via <code>register_context(...)</code> (both sync and async).</li> </ul> <pre><code># Register a context-managed singleton (async)\nfrom contextlib import asynccontextmanager\n\n@asynccontextmanager\nasync def client_cm():\n    c = make_async_client()\n    try:\n        yield c\n    finally:\n        await c.aclose()\n\nCLIENT = Token[AsyncClient](\"client\", scope=Scope.SINGLETON)\ncontainer.register_context(CLIENT, lambda: client_cm(), is_async=True)\n\n# Later, ensure cleanup runs\nawait container.aclose()  # or await container.dispose()\n\nMixed cleanup in async request scopes:\n- In `async_request_scope`, async cleanups run first, then sync cleanups. This ensures awaiting all async finalizers before executing any synchronous ones, avoiding event loop blocking.\n\nTyped registration helpers:\n- `register_context_sync(token, cm_provider, scope=...)` for sync context managers.\n- `register_context_async(token, cm_provider, scope=...)` for async context managers.\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>We follow trunk-based development and Conventional Commits. See the full guide in CONTRIBUTING.md.</p> <p>Key points: - Short-lived branches, PRs into <code>main</code>, squash merge. - CI must pass (ruff, basedpyright, pytest). - Releases automated by Release Please and published to PyPI via GitHub Releases.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide covers the fundamentals of using PyInj for type-safe dependency injection in Python 3.13+.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code># UV (recommended)\nuv add pyinj\n\n# Or pip\npip install pyinj\n</code></pre>"},{"location":"getting-started/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/#token","title":"Token","text":"<p>A typed identifier that represents a dependency. Tokens are immutable and use pre-computed hashes for O(1) lookups.</p> <pre><code>from pyinj import Token\nfrom typing import Protocol\n\nclass Logger(Protocol):\n    def info(self, message: str) -&gt; None: ...\n\n# Create a token for the Logger protocol\nLOGGER = Token[Logger](\"logger\", scope=Scope.SINGLETON)\n</code></pre>"},{"location":"getting-started/#container","title":"Container","text":"<p>The central registry that manages dependencies and their lifecycles.</p> <pre><code>from pyinj import Container\n\ncontainer = Container()\n</code></pre>"},{"location":"getting-started/#provider","title":"Provider","text":"<p>A function or class that creates instances of dependencies.</p> <pre><code>class ConsoleLogger:\n    def info(self, message: str) -&gt; None:\n        print(f\"INFO: {message}\")\n\n# Register the provider\ncontainer.register(LOGGER, ConsoleLogger)\n</code></pre>"},{"location":"getting-started/#scope","title":"Scope","text":"<p>Defines the lifecycle of dependencies:</p> <ul> <li>SINGLETON: One instance per container (shared across all requests)</li> <li>REQUEST: One instance per request context  </li> <li>SESSION: One instance per session context</li> <li>TRANSIENT: New instance every time</li> </ul>"},{"location":"getting-started/#basic-example","title":"Basic Example","text":"<p>Here's a complete example showing the fundamental pattern:</p> <pre><code>from typing import Protocol\nfrom pyinj import Container, Token, Scope\n\n# Define interfaces using protocols\nclass Logger(Protocol):\n    def info(self, message: str) -&gt; None: ...\n    def error(self, message: str) -&gt; None: ...\n\nclass Database(Protocol):\n    def query(self, sql: str) -&gt; list[dict[str, str]]: ...\n\n# Implement the interfaces\nclass ConsoleLogger:\n    def info(self, message: str) -&gt; None:\n        print(f\"INFO: {message}\")\n\n    def error(self, message: str) -&gt; None:\n        print(f\"ERROR: {message}\")\n\nclass PostgreSQLDatabase:\n    def query(self, sql: str) -&gt; list[dict[str, str]]:\n        # Mock implementation\n        return [{\"id\": \"1\", \"name\": \"Alice\"}]\n\n# Create container and tokens\ncontainer = Container()\nLOGGER = Token[Logger](\"logger\", scope=Scope.SINGLETON)\nDATABASE = Token[Database](\"database\", scope=Scope.SINGLETON)\n\n# Register providers\ncontainer.register(LOGGER, ConsoleLogger)\ncontainer.register(DATABASE, PostgreSQLDatabase)\n\n# Resolve dependencies manually\nlogger = container.get(LOGGER)\ndb = container.get(DATABASE)\n\n# Use the dependencies\nlogger.info(\"Application started\")\nusers = db.query(\"SELECT * FROM users\")\nlogger.info(f\"Found {len(users)} users\")\n</code></pre>"},{"location":"getting-started/#type-safe-injection-patterns","title":"Type-Safe Injection Patterns","text":"<p>PyInj provides multiple ways to inject dependencies. Here's the recommended approach:</p>"},{"location":"getting-started/#recommended-inject-with-type-annotations","title":"\u2b50 Recommended: <code>@inject</code> with Type Annotations","text":"<p>This is the cleanest and most type-safe approach:</p> <pre><code>from pyinj import inject, set_default_container\n\n# Set up a default container (optional)\nset_default_container(container)\n\n@inject  # Uses default container\ndef process_users(logger: Logger, db: Database) -&gt; None:\n    \"\"\"Dependencies are automatically injected based on type annotations.\"\"\"\n    logger.info(\"Processing users\")\n    users = db.query(\"SELECT * FROM users\")\n\n    for user in users:\n        logger.info(f\"Processing user: {user['name']}\")\n\n# Call without providing dependencies - they're auto-injected\nprocess_users()\n</code></pre>"},{"location":"getting-started/#mixed-parameters","title":"Mixed Parameters","text":"<p>You can mix injected dependencies with regular parameters:</p> <pre><code>@inject\ndef process_user_by_id(\n    user_id: int,           # Regular parameter\n    logger: Logger,         # Injected dependency\n    db: Database           # Injected dependency\n) -&gt; dict[str, str] | None:\n    logger.info(f\"Looking up user {user_id}\")\n    users = db.query(f\"SELECT * FROM users WHERE id = '{user_id}'\")\n    return users[0] if users else None\n\n# Call with only regular parameters\nuser = process_user_by_id(user_id=123)\n</code></pre>"},{"location":"getting-started/#async-support","title":"Async Support","text":"<p>PyInj fully supports async functions and providers:</p> <pre><code>import asyncio\nfrom typing import Protocol\n\nclass AsyncDatabase(Protocol):\n    async def connect(self) -&gt; None: ...\n    async def query(self, sql: str) -&gt; list[dict[str, str]]: ...\n    async def aclose(self) -&gt; None: ...\n\nclass AsyncPostgreSQLDatabase:\n    def __init__(self) -&gt; None:\n        self.connected = False\n\n    async def connect(self) -&gt; None:\n        print(\"Connecting to async database...\")\n        await asyncio.sleep(0.1)  # Simulate connection time\n        self.connected = True\n\n    async def query(self, sql: str) -&gt; list[dict[str, str]]:\n        if not self.connected:\n            await self.connect()\n        return [{\"id\": \"1\", \"name\": \"Alice\"}]\n\n    async def aclose(self) -&gt; None:\n        print(\"Closing async database...\")\n        self.connected = False\n\n# Register async provider\nASYNC_DB = Token[AsyncDatabase](\"async_db\", scope=Scope.SINGLETON)\n\nasync def create_async_db() -&gt; AsyncDatabase:\n    db = AsyncPostgreSQLDatabase()\n    await db.connect()\n    return db\n\ncontainer.register(ASYNC_DB, create_async_db)\n\n# Async injection\n@inject\nasync def process_users_async(\n    logger: Logger,           # Sync dependency\n    db: AsyncDatabase        # Async dependency  \n) -&gt; None:\n    logger.info(\"Processing users asynchronously\")\n    users = await db.query(\"SELECT * FROM users\")\n\n    for user in users:\n        logger.info(f\"Processing user: {user['name']}\")\n\n# Usage\nasync def main() -&gt; None:\n    await process_users_async()\n    await container.aclose()  # Cleanup async resources\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/#common-anti-patterns-to-avoid","title":"Common Anti-Patterns to Avoid","text":""},{"location":"getting-started/#wrong-injectt-none","title":"\u274c Wrong: <code>Inject[T] = None</code>","text":"<pre><code># \u274c DON'T DO THIS - Breaks type safety\nfrom pyinj import Inject\n\ndef bad_handler(logger: Inject[Logger] = None) -&gt; None:\n    # This breaks static type checking and is confusing\n    pass\n</code></pre>"},{"location":"getting-started/#wrong-unnecessary-injectt-markers","title":"\u274c Wrong: Unnecessary Inject[T] Markers","text":"<pre><code># \u274c UNNECESSARY - Just use plain type annotations\ndef confusing_handler(logger: Inject[Logger]) -&gt; None:\n    # This works but is unnecessarily complex\n    pass\n</code></pre>"},{"location":"getting-started/#correct-simple-type-annotations","title":"\u2705 Correct: Simple Type Annotations","text":"<pre><code># \u2705 CLEAN AND TYPE-SAFE\n@inject\ndef good_handler(logger: Logger) -&gt; None:\n    logger.info(\"This is the recommended pattern\")\n</code></pre>"},{"location":"getting-started/#scoped-dependencies","title":"Scoped Dependencies","text":"<p>PyInj supports different dependency scopes for various use cases:</p>"},{"location":"getting-started/#singleton-scope","title":"Singleton Scope","text":"<p>One instance shared across the entire application:</p> <pre><code>CONFIG = Token[Configuration](\"config\", scope=Scope.SINGLETON)\n\nclass Configuration:\n    def __init__(self) -&gt; None:\n        self.database_url = \"postgresql://localhost/myapp\"\n        self.debug = True\n\ncontainer.register(CONFIG, Configuration)\n\n# Same instance returned every time\nconfig1 = container.get(CONFIG)\nconfig2 = container.get(CONFIG)\nassert config1 is config2\n</code></pre>"},{"location":"getting-started/#request-scope","title":"Request Scope","text":"<p>One instance per request context (useful for web applications):</p> <pre><code>USER = Token[User](\"current_user\", scope=Scope.REQUEST)\n\ndef get_current_user() -&gt; User:\n    # This would typically extract user from request context\n    return User(id=123, name=\"Alice\")\n\ncontainer.register(USER, get_current_user)\n\n# Different instances in different request scopes\nwith container.request_scope():\n    user1 = container.get(USER)\n    user2 = container.get(USER)\n    assert user1 is user2  # Same instance within scope\n\nwith container.request_scope():\n    user3 = container.get(USER)\n    assert user1 is not user3  # Different instance in new scope\n</code></pre>"},{"location":"getting-started/#resource-cleanup","title":"Resource Cleanup","text":"<p>PyInj provides automatic resource cleanup using context managers:</p>"},{"location":"getting-started/#sync-resource-cleanup","title":"Sync Resource Cleanup","text":"<pre><code>from contextlib import contextmanager\nfrom typing import Generator\n\n@contextmanager \ndef database_connection() -&gt; Generator[Database, None, None]:\n    print(\"Opening database connection\")\n    db = PostgreSQLDatabase()\n    try:\n        yield db\n    finally:\n        print(\"Closing database connection\")\n        db.close()\n\ncontainer.register_context_sync(DATABASE, database_connection)\n\n# Resources are automatically cleaned up\nwith container:\n    db = container.get(DATABASE)\n    # Use database\n# Database connection closed automatically\n</code></pre>"},{"location":"getting-started/#async-resource-cleanup","title":"Async Resource Cleanup","text":"<pre><code>from contextlib import asynccontextmanager\nfrom typing import AsyncGenerator\n\n@asynccontextmanager\nasync def async_database_connection() -&gt; AsyncGenerator[AsyncDatabase, None]:\n    print(\"Opening async database connection\")\n    db = AsyncPostgreSQLDatabase()\n    await db.connect()\n    try:\n        yield db\n    finally:\n        print(\"Closing async database connection\")\n        await db.aclose()\n\ncontainer.register_context_async(ASYNC_DB, async_database_connection)\n\n# Async cleanup\nasync def main() -&gt; None:\n    db = await container.aget(ASYNC_DB)\n    # Use database\n    await container.aclose()  # Proper async cleanup\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/#circuit-breaker-for-mixed-cleanup","title":"Circuit Breaker for Mixed Cleanup","text":"<p>PyInj prevents resource leaks by raising <code>AsyncCleanupRequiredError</code> when you try to use sync cleanup on async-only resources:</p> <pre><code>from pyinj import AsyncCleanupRequiredError\n\n# Register an async-only resource\ncontainer.register_context_async(ASYNC_DB, async_database_connection)\n\ntry:\n    # This will raise AsyncCleanupRequiredError\n    with container:\n        db = container.get(ASYNC_DB)  \nexcept AsyncCleanupRequiredError as e:\n    print(f\"Use async cleanup: {e}\")\n\n# Correct way:\nasync def main() -&gt; None:\n    async with container.async_context():\n        db = await container.aget(ASYNC_DB)\n        # Use database\n    # Automatic async cleanup\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/#tokenfactory-for-convenience","title":"TokenFactory for Convenience","text":"<p>The <code>TokenFactory</code> provides convenient methods for creating tokens:</p> <pre><code>from pyinj import TokenFactory\n\nfactory = TokenFactory()\n\n# Convenient creation methods\nLOGGER = factory.singleton(\"logger\", Logger)\nCACHE = factory.request(\"cache\", CacheService)\nCONFIG = factory.session(\"config\", Configuration)\nTEMP_FILE = factory.transient(\"temp_file\", TempFile)\n\n# With qualifiers for multiple instances\nPRIMARY_DB = factory.qualified(\"primary\", Database, Scope.SINGLETON)\nSECONDARY_DB = factory.qualified(\"secondary\", Database, Scope.SINGLETON)\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, explore these advanced topics:</p> <ul> <li>Type Safety - Learn about PEP 561 compliance and static type checking</li> <li>Usage - Framework integration and real-world patterns</li> <li>Advanced - Complex patterns and performance optimization</li> <li>Testing - Testing strategies with dependency overrides</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"getting-started/#quick-reference","title":"Quick Reference","text":""},{"location":"getting-started/#essential-imports","title":"Essential Imports","text":"<pre><code>from typing import Protocol\nfrom pyinj import Container, Token, Scope, inject\n</code></pre>"},{"location":"getting-started/#basic-pattern","title":"Basic Pattern","text":"<pre><code># 1. Define interface\nclass Service(Protocol):\n    def method(self) -&gt; str: ...\n\n# 2. Create implementation  \nclass ServiceImpl:\n    def method(self) -&gt; str:\n        return \"result\"\n\n# 3. Register with container\ncontainer = Container()\nSERVICE = Token[Service](\"service\", scope=Scope.SINGLETON)\ncontainer.register(SERVICE, ServiceImpl)\n\n# 4. Use with injection\n@inject\ndef handler(service: Service) -&gt; None:\n    result = service.method()\n</code></pre> <p>This covers the fundamentals of PyInj. The key is to use type annotations with the <code>@inject</code> decorator for clean, type-safe dependency injection.</p>"},{"location":"internals/","title":"Internals","text":"<p>This page outlines how PyInj is structured under the hood.</p>"},{"location":"internals/#core-concepts","title":"Core concepts","text":"<ul> <li>Token[T]: immutable, hashable identifier for a typed dependency. Holds <code>name</code>, <code>type_</code>, <code>scope</code>, optional <code>qualifier</code>, and <code>tags</code>.</li> <li>ProviderLike[T]: either a sync provider <code>() -&gt; T</code> or async provider <code>() -&gt; Awaitable[T]</code>.</li> <li>Scopes:</li> <li>SINGLETON: shared across the process/container</li> <li>REQUEST: bound to the current request context</li> <li>SESSION: longer-lived context separate from request</li> <li>TRANSIENT: created each resolution</li> </ul>"},{"location":"internals/#container","title":"Container","text":"<ul> <li>Registries</li> <li><code>_providers: dict[Token[object], ProviderLike[object]]</code></li> <li><code>_singletons: dict[Token[object], object]</code></li> <li><code>_token_scopes: dict[Token[object], Scope]</code></li> <li><code>_async_locks: dict[Token[object], asyncio.Lock]</code></li> <li>Concurrency</li> <li>Thread-safe singleton creation (per-token <code>threading.Lock</code>)</li> <li>Async-safe singleton creation (per-token <code>asyncio.Lock</code>)</li> <li>Contexts</li> <li>Uses <code>contextvars</code> to implement REQUEST and SESSION scoping</li> <li><code>use_overrides()</code> merges override maps per context</li> </ul>"},{"location":"internals/#resolution","title":"Resolution","text":"<ul> <li><code>get(Token[T] | type[T]) -&gt; T</code></li> <li>If a <code>type[T]</code> is passed, the container finds or creates a matching token.</li> <li>Checks overrides, request/session caches, then provider</li> <li>Validates type using <code>Token.validate()</code> before storing</li> <li>Disallows calling async providers in sync <code>get()</code></li> <li><code>aget(Token[T] | type[T]) -&gt; T</code></li> <li>Async variant; awaits async providers and uses <code>asyncio.Lock</code> for singletons</li> </ul>"},{"location":"internals/#injection","title":"Injection","text":"<ul> <li>Analyzer inspects function signatures and annotations to build a dependency plan.</li> <li>Supported patterns (preferred first):</li> <li><code>Annotated[T, Inject()]</code></li> <li>Default marker: <code>param: T = Inject()</code></li> <li>Direct <code>Token[T]</code> annotations</li> <li>Plain type-only injection for non-builtin classes/protocols</li> <li>Decorator <code>@inject</code> resolves dependencies per call (sync/async) and passes them as kwargs.</li> </ul>"},{"location":"internals/#typing-model","title":"Typing model","text":"<ul> <li><code>get/aget</code> return types depend on runtime providers in a DI system; the container remains generic.</li> <li>At call sites, annotate variables that receive container results when you need static precision.</li> <li>For <code>@inject</code>, prefer <code>Annotated[T, Inject()]</code> so tools know T is the runtime type while Inject carries metadata.</li> </ul>"},{"location":"llm/","title":"LLM Guide: Using PyInj for Reliable DI","text":"<p>Purpose: concise guidance for integrating PyInj into LLM-driven projects and tools.</p> <ul> <li>Audience: engineers wiring DI into agents, tools, plugins.</li> <li>Constraints: brief, &lt;10k tokens, actionable.</li> </ul>"},{"location":"llm/#core-concepts","title":"Core Concepts","text":"<ul> <li>Token[T]: typed identifier for a dependency; holds name, type, scope.</li> <li>Scopes: SINGLETON (process), SESSION (user/session), REQUEST (per-call), TRANSIENT.</li> <li>Resolution: <code>get/aget</code> by token or type; <code>@inject</code> for functions.</li> <li>Registrations are immutable: re-registering a token raises.</li> </ul>"},{"location":"llm/#setup-minimal-boilerplate","title":"Setup (Minimal Boilerplate)","text":"<pre><code>from pyinj import Container, Token, Scope\ncontainer = Container()\n\n# Tokens\nHTTP = Token[HttpClient](\"http\", scope=Scope.SINGLETON)\nTOOLRUN = Token[dict](\"toolrun\", scope=Scope.REQUEST)\n\n# Providers\ncontainer.register(TOOLRUN, lambda: {\"invocations\": 0})\n\n# Context-managed async singleton\nfrom contextlib import asynccontextmanager\n@asynccontextmanager\nasync def http_cm():\n    client = HttpClient()\n    try:\n        yield client\n    finally:\n        await client.aclose()\n\ncontainer.register_context_async(HTTP, lambda: http_cm())\n</code></pre>"},{"location":"llm/#per-call-isolation-agentstools","title":"Per-Call Isolation (Agents/Tools)","text":"<pre><code>async def run_tool(container: Container, tool_input: dict) -&gt; dict:\n    async with container.async_request_scope():\n        # REQUEST-scoped values\n        state = container.get(TOOLRUN)\n        state[\"invocations\"] += 1\n        http = await container.aget(HTTP)\n        return await http.post(\"/run\", json=tool_input)\n</code></pre>"},{"location":"llm/#injection-in-handlers","title":"Injection in Handlers","text":"<pre><code>from pyinj.injection import Inject, inject\n\n@inject(container=container)\nasync def handler(payload: dict, http: Inject[HttpClient]):\n    return await http.post(\"/endpoint\", json=payload)\n</code></pre>"},{"location":"llm/#overrides-per-call-or-test","title":"Overrides (Per-Call or Test)","text":"<pre><code>FAKEHTTP = Token(\"http\", HttpClient)\nwith container.use_overrides({FAKEHTTP: FakeHttpClient()}):\n    # only this concurrent context sees the override\n    ...\n</code></pre>"},{"location":"llm/#accepted-patterns","title":"Accepted Patterns","text":"<ul> <li>Use <code>register_context_async/sync</code> for resources with lifecycles.</li> <li>Use <code>async_request_scope/request_scope</code> to delimit per-call lifetimes.</li> <li>Use <code>@inject</code> for handler entry points; avoid sprinkling <code>get()</code> across code.</li> <li>Prefer tokens per logical dependency; avoid string-based tokens.</li> <li>Use <code>override()</code>/<code>use_overrides()</code> in tests or local contexts.</li> </ul>"},{"location":"llm/#anti-patterns-avoid","title":"Anti-Patterns (Avoid)","text":"<ul> <li>Re-registering tokens at runtime (immutable; raises).</li> <li>Storing global singletons in module-level variables\u2014use SINGLETON scope instead.</li> <li>Long-lived REQUEST/SESSION scopes\u2014close them promptly.</li> <li>Mixing sync-only cleanup for async resources\u2014use async cleanup and <code>aclose()</code>.</li> <li>Hidden side-effects in providers\u2014keep providers pure and fast.</li> </ul>"},{"location":"llm/#breaking-patterns-incorrect","title":"Breaking Patterns (Incorrect)","text":"<ul> <li>Registering async providers via <code>register</code> and resolving with <code>get()</code> \u2014 use <code>aget()</code> or <code>register_context_async</code>.</li> <li>Entering async-only resources with sync cleanup (e.g., using <code>with container:</code> for async singletons) \u2014 this raises an error; use <code>await container.aclose()</code>.</li> <li>Accessing request-scoped values outside of any request/session scope \u2014 value won\u2019t exist.</li> </ul>"},{"location":"llm/#failure-modes-diagnostics","title":"Failure Modes &amp; Diagnostics","text":"<ul> <li>Circular dependencies: descriptive error with resolution chain.</li> <li>Provider setup failure: exception propagates (fail-fast); inspect the original error.</li> <li>Missing registration: <code>ResolutionError</code> with guidance.</li> </ul>"},{"location":"llm/#migration-notes","title":"Migration Notes","text":"<ul> <li>Registrations are now immutable; remove any re-registration logic.</li> <li>Switch resource cleanup to <code>register_context_sync/async</code>.</li> </ul>"},{"location":"llm/#checklist-for-llm-integrations","title":"Checklist for LLM Integrations","text":"<ul> <li>[ ] Define tokens per tool/client/config.</li> <li>[ ] Register context-managed singletons for IO clients.</li> <li>[ ] Wrap each tool/agent invocation in a request scope.</li> <li>[ ] Use <code>@inject</code> for handler entry points.</li> <li>[ ] Add overrides for tests and per-call variations.</li> <li>[ ] Ensure async cleanup is awaited in shutdown paths.</li> </ul>"},{"location":"performance/","title":"Performance","text":"<p>PyInj targets O(1) resolution and predictable overhead:</p> <ul> <li>O(1) type lookups via token tables</li> <li>Cached signatures to avoid repeated reflection</li> <li>Lock-free fast path for singletons</li> <li>Minimal per-binding memory footprint</li> </ul> <pre><code># Pseudo-benchmark\n# 1000 services registered\n# ~0.0001ms resolution, ~500 bytes/service\n</code></pre>"},{"location":"releases/","title":"Release Process","text":"<p>Releases are automated with Release Please:</p> <ol> <li>Merge Conventional Commits into <code>main</code>.</li> <li>Release Please opens a release PR with version bump and changelog.</li> <li>Merge the release PR to tag and publish a GitHub Release.</li> <li>The <code>publish.yml</code> workflow builds and publishes to PyPI.</li> </ol> <p>See also the maintainer notes in README and <code>CLAUDE.md</code>.</p>"},{"location":"testing/","title":"Testing with PyInj","text":"<p>This guide covers comprehensive testing strategies when using PyInj for dependency injection, including mocking, test isolation, and async testing patterns.</p>"},{"location":"testing/#overview","title":"Overview","text":"<p>PyInj makes testing easier by:</p> <ul> <li>Type-safe mocking with protocol-based interfaces</li> <li>Dependency overrides for isolated testing</li> <li>Request/session scoped test isolation  </li> <li>Async testing support with proper cleanup</li> <li>Zero test pollution between test cases</li> </ul>"},{"location":"testing/#basic-testing-pattern","title":"Basic Testing Pattern","text":""},{"location":"testing/#test-structure","title":"Test Structure","text":"<pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom pyinj import Container, Token, Scope\n\nclass TestUserService:\n    def setup_method(self):\n        \"\"\"Setup for each test method.\"\"\"\n        # Fresh container for each test\n        self.container = Container()\n\n        # Define tokens\n        self.db_token = Token[Database](\"database\", scope=Scope.SINGLETON)\n        self.email_token = Token[EmailService](\"email_service\", scope=Scope.SINGLETON)\n        self.logger_token = Token[Logger](\"logger\", scope=Scope.SINGLETON)\n        self.user_service_token = Token[UserService](\"user_service\")\n\n        # Register production implementations\n        self.container.register(self.db_token, PostgreSQLDatabase)\n        self.container.register(self.email_token, SMTPEmailService)\n        self.container.register(self.logger_token, ConsoleLogger)\n        self.container.register(\n            self.user_service_token,\n            lambda: UserService(\n                db=self.container.get(self.db_token),\n                email=self.container.get(self.email_token),\n                logger=self.container.get(self.logger_token)\n            )\n        )\n\n    def teardown_method(self):\n        \"\"\"Cleanup after each test.\"\"\"\n        self.container.clear_overrides()\n</code></pre>"},{"location":"testing/#type-safe-mocking","title":"Type-Safe Mocking","text":"<pre><code>from typing import Protocol\n\nclass Database(Protocol):\n    def create_user(self, email: str, name: str) -&gt; dict[str, str]: ...\n    def get_user(self, user_id: int) -&gt; dict[str, str] | None: ...\n    def update_user(self, user_id: int, data: dict[str, str]) -&gt; dict[str, str]: ...\n\nclass EmailService(Protocol):\n    def send_welcome_email(self, email: str) -&gt; bool: ...\n    def send_notification(self, email: str, subject: str, body: str) -&gt; bool: ...\n\ndef test_create_user_success(self):\n    \"\"\"Test successful user creation with type-safe mocks.\"\"\"\n    # Create type-safe mocks\n    mock_db = Mock(spec=Database)\n    mock_email = Mock(spec=EmailService)\n    mock_logger = Mock(spec=Logger)\n\n    # Configure mock behavior\n    mock_db.create_user.return_value = {\n        \"id\": 1, \n        \"email\": \"alice@example.com\", \n        \"name\": \"Alice\"\n    }\n    mock_email.send_welcome_email.return_value = True\n\n    # Override dependencies for this test\n    self.container.override(self.db_token, mock_db)\n    self.container.override(self.email_token, mock_email)\n    self.container.override(self.logger_token, mock_logger)\n\n    # Get service with mocked dependencies\n    user_service = self.container.get(self.user_service_token)\n\n    # Execute test\n    result = user_service.create_user(\"alice@example.com\", \"Alice\")\n\n    # Verify behavior\n    assert result[\"id\"] == 1\n    assert result[\"name\"] == \"Alice\"\n\n    # Verify interactions\n    mock_db.create_user.assert_called_once_with(\"alice@example.com\", \"Alice\")\n    mock_email.send_welcome_email.assert_called_once_with(\"alice@example.com\")\n    mock_logger.info.assert_called()\n</code></pre>"},{"location":"testing/#advanced-testing-patterns","title":"Advanced Testing Patterns","text":""},{"location":"testing/#base-test-class","title":"Base Test Class","text":"<p>Create a reusable base class for DI-enabled tests:</p> <pre><code>import pytest\nfrom unittest.mock import Mock\nfrom pyinj import Container, Token\n\nclass DITestCase:\n    \"\"\"Base class for dependency injection tests.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Setup fresh container for each test.\"\"\"\n        self.container = Container()\n        self.mocks: dict[str, Mock] = {}\n        self._original_registrations: dict[Token[object], object] = {}\n\n    def mock_service(self, token: Token[T], **mock_kwargs) -&gt; Mock:\n        \"\"\"Create and register a type-safe mock for a token.\"\"\"\n        mock = Mock(spec=token.type_, **mock_kwargs)\n        self.container.override(token, mock)\n        self.mocks[token.name] = mock\n        return mock\n\n    def register_real_service(self, token: Token[T], provider: type[T] | Callable[[], T]) -&gt; None:\n        \"\"\"Register a real service implementation.\"\"\"\n        self.container.register(token, provider)\n        self._original_registrations[token] = provider\n\n    def get_mock(self, token_name: str) -&gt; Mock:\n        \"\"\"Get a previously created mock by token name.\"\"\"\n        return self.mocks[token_name]\n\n    def verify_no_unexpected_calls(self) -&gt; None:\n        \"\"\"Verify no mocks received unexpected calls.\"\"\"\n        for name, mock in self.mocks.items():\n            # Reset mock to clear any expected calls\n            # This is useful for verifying clean state\n            pass\n\n    def teardown_method(self):\n        \"\"\"Clean up after each test.\"\"\"\n        self.container.clear_overrides()\n        self.mocks.clear()\n        self._original_registrations.clear()\n\n# Usage example\nclass TestUserService(DITestCase):\n    def setup_method(self):\n        super().setup_method()\n\n        # Define tokens\n        self.DB_TOKEN = Token[Database](\"database\", scope=Scope.SINGLETON)\n        self.EMAIL_TOKEN = Token[EmailService](\"email_service\", scope=Scope.SINGLETON)\n        self.USER_SERVICE_TOKEN = Token[UserService](\"user_service\")\n\n        # Register real service implementations\n        self.register_real_service(self.DB_TOKEN, PostgreSQLDatabase)\n        self.register_real_service(self.EMAIL_TOKEN, SMTPEmailService)\n        self.register_real_service(\n            self.USER_SERVICE_TOKEN,\n            lambda: UserService(\n                db=self.container.get(self.DB_TOKEN),\n                email=self.container.get(self.EMAIL_TOKEN)\n            )\n        )\n\n    def test_user_creation_flow(self):\n        \"\"\"Test complete user creation with selective mocking.\"\"\"\n        # Mock only what we need to control\n        mock_db = self.mock_service(self.DB_TOKEN)\n        mock_email = self.mock_service(self.EMAIL_TOKEN)\n\n        # Configure expected behavior\n        mock_db.create_user.return_value = {\"id\": 123, \"name\": \"Alice\", \"email\": \"alice@example.com\"}\n        mock_email.send_welcome_email.return_value = True\n\n        # Execute test\n        service = self.container.get(self.USER_SERVICE_TOKEN)\n        result = service.create_user(\"alice@example.com\", \"Alice\")\n\n        # Verify results and interactions\n        assert result[\"id\"] == 123\n        mock_db.create_user.assert_called_once()\n        mock_email.send_welcome_email.assert_called_once()\n</code></pre>"},{"location":"testing/#parametrized-testing","title":"Parametrized Testing","text":"<pre><code>import pytest\n\nclass TestUserValidation(DITestCase):\n    def setup_method(self):\n        super().setup_method()\n        self.VALIDATOR_TOKEN = Token[UserValidator](\"validator\")\n        self.register_real_service(self.VALIDATOR_TOKEN, EmailUserValidator)\n\n    @pytest.mark.parametrize(\"email,expected\", [\n        (\"valid@example.com\", True),\n        (\"invalid-email\", False),\n        (\"\", False),\n        (\"user@domain.co.uk\", True),\n        (\"user+tag@example.com\", True),\n    ])\n    def test_email_validation(self, email: str, expected: bool):\n        \"\"\"Test email validation with multiple cases.\"\"\"\n        validator = self.container.get(self.VALIDATOR_TOKEN)\n        result = validator.is_valid_email(email)\n        assert result == expected\n\n    @pytest.mark.parametrize(\"user_data,should_raise\", [\n        ({\"email\": \"valid@example.com\", \"name\": \"Alice\"}, False),\n        ({\"email\": \"invalid\", \"name\": \"Bob\"}, True),\n        ({\"name\": \"Charlie\"}, True),  # Missing email\n        ({\"email\": \"test@example.com\"}, True),  # Missing name\n    ])\n    def test_user_data_validation(self, user_data: dict[str, str], should_raise: bool):\n        \"\"\"Test user data validation with various inputs.\"\"\"\n        validator = self.container.get(self.VALIDATOR_TOKEN)\n\n        if should_raise:\n            with pytest.raises(ValidationError):\n                validator.validate_user_data(user_data)\n        else:\n            # Should not raise\n            validator.validate_user_data(user_data)\n</code></pre>"},{"location":"testing/#async-testing","title":"Async Testing","text":""},{"location":"testing/#async-service-testing","title":"Async Service Testing","text":"<pre><code>import asyncio\nimport pytest\nfrom unittest.mock import AsyncMock\n\nclass TestAsyncUserService(DITestCase):\n    def setup_method(self):\n        super().setup_method()\n\n        # Define async service tokens\n        self.ASYNC_DB_TOKEN = Token[AsyncDatabase](\"async_db\", scope=Scope.SINGLETON)\n        self.ASYNC_EMAIL_TOKEN = Token[AsyncEmailService](\"async_email\", scope=Scope.SINGLETON)\n        self.ASYNC_USER_SERVICE_TOKEN = Token[AsyncUserService](\"async_user_service\")\n\n        # Register async services\n        self.register_real_service(self.ASYNC_DB_TOKEN, AsyncPostgreSQLDatabase)\n        self.register_real_service(self.ASYNC_EMAIL_TOKEN, AsyncSMTPEmailService)\n        self.register_real_service(\n            self.ASYNC_USER_SERVICE_TOKEN,\n            lambda: AsyncUserService(\n                db=self.container.get(self.ASYNC_DB_TOKEN),\n                email=self.container.get(self.ASYNC_EMAIL_TOKEN)\n            )\n        )\n\n    @pytest.mark.asyncio\n    async def test_async_user_creation(self):\n        \"\"\"Test async user service with async mocks.\"\"\"\n        # Create async mocks\n        mock_async_db = AsyncMock(spec=AsyncDatabase)\n        mock_async_email = AsyncMock(spec=AsyncEmailService)\n\n        # Configure async mock behavior\n        mock_async_db.create_user.return_value = {\n            \"id\": 1, \n            \"name\": \"Alice\", \n            \"email\": \"alice@example.com\"\n        }\n        mock_async_email.send_welcome_email.return_value = True\n\n        # Override with async mocks\n        self.container.override(self.ASYNC_DB_TOKEN, mock_async_db)\n        self.container.override(self.ASYNC_EMAIL_TOKEN, mock_async_email)\n\n        # Test async service\n        service = self.container.get(self.ASYNC_USER_SERVICE_TOKEN)\n        result = await service.create_user(\"alice@example.com\", \"Alice\")\n\n        # Verify async interactions\n        assert result[\"id\"] == 1\n        mock_async_db.create_user.assert_called_once_with(\"alice@example.com\", \"Alice\")\n        mock_async_email.send_welcome_email.assert_called_once_with(\"alice@example.com\")\n\n    @pytest.mark.asyncio\n    async def test_async_error_handling(self):\n        \"\"\"Test error handling in async services.\"\"\"\n        mock_async_db = AsyncMock(spec=AsyncDatabase)\n        mock_async_email = AsyncMock(spec=AsyncEmailService)\n\n        # Configure mock to raise exception\n        mock_async_db.create_user.side_effect = DatabaseConnectionError(\"Connection failed\")\n\n        self.container.override(self.ASYNC_DB_TOKEN, mock_async_db)\n        self.container.override(self.ASYNC_EMAIL_TOKEN, mock_async_email)\n\n        service = self.container.get(self.ASYNC_USER_SERVICE_TOKEN)\n\n        # Verify exception propagation\n        with pytest.raises(DatabaseConnectionError):\n            await service.create_user(\"alice@example.com\", \"Alice\")\n\n        # Verify email was not sent due to database error\n        mock_async_email.send_welcome_email.assert_not_called()\n\n    @pytest.mark.asyncio\n    async def test_concurrent_async_operations(self):\n        \"\"\"Test concurrent async operations with proper isolation.\"\"\"\n        mock_async_db = AsyncMock(spec=AsyncDatabase)\n        self.container.override(self.ASYNC_DB_TOKEN, mock_async_db)\n\n        # Configure mock for concurrent calls\n        mock_async_db.get_user.side_effect = lambda user_id: {\n            \"id\": user_id, \n            \"name\": f\"User{user_id}\"\n        }\n\n        service = self.container.get(self.ASYNC_USER_SERVICE_TOKEN)\n\n        # Execute concurrent operations\n        tasks = [\n            service.get_user(i) \n            for i in range(1, 11)\n        ]\n        results = await asyncio.gather(*tasks)\n\n        # Verify all operations completed successfully\n        assert len(results) == 10\n        for i, result in enumerate(results, 1):\n            assert result[\"id\"] == i\n            assert result[\"name\"] == f\"User{i}\"\n\n        # Verify all calls were made\n        assert mock_async_db.get_user.call_count == 10\n</code></pre>"},{"location":"testing/#resource-cleanup-testing","title":"Resource Cleanup Testing","text":"<pre><code>@pytest.mark.asyncio\nasync def test_async_resource_cleanup(self):\n    \"\"\"Test proper cleanup of async resources.\"\"\"\n    cleanup_called = False\n\n    class MockAsyncResource:\n        async def aclose(self) -&gt; None:\n            nonlocal cleanup_called\n            cleanup_called = True\n\n    # Register resource with cleanup\n    resource_token = Token[MockAsyncResource](\"resource\", scope=Scope.SINGLETON)\n    self.container.register(resource_token, MockAsyncResource)\n\n    # Use resource\n    resource = await self.container.aget(resource_token)\n    assert not cleanup_called\n\n    # Cleanup should be called\n    await self.container.aclose()\n    assert cleanup_called\n</code></pre>"},{"location":"testing/#requestsession-scope-testing","title":"Request/Session Scope Testing","text":""},{"location":"testing/#request-scope-isolation","title":"Request Scope Isolation","text":"<pre><code>def test_request_scope_isolation(self):\n    \"\"\"Test that request-scoped dependencies are isolated between requests.\"\"\"\n    request_service_token = Token[RequestService](\"request_service\", scope=Scope.REQUEST)\n\n    # Mock that tracks instance creation\n    creation_count = 0\n\n    def create_request_service() -&gt; RequestService:\n        nonlocal creation_count\n        creation_count += 1\n        return RequestService(id=creation_count)\n\n    self.container.register(request_service_token, create_request_service)\n\n    # Request 1\n    with self.container.request_scope():\n        service1a = self.container.get(request_service_token)\n        service1b = self.container.get(request_service_token)\n\n        # Same instance within request scope\n        assert service1a is service1b\n        assert service1a.id == 1\n        assert creation_count == 1\n\n    # Request 2\n    with self.container.request_scope():\n        service2 = self.container.get(request_service_token)\n\n        # Different instance in new request scope\n        assert service1a is not service2\n        assert service2.id == 2\n        assert creation_count == 2\n\ndef test_session_scope_persistence(self):\n    \"\"\"Test that session-scoped dependencies persist across requests.\"\"\"\n    session_service_token = Token[SessionService](\"session_service\", scope=Scope.SESSION)\n\n    creation_count = 0\n\n    def create_session_service() -&gt; SessionService:\n        nonlocal creation_count\n        creation_count += 1\n        return SessionService(id=creation_count)\n\n    self.container.register(session_service_token, create_session_service)\n\n    # Session with multiple requests\n    with self.container.session_scope():\n        # Request 1\n        with self.container.request_scope():\n            service1 = self.container.get(session_service_token)\n            assert service1.id == 1\n            assert creation_count == 1\n\n        # Request 2 - same session service\n        with self.container.request_scope():\n            service2 = self.container.get(session_service_token)\n            assert service1 is service2\n            assert service2.id == 1\n            assert creation_count == 1  # No new creation\n</code></pre>"},{"location":"testing/#integration-testing","title":"Integration Testing","text":""},{"location":"testing/#end-to-end-testing","title":"End-to-End Testing","text":"<pre><code>class TestUserRegistrationFlow(DITestCase):\n    \"\"\"End-to-end testing of user registration flow.\"\"\"\n\n    def setup_method(self):\n        super().setup_method()\n\n        # Setup complete service stack\n        self.setup_database_stack()\n        self.setup_email_stack()\n        self.setup_user_services()\n\n    def setup_database_stack(self):\n        \"\"\"Setup database-related services.\"\"\"\n        self.DB_TOKEN = Token[Database](\"database\", scope=Scope.SINGLETON)\n        self.USER_REPO_TOKEN = Token[UserRepository](\"user_repo\", scope=Scope.SINGLETON)\n\n        self.register_real_service(self.DB_TOKEN, InMemoryDatabase)  # Use in-memory for tests\n        self.register_real_service(\n            self.USER_REPO_TOKEN,\n            lambda: UserRepository(db=self.container.get(self.DB_TOKEN))\n        )\n\n    def setup_email_stack(self):\n        \"\"\"Setup email-related services.\"\"\"\n        self.EMAIL_TOKEN = Token[EmailService](\"email_service\", scope=Scope.SINGLETON)\n        self.register_real_service(self.EMAIL_TOKEN, MockEmailService)  # Mock for tests\n\n    def setup_user_services(self):\n        \"\"\"Setup user service layer.\"\"\"\n        self.USER_SERVICE_TOKEN = Token[UserService](\"user_service\", scope=Scope.SINGLETON)\n        self.REGISTRATION_SERVICE_TOKEN = Token[RegistrationService](\"registration_service\")\n\n        self.register_real_service(\n            self.USER_SERVICE_TOKEN,\n            lambda: UserService(\n                user_repo=self.container.get(self.USER_REPO_TOKEN),\n                email_service=self.container.get(self.EMAIL_TOKEN)\n            )\n        )\n\n        self.register_real_service(\n            self.REGISTRATION_SERVICE_TOKEN,\n            lambda: RegistrationService(\n                user_service=self.container.get(self.USER_SERVICE_TOKEN)\n            )\n        )\n\n    def test_complete_user_registration(self):\n        \"\"\"Test complete user registration flow end-to-end.\"\"\"\n        # Get the registration service\n        registration_service = self.container.get(self.REGISTRATION_SERVICE_TOKEN)\n\n        # Execute registration\n        user_data = {\n            \"email\": \"alice@example.com\",\n            \"name\": \"Alice Smith\",\n            \"password\": \"secure_password\"\n        }\n\n        result = registration_service.register_user(user_data)\n\n        # Verify user was created\n        assert \"id\" in result\n        assert result[\"email\"] == \"alice@example.com\"\n        assert result[\"name\"] == \"Alice Smith\"\n\n        # Verify user exists in database\n        db = self.container.get(self.DB_TOKEN)\n        stored_user = db.get_user(result[\"id\"])\n        assert stored_user is not None\n        assert stored_user[\"email\"] == \"alice@example.com\"\n\n        # Verify welcome email was sent\n        email_service = self.container.get(self.EMAIL_TOKEN)\n        assert email_service.last_sent_email[\"to\"] == \"alice@example.com\"\n        assert \"welcome\" in email_service.last_sent_email[\"subject\"].lower()\n\n    def test_duplicate_email_registration(self):\n        \"\"\"Test that duplicate email registration is handled properly.\"\"\"\n        registration_service = self.container.get(self.REGISTRATION_SERVICE_TOKEN)\n\n        user_data = {\n            \"email\": \"duplicate@example.com\",\n            \"name\": \"First User\",\n            \"password\": \"password1\"\n        }\n\n        # First registration should succeed\n        result1 = registration_service.register_user(user_data)\n        assert \"id\" in result1\n\n        # Second registration with same email should fail\n        user_data[\"name\"] = \"Second User\"\n        user_data[\"password\"] = \"password2\"\n\n        with pytest.raises(DuplicateEmailError):\n            registration_service.register_user(user_data)\n</code></pre>"},{"location":"testing/#test-fixtures-and-utilities","title":"Test Fixtures and Utilities","text":""},{"location":"testing/#pytest-fixtures","title":"Pytest Fixtures","text":"<pre><code>import pytest\nfrom pyinj import Container\n\n@pytest.fixture\ndef container() -&gt; Container:\n    \"\"\"Provide a fresh container for each test.\"\"\"\n    return Container()\n\n@pytest.fixture\ndef user_service_stack(container: Container) -&gt; dict[str, Token]:\n    \"\"\"Setup complete user service stack.\"\"\"\n    # Define tokens\n    tokens = {\n        \"db\": Token[Database](\"database\", scope=Scope.SINGLETON),\n        \"email\": Token[EmailService](\"email_service\", scope=Scope.SINGLETON),\n        \"logger\": Token[Logger](\"logger\", scope=Scope.SINGLETON),\n        \"user_service\": Token[UserService](\"user_service\")\n    }\n\n    # Register services\n    container.register(tokens[\"db\"], InMemoryDatabase)\n    container.register(tokens[\"email\"], MockEmailService)\n    container.register(tokens[\"logger\"], TestLogger)\n    container.register(\n        tokens[\"user_service\"],\n        lambda: UserService(\n            db=container.get(tokens[\"db\"]),\n            email=container.get(tokens[\"email\"]),\n            logger=container.get(tokens[\"logger\"])\n        )\n    )\n\n    return tokens\n\n@pytest.fixture\nasync def async_container() -&gt; Container:\n    \"\"\"Provide container with async cleanup.\"\"\"\n    container = Container()\n    yield container\n    await container.aclose()\n\n# Usage in tests\ndef test_user_service_with_fixture(user_service_stack: dict[str, Token], container: Container):\n    \"\"\"Test using fixture-provided service stack.\"\"\"\n    user_service = container.get(user_service_stack[\"user_service\"])\n    result = user_service.create_user(\"test@example.com\", \"Test User\")\n    assert result[\"email\"] == \"test@example.com\"\n\n@pytest.mark.asyncio\nasync def test_async_service_with_fixture(async_container: Container):\n    \"\"\"Test async service with fixture cleanup.\"\"\"\n    # Setup async service\n    async_token = Token[AsyncService](\"async_service\")\n    async_container.register(async_token, AsyncServiceImpl)\n\n    # Use service\n    service = await async_container.aget(async_token)\n    result = await service.process_data(\"test\")\n\n    assert result == \"processed: test\"\n    # Cleanup handled by fixture\n</code></pre>"},{"location":"testing/#best-practices","title":"Best Practices","text":""},{"location":"testing/#1-test-isolation","title":"1. Test Isolation","text":"<pre><code># \u2705 Good - Fresh container per test\nclass TestService:\n    def setup_method(self):\n        self.container = Container()  # Fresh instance\n\n    def teardown_method(self):\n        self.container.clear_overrides()\n\n# \u274c Bad - Shared container between tests\nclass TestService:\n    container = Container()  # Shared - tests can interfere\n</code></pre>"},{"location":"testing/#2-mock-scope","title":"2. Mock Scope","text":"<pre><code># \u2705 Good - Mock only what you need to control\ndef test_user_service(self):\n    mock_db = Mock(spec=Database)\n    self.container.override(DB_TOKEN, mock_db)\n    # Use real email service if not relevant to test\n\n# \u274c Bad - Over-mocking\ndef test_user_service(self):\n    mock_db = Mock(spec=Database)\n    mock_email = Mock(spec=EmailService)\n    mock_logger = Mock(spec=Logger)\n    mock_validator = Mock(spec=Validator)\n    # Too many mocks make tests brittle\n</code></pre>"},{"location":"testing/#3-verification-focus","title":"3. Verification Focus","text":"<pre><code># \u2705 Good - Verify behavior that matters\ndef test_user_creation(self):\n    # ... setup ...\n    user_service.create_user(\"test@example.com\", \"Test\")\n\n    # Verify the important interactions\n    mock_db.create_user.assert_called_once()\n    mock_email.send_welcome_email.assert_called_once()\n\n# \u274c Bad - Over-verification\ndef test_user_creation(self):\n    # ... setup ...\n    user_service.create_user(\"test@example.com\", \"Test\")\n\n    # Too detailed - tests become brittle\n    mock_db.create_user.assert_called_once_with(\"test@example.com\", \"Test\")\n    mock_email.send_welcome_email.assert_called_once_with(\"test@example.com\")\n    mock_logger.info.assert_called_with(\"Creating user: Test\")\n    # ... many more detailed assertions\n</code></pre>"},{"location":"testing/#4-async-testing","title":"4. Async Testing","text":"<pre><code># \u2705 Good - Proper async test setup\n@pytest.mark.asyncio\nasync def test_async_service():\n    mock_async_db = AsyncMock(spec=AsyncDatabase)\n    # Test async behavior properly\n\n# \u274c Bad - Missing async markers\ndef test_async_service():  # Missing @pytest.mark.asyncio\n    # Will fail at runtime\n</code></pre> <p>This comprehensive testing guide ensures your PyInj-based applications are thoroughly tested with type safety and proper isolation.</p>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide covers common issues, error messages, and solutions when using PyInj.</p>"},{"location":"troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"troubleshooting/#1-circular-dependencies","title":"1. Circular Dependencies","text":"<p>Problem: Services depend on each other, creating a circular dependency.</p> <p>Error Message: <pre><code>pyinj.exceptions.CircularDependencyError: Cannot resolve token 'service_a':\n  Resolution chain: service_a -&gt; service_b -&gt; service_a\n  Cause: Circular dependency detected: service_a -&gt; service_b -&gt; service_a\n</code></pre></p> <p>Example: <pre><code>class ServiceA:\n    def __init__(self, service_b: ServiceB):\n        self.service_b = service_b\n\nclass ServiceB:  \n    def __init__(self, service_a: ServiceA):\n        self.service_a = service_a\n\n# This creates a circular dependency\ncontainer.register(SERVICE_A, lambda: ServiceA(container.get(SERVICE_B)))\ncontainer.register(SERVICE_B, lambda: ServiceB(container.get(SERVICE_A)))\n</code></pre></p> <p>Solutions:</p>"},{"location":"troubleshooting/#solution-1-redesign-architecture","title":"Solution 1: Redesign Architecture","text":"<pre><code># Extract common functionality\nclass SharedService:\n    def common_functionality(self) -&gt; str:\n        return \"shared logic\"\n\nclass ServiceA:\n    def __init__(self, shared: SharedService):\n        self.shared = shared\n\nclass ServiceB:\n    def __init__(self, shared: SharedService):\n        self.shared = shared\n\n# No circular dependency\ncontainer.register(SHARED_SERVICE, SharedService, scope=Scope.SINGLETON)\ncontainer.register(SERVICE_A, lambda: ServiceA(container.get(SHARED_SERVICE)))\ncontainer.register(SERVICE_B, lambda: ServiceB(container.get(SHARED_SERVICE)))\n</code></pre>"},{"location":"troubleshooting/#solution-2-lazy-injection","title":"Solution 2: Lazy Injection","text":"<pre><code>from typing import Callable\n\nclass ServiceA:\n    def __init__(self, get_service_b: Callable[[], ServiceB]):\n        self._get_service_b = get_service_b\n        self._service_b: ServiceB | None = None\n\n    @property\n    def service_b(self) -&gt; ServiceB:\n        if self._service_b is None:\n            self._service_b = self._get_service_b()\n        return self._service_b\n\n# Use lazy injection\ncontainer.register(SERVICE_A, lambda: ServiceA(lambda: container.get(SERVICE_B)))\ncontainer.register(SERVICE_B, ServiceBImplementation)\n</code></pre>"},{"location":"troubleshooting/#2-type-checker-issues","title":"2. Type Checker Issues","text":"<p>Problem: Static type checkers report errors with PyInj code.</p>"},{"location":"troubleshooting/#issue-cannot-assign-to-tokenx","title":"Issue: \"Cannot assign to Token[X]\"","text":"<p>Error: <pre><code>error: Argument 2 to \"register\" has incompatible type \"int\"; expected \"Callable[[], str]\"\n</code></pre></p> <p>Cause: <pre><code>TOKEN = Token[str](\"my_token\")\ncontainer.register(TOKEN, 123)  # Type error: int not assignable to str\n</code></pre></p> <p>Solution: <pre><code># Fix the type or provider\nTOKEN = Token[int](\"my_token\")\ncontainer.register(TOKEN, 123)  # OK\n\n# Or fix the provider\nTOKEN = Token[str](\"my_token\")\ncontainer.register(TOKEN, lambda: \"123\")  # OK\n</code></pre></p>"},{"location":"troubleshooting/#issue-protocol-not-satisfied","title":"Issue: \"Protocol not satisfied\"","text":"<p>Error: <pre><code>error: Argument 2 to \"register\" has incompatible type \"IncompleteService\"; \nexpected \"Callable[[], Logger]\"\n</code></pre></p> <p>Cause: <pre><code>from typing import Protocol\n\nclass Logger(Protocol):\n    def info(self, message: str) -&gt; None: ...\n    def error(self, message: str) -&gt; None: ...\n\nclass IncompleteLogger:\n    def info(self, message: str) -&gt; None:\n        print(message)\n    # Missing error method!\n\nLOGGER = Token[Logger](\"logger\")\ncontainer.register(LOGGER, IncompleteLogger)  # Type error\n</code></pre></p> <p>Solution: <pre><code>class CompleteLogger:\n    def info(self, message: str) -&gt; None:\n        print(f\"INFO: {message}\")\n\n    def error(self, message: str) -&gt; None:\n        print(f\"ERROR: {message}\")\n\ncontainer.register(LOGGER, CompleteLogger)  # OK\n</code></pre></p>"},{"location":"troubleshooting/#3-asyncsync-mixing-issues","title":"3. Async/Sync Mixing Issues","text":"<p>Problem: Mixing async and sync contexts incorrectly.</p>"},{"location":"troubleshooting/#issue-async-provider-in-sync-context","title":"Issue: Async Provider in Sync Context","text":"<p>Error: <pre><code>RuntimeError: Cannot resolve async provider in sync context\n</code></pre></p> <p>Cause: <pre><code>async def create_async_service() -&gt; AsyncService:\n    service = AsyncService()\n    await service.initialize()\n    return service\n\ncontainer.register(ASYNC_SERVICE, create_async_service)\n\n# This fails - async provider in sync context\nservice = container.get(ASYNC_SERVICE)  # Error!\n</code></pre></p> <p>Solution: <pre><code># Use async resolution\nservice = await container.aget(ASYNC_SERVICE)  # OK\n</code></pre></p>"},{"location":"troubleshooting/#issue-asynccleanuprequirederror","title":"Issue: AsyncCleanupRequiredError","text":"<p>Error: <pre><code>pyinj.exceptions.AsyncCleanupRequiredError: Resource AsyncDatabaseClient requires \nasynchronous cleanup. Use an async request/session scope.\n</code></pre></p> <p>Cause: <pre><code># Register async-only resource\ncontainer.register_context_async(ASYNC_DB, async_database_context)\n\n# Try to use sync cleanup\nwith container:  # Error! Async resource needs async cleanup\n    db = await container.aget(ASYNC_DB)\n</code></pre></p> <p>Solution: <pre><code># Use async cleanup\nasync def main():\n    db = await container.aget(ASYNC_DB)\n    # Use database\n    await container.aclose()  # Proper async cleanup\n\nasyncio.run(main())\n</code></pre></p>"},{"location":"troubleshooting/#4-resolution-errors","title":"4. Resolution Errors","text":"<p>Problem: PyInj cannot resolve a requested dependency.</p>"},{"location":"troubleshooting/#issue-missing-provider","title":"Issue: Missing Provider","text":"<p>Error: <pre><code>pyinj.exceptions.ResolutionError: Cannot resolve token 'database':\n  Resolution chain: user_service -&gt; database\n  Cause: No provider registered for token 'database'\n</code></pre></p> <p>Cause: <pre><code>USER_SERVICE = Token[UserService](\"user_service\")\nDATABASE = Token[Database](\"database\")\n\n# Register user service but forget database\ncontainer.register(USER_SERVICE, lambda: UserService(container.get(DATABASE)))\n# DATABASE never registered!\n\nuser_service = container.get(USER_SERVICE)  # Error!\n</code></pre></p> <p>Solution: <pre><code># Register all required dependencies\ncontainer.register(DATABASE, PostgreSQLDatabase)\ncontainer.register(USER_SERVICE, lambda: UserService(container.get(DATABASE)))\n</code></pre></p>"},{"location":"troubleshooting/#issue-type-not-found-for-plain-annotation","title":"Issue: Type Not Found for Plain Annotation","text":"<p>Error: <pre><code>pyinj.exceptions.ResolutionError: Cannot resolve token for type 'Database':\n  Resolution chain: root\n  Cause: No provider registered for type 'Database'\n</code></pre></p> <p>Cause: <pre><code>@inject\ndef service(db: Database) -&gt; None:  # Plain type annotation\n    pass\n\n# But no registration for Database type\nservice()  # Error!\n</code></pre></p> <p>Solution:</p> <p>Option 1: Register by Type <pre><code>container.register(Database, PostgreSQLDatabase)\n\n@inject(container=container)\ndef service(db: Database) -&gt; None:\n    pass\n</code></pre></p> <p>Option 2: Use Explicit Tokens <pre><code>DATABASE = Token[Database](\"database\")\ncontainer.register(DATABASE, PostgreSQLDatabase)\n\n@inject\ndef service(db: Annotated[Database, Inject(lambda: container.get(DATABASE))]) -&gt; None:\n    pass\n</code></pre></p>"},{"location":"troubleshooting/#5-scope-related-issues","title":"5. Scope-Related Issues","text":""},{"location":"troubleshooting/#issue-request-scope-outside-context","title":"Issue: Request Scope Outside Context","text":"<p>Error: <pre><code>RuntimeError: No active request scope for registering cleanup\n</code></pre></p> <p>Cause: <pre><code># Try to register request-scoped cleanup outside request scope\ncontainer.register_context_sync(REQUEST_TOKEN, some_context)\ncontainer._register_request_cleanup_sync(cleanup_fn)  # Error!\n</code></pre></p> <p>Solution: <pre><code># Use request scope properly\nwith container.request_scope():\n    # Request-scoped operations here\n    service = container.get(REQUEST_SCOPED_TOKEN)\n</code></pre></p>"},{"location":"troubleshooting/#issue-scope-mismatch","title":"Issue: Scope Mismatch","text":"<p>Problem: Dependencies have incompatible scopes.</p> <pre><code># Singleton depends on request-scoped service\nSINGLETON_SERVICE = Token[Service](\"singleton\", scope=Scope.SINGLETON)\nREQUEST_SERVICE = Token[RequestService](\"request\", scope=Scope.REQUEST)\n\ncontainer.register(REQUEST_SERVICE, RequestServiceImpl)\ncontainer.register(\n    SINGLETON_SERVICE,\n    lambda: Service(container.get(REQUEST_SERVICE))  # Problem!\n)\n</code></pre> <p>Issue: Singleton will get the first request-scoped instance and keep it forever.</p> <p>Solution: <pre><code># Redesign: singleton should not depend on request-scoped\n# Or make both request-scoped\nSINGLETON_SERVICE = Token[Service](\"service\", scope=Scope.REQUEST)\n</code></pre></p>"},{"location":"troubleshooting/#6-import-and-module-issues","title":"6. Import and Module Issues","text":""},{"location":"troubleshooting/#issue-circular-imports","title":"Issue: Circular Imports","text":"<p>Error: <pre><code>ImportError: cannot import name 'UserService' from partially initialized module\n</code></pre></p> <p>Cause: <pre><code># services/user.py\nfrom services.email import EmailService\n\nclass UserService:\n    def __init__(self, email: EmailService): ...\n\n# services/email.py\nfrom services.user import UserService  # Circular import!\n\nclass EmailService:\n    def __init__(self, user: UserService): ...\n</code></pre></p> <p>Solutions:</p> <p>Option 1: Protocol Imports <pre><code># protocols.py\nfrom typing import Protocol\n\nclass UserServiceProtocol(Protocol):\n    def create_user(self, data: dict) -&gt; dict: ...\n\nclass EmailServiceProtocol(Protocol):\n    def send_email(self, to: str, subject: str) -&gt; bool: ...\n\n# services/user.py\nfrom protocols import EmailServiceProtocol\n\nclass UserService:\n    def __init__(self, email: EmailServiceProtocol): ...\n\n# services/email.py  \nfrom protocols import UserServiceProtocol\n\nclass EmailService:\n    def __init__(self, user: UserServiceProtocol): ...\n</code></pre></p> <p>Option 2: Type Imports Only <pre><code># services/user.py\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from services.email import EmailService\n\nclass UserService:\n    def __init__(self, email: \"EmailService\"): ...\n</code></pre></p>"},{"location":"troubleshooting/#7-performance-issues","title":"7. Performance Issues","text":""},{"location":"troubleshooting/#issue-slow-container-resolution","title":"Issue: Slow Container Resolution","text":"<p>Problem: Container resolution is slower than expected.</p> <p>Debugging: <pre><code>import time\nfrom pyinj import Container, Token\n\ncontainer = Container()\n\n# Time resolution\nstart = time.time()\nfor _ in range(1000):\n    service = container.get(SERVICE_TOKEN)\nend = time.time()\n\nprint(f\"Average resolution time: {(end - start) / 1000 * 1000:.2f}ms\")\n</code></pre></p> <p>Common Causes:</p> <ol> <li>Heavy provider functions <pre><code># Slow provider\ndef create_heavy_service() -&gt; Service:\n    time.sleep(0.1)  # Simulated heavy work\n    return Service()\n\ncontainer.register(SERVICE_TOKEN, create_heavy_service, scope=Scope.TRANSIENT)\n</code></pre></li> </ol> <p>Solution: Use appropriate scope <pre><code># Cache expensive creation with singleton scope\ncontainer.register(SERVICE_TOKEN, create_heavy_service, scope=Scope.SINGLETON)\n</code></pre></p> <ol> <li>Complex dependency chains <pre><code># Many nested dependencies\ncontainer.register(A, lambda: A(container.get(B)))\ncontainer.register(B, lambda: B(container.get(C)))\ncontainer.register(C, lambda: C(container.get(D)))\n# ... many more levels\n</code></pre></li> </ol> <p>Solution: Flatten dependency hierarchy or use caching.</p>"},{"location":"troubleshooting/#8-testing-issues","title":"8. Testing Issues","text":""},{"location":"troubleshooting/#issue-test-pollution","title":"Issue: Test Pollution","text":"<p>Problem: Tests affect each other due to shared container state.</p> <pre><code>class TestService:\n    container = Container()  # Shared between tests - BAD!\n\n    def test_user_creation(self):\n        self.container.override(DB_TOKEN, mock_db)\n        # Test logic\n\n    def test_user_deletion(self):\n        # This test affected by previous override!\n        service = self.container.get(USER_SERVICE_TOKEN)\n</code></pre> <p>Solution: <pre><code>class TestService:\n    def setup_method(self):\n        self.container = Container()  # Fresh container per test\n\n    def teardown_method(self):\n        self.container.clear_overrides()\n</code></pre></p>"},{"location":"troubleshooting/#issue-mock-assertion-failures","title":"Issue: Mock Assertion Failures","text":"<p>Problem: Mock assertions fail unexpectedly.</p> <pre><code>def test_user_service(self):\n    mock_db = Mock(spec=Database)\n    container.override(DB_TOKEN, mock_db)\n\n    service = container.get(USER_SERVICE_TOKEN)\n    service.create_user(\"test@example.com\", \"Test\")\n\n    # This might fail if the service makes multiple calls\n    mock_db.create_user.assert_called_once()\n</code></pre> <p>Debug with: <pre><code># See all calls made to mock\nprint(mock_db.method_calls)\nprint(mock_db.create_user.call_count)\nprint(mock_db.create_user.call_args_list)\n</code></pre></p>"},{"location":"troubleshooting/#debugging-techniques","title":"Debugging Techniques","text":""},{"location":"troubleshooting/#1-enable-debug-logging","title":"1. Enable Debug Logging","text":"<pre><code>import logging\n\n# Enable PyInj debug logging\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(\"pyinj\")\n\ncontainer = Container()\n# Resolution steps will be logged\n</code></pre>"},{"location":"troubleshooting/#2-inspect-container-state","title":"2. Inspect Container State","text":"<pre><code># Check registered providers\nprint(\"Registered tokens:\", list(container._providers.keys()))\n\n# Check singleton cache\nprint(\"Singletons:\", list(container._singletons.keys()))\n\n# Check overrides\nprint(\"Overrides:\", list(container._overrides.keys()) if hasattr(container, '_overrides') else [])\n</code></pre>"},{"location":"troubleshooting/#3-resolution-chain-analysis","title":"3. Resolution Chain Analysis","text":"<pre><code>from pyinj.exceptions import ResolutionError\n\ntry:\n    service = container.get(PROBLEMATIC_TOKEN)\nexcept ResolutionError as e:\n    print(f\"Failed token: {e.token.name}\")\n    print(f\"Resolution chain: {[t.name for t in e.chain]}\")\n    print(f\"Root cause: {e.cause}\")\n</code></pre>"},{"location":"troubleshooting/#4-provider-function-inspection","title":"4. Provider Function Inspection","text":"<pre><code>import inspect\n\n# Check provider function signature\nprovider = container._providers[TOKEN]\nif callable(provider):\n    sig = inspect.signature(provider)\n    print(f\"Provider signature: {sig}\")\n    print(f\"Provider source: {inspect.getsource(provider)}\")\n</code></pre>"},{"location":"troubleshooting/#5-type-checking-verification","title":"5. Type Checking Verification","text":"<pre><code># Verify protocol compliance at runtime\nfrom typing import runtime_checkable\n\n@runtime_checkable\nclass Logger(Protocol):\n    def info(self, message: str) -&gt; None: ...\n\nlogger_instance = container.get(LOGGER_TOKEN)\nassert isinstance(logger_instance, Logger), f\"Logger instance {logger_instance} does not satisfy Logger protocol\"\n</code></pre>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"troubleshooting/#1-error-context","title":"1. Error Context","text":"<p>When reporting issues, include:</p> <ul> <li>Complete error message and stack trace</li> <li>Minimal reproduction code</li> <li>Python and PyInj versions</li> <li>Type checker (mypy/basedpyright) version if relevant</li> </ul>"},{"location":"troubleshooting/#2-code-review-checklist","title":"2. Code Review Checklist","text":"<p>Before asking for help, verify:</p> <ul> <li>[ ] All dependencies are registered</li> <li>[ ] Token types match provider return types  </li> <li>[ ] Circular dependencies are avoided</li> <li>[ ] Appropriate scopes are used</li> <li>[ ] Async/sync contexts are correct</li> <li>[ ] Test containers are isolated</li> </ul>"},{"location":"troubleshooting/#3-common-solutions-summary","title":"3. Common Solutions Summary","text":"Problem Solution Circular dependencies Redesign architecture or use lazy injection Type errors Match token types with providers Async/sync mixing Use <code>aget()</code> for async, <code>get()</code> for sync Missing providers Register all required dependencies Test pollution Use fresh containers per test Performance issues Use appropriate scopes (singleton for expensive) Import errors Use protocols or TYPE_CHECKING imports <p>This should help you diagnose and fix most common PyInj issues. For complex problems, consider breaking down your dependency graph and testing components in isolation.</p>"},{"location":"type-safety/","title":"Type Safety &amp; Static Analysis","text":"<p>PyInj provides comprehensive static type checking support, ensuring your dependency injection code is type-safe at compile time.</p>"},{"location":"type-safety/#pep-561-compliance","title":"PEP 561 Compliance","text":"<p>PyInj is fully compliant with PEP 561 and includes a <code>py.typed</code> marker file. This means:</p> <ul> <li>Full type information is available to all type checkers</li> <li>Zero configuration required for type checking</li> <li>Works with all major type checkers: mypy, basedpyright, pyright</li> </ul> <pre><code># All of these work out of the box\nmypy your_code.py\nbasedpyright your_code.py  \npyright your_code.py\n</code></pre>"},{"location":"type-safety/#supported-type-checkers","title":"Supported Type Checkers","text":""},{"location":"type-safety/#basedpyright-recommended","title":"basedpyright (Recommended)","text":"<p>PyInj is developed and tested with basedpyright in strict mode:</p> <pre><code># Install basedpyright\nuvx basedpyright --help\n\n# Check your PyInj code\nuvx basedpyright src/ --strict\n</code></pre>"},{"location":"type-safety/#mypy","title":"mypy","text":"<p>Full mypy compatibility with strict settings:</p> <pre><code># pyproject.toml\n[tool.mypy]\nstrict = true\nwarn_return_any = true\nwarn_unused_configs = true\ndisallow_untyped_defs = true\n</code></pre>"},{"location":"type-safety/#pyrightpylance","title":"pyright/pylance","text":"<p>Works with VS Code and other editors supporting pyright:</p> <pre><code>// pyrightconfig.json\n{\n  \"typeCheckingMode\": \"strict\",\n  \"reportMissingImports\": true,\n  \"reportMissingTypeStubs\": true\n}\n</code></pre>"},{"location":"type-safety/#type-safe-registration","title":"Type-Safe Registration","text":"<p>PyInj enforces type compatibility between tokens and providers:</p> <pre><code>from typing import Protocol\nfrom pyinj import Container, Token, Scope\n\nclass Logger(Protocol):\n    def info(self, message: str) -&gt; None: ...\n    def error(self, message: str) -&gt; None: ...\n\nclass ConsoleLogger:\n    def info(self, message: str) -&gt; None:\n        print(f\"INFO: {message}\")\n\n    def error(self, message: str) -&gt; None:\n        print(f\"ERROR: {message}\")\n\nclass FileLogger:\n    def __init__(self, filename: str):\n        self.filename = filename\n\n    def info(self, message: str) -&gt; None:\n        with open(self.filename, 'a') as f:\n            f.write(f\"INFO: {message}\\n\")\n\n    def error(self, message: str) -&gt; None:\n        with open(self.filename, 'a') as f:\n            f.write(f\"ERROR: {message}\\n\")\n\ncontainer = Container()\nLOGGER = Token[Logger](\"logger\", scope=Scope.SINGLETON)\n\n# \u2705 Type-safe registrations - type checker will verify compatibility\ncontainer.register(LOGGER, ConsoleLogger)  # OK\ncontainer.register(LOGGER, lambda: FileLogger(\"app.log\"))  # OK\n\n# \u274c These would fail type checking\n# container.register(LOGGER, str)  # Type error!\n# container.register(LOGGER, lambda: \"not a logger\")  # Type error!\n</code></pre>"},{"location":"type-safety/#protocol-based-type-safety","title":"Protocol-Based Type Safety","text":"<p>PyInj works seamlessly with Python's Protocol system for structural typing:</p>"},{"location":"type-safety/#runtime-protocol-validation","title":"Runtime Protocol Validation","text":"<pre><code>from typing import Protocol, runtime_checkable\n\n@runtime_checkable\nclass DatabaseProtocol(Protocol):\n    def connect(self) -&gt; None: ...\n    def query(self, sql: str) -&gt; list[dict[str, str]]: ...\n    def close(self) -&gt; None: ...\n\nclass PostgreSQLDatabase:\n    def connect(self) -&gt; None:\n        print(\"Connecting to PostgreSQL\")\n\n    def query(self, sql: str) -&gt; list[dict[str, str]]:\n        return [{\"result\": \"data\"}]\n\n    def close(self) -&gt; None:\n        print(\"Closing PostgreSQL connection\")\n\nclass InvalidDatabase:\n    # Missing required methods!\n    def some_method(self) -&gt; None:\n        pass\n\n# Runtime validation with @runtime_checkable\nDB_TOKEN = Token[DatabaseProtocol](\"database\")\n\ncontainer.register(DB_TOKEN, PostgreSQLDatabase)  # \u2705 Valid\n\n# This would pass static type checking but fail at runtime\n# container.register(DB_TOKEN, InvalidDatabase)  # \u274c Runtime error\n\n# Verify at registration time\ndb_instance = PostgreSQLDatabase()\nassert isinstance(db_instance, DatabaseProtocol)  # \u2705 True\n</code></pre>"},{"location":"type-safety/#generic-protocol-support","title":"Generic Protocol Support","text":"<pre><code>from typing import Protocol, TypeVar, Generic\n\nT = TypeVar('T')\nK = TypeVar('K')\nV = TypeVar('V')\n\nclass Repository(Protocol, Generic[T]):\n    def save(self, entity: T) -&gt; None: ...\n    def find_by_id(self, id: int) -&gt; T | None: ...\n    def find_all(self) -&gt; list[T]: ...\n\nclass Cache(Protocol, Generic[K, V]):\n    def get(self, key: K) -&gt; V | None: ...\n    def set(self, key: K, value: V) -&gt; None: ...\n\n# Type-safe generic implementations\nclass User:\n    def __init__(self, id: int, name: str):\n        self.id = id\n        self.name = name\n\nclass UserRepository:\n    def save(self, user: User) -&gt; None:\n        print(f\"Saving user: {user.name}\")\n\n    def find_by_id(self, id: int) -&gt; User | None:\n        return User(id, f\"User{id}\")\n\n    def find_all(self) -&gt; list[User]:\n        return [User(1, \"Alice\"), User(2, \"Bob\")]\n\nclass MemoryCache:\n    def __init__(self) -&gt; None:\n        self._data: dict[str, str] = {}\n\n    def get(self, key: str) -&gt; str | None:\n        return self._data.get(key)\n\n    def set(self, key: str, value: str) -&gt; None:\n        self._data[key] = value\n\n# Type-safe generic token creation\nUSER_REPO = Token[Repository[User]](\"user_repo\", scope=Scope.SINGLETON)\nSTRING_CACHE = Token[Cache[str, str]](\"string_cache\", scope=Scope.SINGLETON)\n\ncontainer.register(USER_REPO, UserRepository)\ncontainer.register(STRING_CACHE, MemoryCache)\n</code></pre>"},{"location":"type-safety/#type-safe-injection-patterns","title":"Type-Safe Injection Patterns","text":""},{"location":"type-safety/#recommended-pattern-plain-type-annotations","title":"Recommended Pattern: Plain Type Annotations","text":"<p>The cleanest and most type-safe approach:</p> <pre><code>from pyinj import inject\n\n@inject\ndef user_service(\n    repo: Repository[User],\n    cache: Cache[str, str],\n    logger: Logger\n) -&gt; None:\n    \"\"\"All parameters are automatically type-checked and injected.\"\"\"\n    users = repo.find_all()\n    logger.info(f\"Found {len(users)} users\")\n\n    for user in users:\n        cache.set(f\"user:{user.id}\", user.name)\n        logger.info(f\"Cached user: {user.name}\")\n\n# Type checker verifies all dependencies can be resolved\nuser_service()\n</code></pre>"},{"location":"type-safety/#advanced-pattern-explicit-inject-markers","title":"Advanced Pattern: Explicit Inject Markers","text":"<p>Use when you need custom providers or explicit control:</p> <pre><code>from typing import Annotated\nfrom pyinj import Inject\n\n@inject  \ndef advanced_service(\n    # Regular injection - recommended\n    logger: Logger,\n\n    # Custom provider - useful for testing/configuration\n    config: Annotated[Config, Inject(lambda: Config.from_file(\"config.yml\"))],\n\n    # Regular parameters  \n    user_id: int\n) -&gt; None:\n    logger.info(f\"Processing user {user_id}\")\n    logger.info(f\"Using config: {config.database_url}\")\n\n# Mixed regular and injected parameters\nadvanced_service(user_id=123)\n</code></pre>"},{"location":"type-safety/#static-analysis-best-practices","title":"Static Analysis Best Practices","text":""},{"location":"type-safety/#1-always-use-type-annotations","title":"1. Always Use Type Annotations","text":"<pre><code># \u2705 Good - explicit types\n@inject\ndef process_data(logger: Logger, db: Database) -&gt; list[str]:\n    return db.query(\"SELECT name FROM users\")\n\n# \u274c Bad - no type information  \n@inject\ndef process_data(logger, db):  # Type checker can't help\n    return db.query(\"SELECT name FROM users\")\n</code></pre>"},{"location":"type-safety/#2-use-protocols-for-interfaces","title":"2. Use Protocols for Interfaces","text":"<pre><code># \u2705 Good - protocol defines interface\nclass EmailService(Protocol):\n    def send_email(self, to: str, subject: str, body: str) -&gt; bool: ...\n\n# \u274c Less ideal - concrete class coupling\nclass SMTPEmailService:\n    def send_email(self, to: str, subject: str, body: str) -&gt; bool: ...\n    # Other SMTP-specific methods...\n</code></pre>"},{"location":"type-safety/#3-leverage-union-types-for-optional-dependencies","title":"3. Leverage Union Types for Optional Dependencies","text":"<pre><code>from typing import Union\n\n# For optional dependencies, use container overrides instead of Union types\n@inject\ndef service_with_optional_logger(\n    db: Database,\n    logger: Logger  # Required - override in tests if needed\n) -&gt; None:\n    logger.info(\"Service starting\")\n\n# In tests, override the logger token\ncontainer.override(LOGGER, Mock(spec=Logger))\n</code></pre>"},{"location":"type-safety/#type-checking-configuration","title":"Type Checking Configuration","text":""},{"location":"type-safety/#strict-type-checking-setup","title":"Strict Type Checking Setup","text":"<pre><code># pyproject.toml\n[tool.basedpyright]\nstrict = [\"src/\"]\ntypeCheckingMode = \"strict\"\nreportMissingImports = true\nreportMissingTypeStubs = true\nreportUntypedFunctionDecorator = true\nreportUnknownParameterType = true\n\n[tool.mypy]\nfiles = [\"src/\", \"tests/\"]\nstrict = true\nwarn_return_any = true\nwarn_unused_configs = true\ndisallow_any_generics = true\ndisallow_untyped_defs = true\nno_implicit_optional = true\n</code></pre>"},{"location":"type-safety/#cicd-integration","title":"CI/CD Integration","text":"<pre><code># .github/workflows/ci.yml\n- name: Type checking\n  run: |\n    uvx basedpyright src/ --strict\n    # or\n    uvx mypy src/ --strict\n</code></pre>"},{"location":"type-safety/#common-type-safety-patterns","title":"Common Type Safety Patterns","text":""},{"location":"type-safety/#1-factory-functions-with-proper-types","title":"1. Factory Functions with Proper Types","text":"<pre><code>from typing import Callable\n\ndef create_database_factory(config: Config) -&gt; Callable[[], Database]:\n    def factory() -&gt; Database:\n        if config.db_type == \"postgresql\":\n            return PostgreSQLDatabase(config.db_url)\n        elif config.db_type == \"sqlite\":\n            return SQLiteDatabase(config.db_path)\n        else:\n            raise ValueError(f\"Unknown database type: {config.db_type}\")\n    return factory\n\n# Type-safe factory registration\ncontainer.register(DB_TOKEN, create_database_factory(config))\n</code></pre>"},{"location":"type-safety/#2-async-type-safety","title":"2. Async Type Safety","text":"<pre><code>from typing import Awaitable\n\nclass AsyncService(Protocol):\n    async def process(self, data: str) -&gt; str: ...\n\nclass AsyncServiceImpl:\n    async def process(self, data: str) -&gt; str:\n        await asyncio.sleep(0.1)\n        return f\"processed: {data}\"\n\n# Type-safe async provider\nasync def create_async_service() -&gt; AsyncService:\n    service = AsyncServiceImpl()\n    # Any async setup here\n    return service\n\nASYNC_SERVICE = Token[AsyncService](\"async_service\")\ncontainer.register(ASYNC_SERVICE, create_async_service)\n\n@inject\nasync def async_handler(service: AsyncService) -&gt; str:\n    return await service.process(\"test data\")\n</code></pre>"},{"location":"type-safety/#3-context-manager-type-safety","title":"3. Context Manager Type Safety","text":"<pre><code>from typing import ContextManager\nfrom contextlib import contextmanager\n\n@contextmanager\ndef database_transaction() -&gt; ContextManager[Database]:\n    db = PostgreSQLDatabase()\n    db.begin_transaction()\n    try:\n        yield db\n    finally:\n        db.rollback()  # Always rollback for safety\n\n# Type-safe context manager registration\ncontainer.register_context_sync(\n    Token[Database](\"transactional_db\"),\n    database_transaction\n)\n</code></pre>"},{"location":"type-safety/#troubleshooting-type-issues","title":"Troubleshooting Type Issues","text":""},{"location":"type-safety/#common-type-errors-and-solutions","title":"Common Type Errors and Solutions","text":""},{"location":"type-safety/#1-cannot-assign-to-tokenx","title":"1. \"Cannot assign to Token[X]\"","text":"<pre><code># \u274c Problem\nTOKEN = Token[str](\"my_token\")\ncontainer.register(TOKEN, 123)  # Type error: int not assignable to str\n\n# \u2705 Solution - fix the type or provider\nTOKEN = Token[int](\"my_token\")\ncontainer.register(TOKEN, 123)  # OK\n\n# Or fix the provider\nTOKEN = Token[str](\"my_token\")  \ncontainer.register(TOKEN, lambda: \"123\")  # OK\n</code></pre>"},{"location":"type-safety/#2-protocol-not-satisfied","title":"2. \"Protocol not satisfied\"","text":"<pre><code># \u274c Problem\nclass IncompleteService:\n    def some_method(self) -&gt; None: ...\n    # Missing required protocol methods!\n\ncontainer.register(SERVICE_TOKEN, IncompleteService)  # Type error\n\n# \u2705 Solution - implement all protocol methods\nclass CompleteService:\n    def some_method(self) -&gt; None: ...\n    def required_method(self) -&gt; str: ...  # Add missing methods\n</code></pre>"},{"location":"type-safety/#3-cannot-resolve-generic-types","title":"3. \"Cannot resolve generic types\"","text":"<pre><code># \u274c Problem - type checker can't infer generic parameters\ndef create_generic_service():  # No return type annotation\n    return GenericService()\n\n# \u2705 Solution - explicit type annotation\ndef create_generic_service() -&gt; GenericService[User]:\n    return GenericService[User]()\n</code></pre>"},{"location":"type-safety/#debugging-type-issues","title":"Debugging Type Issues","text":"<p>Enable verbose type checking:</p> <pre><code># basedpyright with verbose output\nuvx basedpyright src/ --verbose\n\n# mypy with detailed error information\nuvx mypy src/ --show-error-codes --show-traceback\n</code></pre>"},{"location":"type-safety/#ide-integration","title":"IDE Integration","text":""},{"location":"type-safety/#vs-code-with-pylance","title":"VS Code with Pylance","text":"<pre><code>// .vscode/settings.json\n{\n    \"python.analysis.typeCheckingMode\": \"strict\",\n    \"python.analysis.autoImportCompletions\": true,\n    \"python.analysis.completeFunctionParens\": true,\n    \"python.analysis.inlayHints.functionReturnTypes\": true,\n    \"python.analysis.inlayHints.variableTypes\": true\n}\n</code></pre>"},{"location":"type-safety/#pycharm","title":"PyCharm","text":"<p>Enable strict type checking in Settings \u2192 Editor \u2192 Inspections \u2192 Python: - Enable \"Type checker\" inspections - Enable \"Unresolved references\" warnings - Configure to use mypy or pyright as external tool</p>"},{"location":"type-safety/#performance-of-type-checking","title":"Performance of Type Checking","text":"<p>PyInj's type checking has minimal runtime impact:</p> <ul> <li>Compile-time only: Type checking happens during static analysis, not at runtime</li> <li>O(1) token lookups: Pre-computed hash values for tokens</li> <li>Cached analysis: Function signature parsing is cached by <code>@inject</code></li> <li>Zero overhead: No runtime type validation unless explicitly requested with <code>@runtime_checkable</code></li> </ul> <p>This ensures that your production code runs at full speed while maintaining complete type safety during development.</p>"},{"location":"usage/","title":"Usage Guide","text":"<p>This guide covers practical usage patterns, framework integration, and real-world examples of PyInj in production applications.</p>"},{"location":"usage/#framework-integration","title":"Framework Integration","text":""},{"location":"usage/#fastapi-integration","title":"FastAPI Integration","text":"<p>PyInj integrates seamlessly with FastAPI through multiple approaches:</p>"},{"location":"usage/#option-1-fastapi-dependencies-traditional","title":"Option 1: FastAPI Dependencies (Traditional)","text":"<pre><code>from typing import Annotated\nfrom fastapi import FastAPI, Depends\nfrom pyinj import Container, Token, Scope\n\napp = FastAPI()\ncontainer = Container()\n\n# Define services\nclass UserService:\n    def __init__(self, db: Database, logger: Logger):\n        self.db = db\n        self.logger = logger\n\n    def get_user(self, user_id: int) -&gt; dict[str, str]:\n        self.logger.info(f\"Fetching user {user_id}\")\n        return self.db.query(f\"SELECT * FROM users WHERE id = {user_id}\")[0]\n\n    def create_user(self, user_data: dict[str, str]) -&gt; dict[str, str]:\n        self.logger.info(f\"Creating user: {user_data['name']}\")\n        # Create user logic here\n        return {\"id\": \"123\", \"name\": user_data[\"name\"]}\n\n# Register services\nUSER_SERVICE = Token[UserService](\"user_service\", scope=Scope.SINGLETON)\ncontainer.register(USER_SERVICE, lambda: UserService(\n    db=container.get(DATABASE),\n    logger=container.get(LOGGER)\n))\n\n# FastAPI dependency\ndef get_user_service() -&gt; UserService:\n    return container.get(USER_SERVICE)\n\n# Endpoints using FastAPI dependencies\n@app.post(\"/users\")\nasync def create_user(\n    user_data: dict[str, str],\n    user_service: Annotated[UserService, Depends(get_user_service)]\n) -&gt; dict[str, str]:\n    return user_service.create_user(user_data)\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(\n    user_id: int,\n    user_service: Annotated[UserService, Depends(get_user_service)]\n) -&gt; dict[str, str]:\n    return user_service.get_user(user_id)\n</code></pre>"},{"location":"usage/#option-2-pyinj-inject-decorator-recommended","title":"Option 2: PyInj @inject Decorator (Recommended)","text":"<pre><code>from pyinj import inject, set_default_container\n\n# Set global container\nset_default_container(container)\n\n@app.post(\"/users-v2\")\n@inject  # Much cleaner!\nasync def create_user_v2(\n    user_data: dict[str, str],\n    user_service: UserService  # Auto-injected\n) -&gt; dict[str, str]:\n    return user_service.create_user(user_data)\n\n@app.get(\"/users-v2/{user_id}\")\n@inject\nasync def get_user_v2(\n    user_id: int,\n    user_service: UserService  # Auto-injected\n) -&gt; dict[str, str]:\n    return user_service.get_user(user_id)\n</code></pre>"},{"location":"usage/#request-scoped-dependencies","title":"Request-Scoped Dependencies","text":"<pre><code>from pyinj import RequestScope\n\n# Current user based on request context\nCURRENT_USER = Token[User](\"current_user\", scope=Scope.REQUEST)\n\ndef get_current_user_from_request() -&gt; User:\n    # In real app, extract from JWT token, session, etc.\n    return User(id=123, name=\"Alice\")\n\ncontainer.register(CURRENT_USER, get_current_user_from_request)\n\n# Middleware for request scope\n@app.middleware(\"http\")\nasync def request_scope_middleware(request, call_next):\n    async with container.async_request_scope():\n        response = await call_next(request)\n    return response\n\n@app.get(\"/profile\")\n@inject\nasync def get_profile(current_user: User) -&gt; dict[str, str]:\n    return {\"id\": str(current_user.id), \"name\": current_user.name}\n</code></pre>"},{"location":"usage/#django-integration","title":"Django Integration","text":""},{"location":"usage/#global-container-setup","title":"Global Container Setup","text":"<pre><code># settings.py\nfrom pyinj import Container, Token, Scope, set_default_container\n\n# Global DI container\nDI_CONTAINER = Container()\nset_default_container(DI_CONTAINER)\n\n# Service registrations\nUSER_SERVICE = Token[UserService](\"user_service\", scope=Scope.SINGLETON)\nEMAIL_SERVICE = Token[EmailService](\"email_service\", scope=Scope.SINGLETON)\nLOGGER = Token[Logger](\"logger\", scope=Scope.SINGLETON)\n\nDI_CONTAINER.register(USER_SERVICE, lambda: DjangoUserService())\nDI_CONTAINER.register(EMAIL_SERVICE, lambda: DjangoEmailService())\nDI_CONTAINER.register(LOGGER, lambda: DjangoLogger())\n</code></pre>"},{"location":"usage/#django-views-with-injection","title":"Django Views with Injection","text":"<pre><code># views.py\nimport json\nfrom django.http import JsonResponse\nfrom django.views.decorators.csrf import csrf_exempt\nfrom pyinj import inject\n\n@csrf_exempt\n@inject  # Uses default container\ndef create_user_view(\n    request,\n    user_service: UserService,  # Auto-injected\n    email_service: EmailService,  # Auto-injected\n    logger: Logger  # Auto-injected\n) -&gt; JsonResponse:\n    if request.method == 'POST':\n        user_data = json.loads(request.body)\n        logger.info(f\"Creating user: {user_data['name']}\")\n\n        user = user_service.create_user(user_data)\n        email_service.send_welcome_email(user.email)\n\n        return JsonResponse({\"user_id\": user.id, \"status\": \"created\"})\n\n    return JsonResponse({\"error\": \"Method not allowed\"}, status=405)\n\n@inject\ndef user_list_view(\n    request,\n    user_service: UserService,\n    logger: Logger\n) -&gt; JsonResponse:\n    logger.info(\"Fetching all users\")\n    users = user_service.get_all_users()\n    return JsonResponse({\"users\": [{\"id\": u.id, \"name\": u.name} for u in users]})\n</code></pre>"},{"location":"usage/#django-class-based-views","title":"Django Class-Based Views","text":"<pre><code>from django.views import View\nfrom django.http import JsonResponse\nfrom pyinj import inject\n\nclass UserView(View):\n    @inject\n    def get(\n        self,\n        request,\n        user_service: UserService,\n        logger: Logger\n    ) -&gt; JsonResponse:\n        logger.info(\"GET /users\")\n        users = user_service.get_all_users()\n        return JsonResponse({\"users\": [u.to_dict() for u in users]})\n\n    @inject  \n    def post(\n        self,\n        request,\n        user_service: UserService,\n        email_service: EmailService,\n        logger: Logger\n    ) -&gt; JsonResponse:\n        user_data = json.loads(request.body)\n        logger.info(f\"POST /users - Creating: {user_data['name']}\")\n\n        user = user_service.create_user(user_data)\n        email_service.send_welcome_email(user.email)\n\n        return JsonResponse(user.to_dict(), status=201)\n</code></pre>"},{"location":"usage/#flask-integration","title":"Flask Integration","text":"<pre><code>from flask import Flask, request, jsonify\nfrom pyinj import Container, Token, Scope, inject\n\napp = Flask(__name__)\ncontainer = Container()\n\n# Service setup (same as above examples)\nUSER_SERVICE = Token[UserService](\"user_service\", scope=Scope.SINGLETON)\ncontainer.register(USER_SERVICE, FlaskUserService)\n\n# Request-scoped current user\nCURRENT_USER = Token[User](\"current_user\", scope=Scope.REQUEST)\ncontainer.register(CURRENT_USER, get_current_user_from_flask_session)\n\n@app.before_request\ndef setup_request_scope():\n    g.request_scope = container.request_scope()\n    g.request_scope.__enter__()\n\n@app.teardown_request\ndef teardown_request_scope(exception=None):\n    if hasattr(g, 'request_scope'):\n        g.request_scope.__exit__(None, None, None)\n\n@app.route('/users', methods=['POST'])\n@inject(container=container)\ndef create_user(\n    user_service: UserService,\n    logger: Logger\n) -&gt; dict[str, str]:\n    user_data = request.json\n    logger.info(f\"Creating user: {user_data['name']}\")\n    user = user_service.create_user(user_data)\n    return jsonify(user.to_dict())\n\n@app.route('/profile')\n@inject(container=container)\ndef get_profile(current_user: User) -&gt; dict[str, str]:\n    return jsonify(current_user.to_dict())\n</code></pre>"},{"location":"usage/#click-cli-applications","title":"Click CLI Applications","text":"<pre><code>import click\nfrom pyinj import Container, Token, Scope, inject\n\n# Setup container\ncontainer = Container()\nCONFIG = Token[Config](\"config\", scope=Scope.SINGLETON)\nLOGGER = Token[Logger](\"logger\", scope=Scope.SINGLETON)\nUSER_SERVICE = Token[UserService](\"user_service\", scope=Scope.SINGLETON)\n\ncontainer.register(CONFIG, lambda: Config.from_file(\"config.yml\"))\ncontainer.register(LOGGER, lambda: ClickLogger())\ncontainer.register(USER_SERVICE, lambda: UserService(\n    config=container.get(CONFIG),\n    logger=container.get(LOGGER)\n))\n\n@click.group()\n@click.pass_context\ndef cli(ctx):\n    \"\"\"CLI application with dependency injection.\"\"\"\n    ctx.obj = container\n\n@cli.command()\n@click.argument('name')\n@click.option('--email', help='User email address')\n@click.pass_context\n@inject(container=lambda ctx=None: ctx.obj if ctx else container)\ndef create_user(\n    ctx,\n    name: str,\n    email: str | None,\n    user_service: UserService,\n    logger: Logger\n) -&gt; None:\n    \"\"\"Create a new user.\"\"\"\n    logger.info(f\"Creating user: {name}\")\n    user_data = {\"name\": name}\n    if email:\n        user_data[\"email\"] = email\n\n    user = user_service.create_user(user_data)\n    click.echo(f\"Created user: {user.id}\")\n\n@cli.command()\n@click.pass_context\n@inject\ndef list_users(\n    ctx,\n    user_service: UserService,\n    logger: Logger\n) -&gt; None:\n    \"\"\"List all users.\"\"\"\n    logger.info(\"Listing all users\")\n    users = user_service.get_all_users()\n\n    for user in users:\n        click.echo(f\"{user.id}: {user.name}\")\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre>"},{"location":"usage/#real-world-usage-patterns","title":"Real-World Usage Patterns","text":""},{"location":"usage/#microservice-architecture","title":"Microservice Architecture","text":"<pre><code>from pyinj import Container, Token, Scope, inject\nimport httpx\nfrom typing import Protocol\n\n# Service interfaces\nclass UserServiceClient(Protocol):\n    async def get_user(self, user_id: int) -&gt; dict[str, str]: ...\n    async def create_user(self, user_data: dict[str, str]) -&gt; dict[str, str]: ...\n\nclass NotificationServiceClient(Protocol):\n    async def send_notification(self, user_id: int, message: str) -&gt; bool: ...\n\nclass OrderService(Protocol):\n    async def create_order(self, user_id: int, items: list[dict[str, str]]) -&gt; dict[str, str]: ...\n\n# Implementations\nclass HTTPUserServiceClient:\n    def __init__(self, base_url: str):\n        self.client = httpx.AsyncClient(base_url=base_url)\n\n    async def get_user(self, user_id: int) -&gt; dict[str, str]:\n        response = await self.client.get(f\"/users/{user_id}\")\n        return response.json()\n\n    async def create_user(self, user_data: dict[str, str]) -&gt; dict[str, str]:\n        response = await self.client.post(\"/users\", json=user_data)\n        return response.json()\n\nclass HTTPNotificationServiceClient:\n    def __init__(self, base_url: str):\n        self.client = httpx.AsyncClient(base_url=base_url)\n\n    async def send_notification(self, user_id: int, message: str) -&gt; bool:\n        response = await self.client.post(\"/notifications\", json={\n            \"user_id\": user_id,\n            \"message\": message\n        })\n        return response.status_code == 200\n\nclass OrderServiceImpl:\n    def __init__(self, user_client: UserServiceClient, notification_client: NotificationServiceClient):\n        self.user_client = user_client\n        self.notification_client = notification_client\n\n    async def create_order(self, user_id: int, items: list[dict[str, str]]) -&gt; dict[str, str]:\n        # Verify user exists\n        user = await self.user_client.get_user(user_id)\n\n        # Create order (business logic here)\n        order = {\n            \"id\": \"order_123\",\n            \"user_id\": user_id,\n            \"items\": items,\n            \"total\": sum(item[\"price\"] for item in items)\n        }\n\n        # Send notification\n        await self.notification_client.send_notification(\n            user_id,\n            f\"Order {order['id']} created successfully!\"\n        )\n\n        return order\n\n# Container setup\ncontainer = Container()\n\n# Register service clients\nUSER_CLIENT = Token[UserServiceClient](\"user_client\", scope=Scope.SINGLETON)\nNOTIFICATION_CLIENT = Token[NotificationServiceClient](\"notification_client\", scope=Scope.SINGLETON)\nORDER_SERVICE = Token[OrderService](\"order_service\", scope=Scope.SINGLETON)\n\ncontainer.register(\n    USER_CLIENT,\n    lambda: HTTPUserServiceClient(\"https://user-service.internal\")\n)\ncontainer.register(\n    NOTIFICATION_CLIENT,\n    lambda: HTTPNotificationServiceClient(\"https://notification-service.internal\")\n)\ncontainer.register(\n    ORDER_SERVICE,\n    lambda: OrderServiceImpl(\n        user_client=container.get(USER_CLIENT),\n        notification_client=container.get(NOTIFICATION_CLIENT)\n    )\n)\n\n# API endpoints\n@inject\nasync def create_order_endpoint(\n    user_id: int,\n    items: list[dict[str, str]],\n    order_service: OrderService\n) -&gt; dict[str, str]:\n    return await order_service.create_order(user_id, items)\n</code></pre>"},{"location":"usage/#database-integration-patterns","title":"Database Integration Patterns","text":"<pre><code>import asyncio\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncGenerator\nimport asyncpg\n\nclass DatabasePool:\n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n        self.pool: asyncpg.Pool | None = None\n\n    async def initialize(self) -&gt; None:\n        self.pool = await asyncpg.create_pool(self.connection_string)\n\n    async def close(self) -&gt; None:\n        if self.pool:\n            await self.pool.close()\n\n    async def execute(self, query: str, *args) -&gt; str:\n        async with self.pool.acquire() as conn:\n            return await conn.execute(query, *args)\n\n    async def fetch(self, query: str, *args) -&gt; list[dict[str, str]]:\n        async with self.pool.acquire() as conn:\n            rows = await conn.fetch(query, *args)\n            return [dict(row) for row in rows]\n\n# Repository pattern with DI\nclass UserRepository:\n    def __init__(self, db: DatabasePool):\n        self.db = db\n\n    async def create_user(self, user_data: dict[str, str]) -&gt; dict[str, str]:\n        query = \"INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id, name, email\"\n        rows = await self.db.fetch(query, user_data[\"name\"], user_data[\"email\"])\n        return rows[0]\n\n    async def get_user(self, user_id: int) -&gt; dict[str, str]:\n        query = \"SELECT id, name, email FROM users WHERE id = $1\"\n        rows = await self.db.fetch(query, user_id)\n        return rows[0] if rows else None\n\n# Resource management with context managers\n@asynccontextmanager\nasync def database_pool_context() -&gt; AsyncGenerator[DatabasePool, None]:\n    pool = DatabasePool(\"postgresql://localhost/myapp\")\n    await pool.initialize()\n    try:\n        yield pool\n    finally:\n        await pool.close()\n\n# Container setup\ncontainer = Container()\nDB_POOL = Token[DatabasePool](\"db_pool\", scope=Scope.SINGLETON)\nUSER_REPO = Token[UserRepository](\"user_repo\", scope=Scope.SINGLETON)\n\ncontainer.register_context_async(DB_POOL, database_pool_context)\ncontainer.register(USER_REPO, lambda: UserRepository(\n    db=container.get(DB_POOL)\n))\n\n# Service layer\n@inject\nasync def user_service(\n    user_repo: UserRepository,\n    logger: Logger\n) -&gt; None:\n    logger.info(\"User service started\")\n    users = await user_repo.get_user(123)\n    logger.info(f\"Found user: {users}\")\n\n# Application lifecycle\nasync def main() -&gt; None:\n    try:\n        await user_service()\n    finally:\n        await container.aclose()  # Clean shutdown\n\nasyncio.run(main())\n</code></pre>"},{"location":"usage/#testing-patterns-with-di","title":"Testing Patterns with DI","text":"<pre><code>import pytest\nfrom unittest.mock import AsyncMock, Mock\nfrom pyinj import Container, Token, Scope\n\nclass TestUserService:\n    def setup_method(self):\n        \"\"\"Setup for each test.\"\"\"\n        self.container = Container()\n\n        # Define tokens\n        self.db_token = Token[Database](\"database\", scope=Scope.SINGLETON)\n        self.email_token = Token[EmailService](\"email_service\", scope=Scope.SINGLETON)\n        self.user_service_token = Token[UserService](\"user_service\")\n\n        # Register real implementations\n        self.container.register(self.db_token, PostgreSQLDatabase)\n        self.container.register(self.email_token, SMTPEmailService)\n        self.container.register(\n            self.user_service_token,\n            lambda: UserService(\n                db=self.container.get(self.db_token),\n                email=self.container.get(self.email_token)\n            )\n        )\n\n    def test_create_user_success(self):\n        \"\"\"Test user creation with mocked dependencies.\"\"\"\n        # Create mocks\n        mock_db = Mock(spec=Database)\n        mock_email = Mock(spec=EmailService)\n\n        mock_db.create_user.return_value = {\"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\"}\n        mock_email.send_welcome_email.return_value = True\n\n        # Override dependencies\n        self.container.override(self.db_token, mock_db)\n        self.container.override(self.email_token, mock_email)\n\n        # Test\n        user_service = self.container.get(self.user_service_token)\n        result = user_service.create_user(\"alice@example.com\", \"Alice\")\n\n        # Assertions\n        assert result[\"id\"] == 1\n        assert result[\"name\"] == \"Alice\"\n        mock_db.create_user.assert_called_once_with(\"alice@example.com\", \"Alice\")\n        mock_email.send_welcome_email.assert_called_once_with(\"alice@example.com\")\n\n    def test_create_user_database_error(self):\n        \"\"\"Test error handling when database fails.\"\"\"\n        # Create mocks\n        mock_db = Mock(spec=Database)\n        mock_email = Mock(spec=EmailService)\n\n        mock_db.create_user.side_effect = DatabaseError(\"Connection failed\")\n\n        # Override dependencies\n        self.container.override(self.db_token, mock_db)\n        self.container.override(self.email_token, mock_email)\n\n        # Test\n        user_service = self.container.get(self.user_service_token)\n\n        with pytest.raises(DatabaseError):\n            user_service.create_user(\"alice@example.com\", \"Alice\")\n\n        # Email should not be sent on database error\n        mock_email.send_welcome_email.assert_not_called()\n\n    @pytest.mark.asyncio\n    async def test_async_user_service(self):\n        \"\"\"Test async service with async mocks.\"\"\"\n        # Create async mocks\n        mock_async_db = AsyncMock(spec=AsyncDatabase)\n        mock_async_email = AsyncMock(spec=AsyncEmailService)\n\n        mock_async_db.create_user.return_value = {\"id\": 1, \"name\": \"Alice\"}\n        mock_async_email.send_welcome_email.return_value = True\n\n        # Register async service\n        async_service_token = Token[AsyncUserService](\"async_user_service\")\n        self.container.register(\n            async_service_token,\n            lambda: AsyncUserService(\n                db=mock_async_db,\n                email=mock_async_email\n            )\n        )\n\n        # Test\n        service = self.container.get(async_service_token)\n        result = await service.create_user(\"alice@example.com\", \"Alice\")\n\n        # Assertions\n        assert result[\"id\"] == 1\n        mock_async_db.create_user.assert_called_once()\n        mock_async_email.send_welcome_email.assert_called_once()\n\n    def teardown_method(self):\n        \"\"\"Cleanup after each test.\"\"\"\n        self.container.clear_overrides()\n</code></pre>"},{"location":"usage/#configuration-management","title":"Configuration Management","text":"<pre><code>from dataclasses import dataclass\nfrom typing import Optional\nimport os\nfrom pyinj import Container, Token, Scope, inject\n\n@dataclass\nclass DatabaseConfig:\n    host: str\n    port: int\n    database: str\n    username: str\n    password: str\n    pool_size: int = 10\n\n@dataclass\nclass RedisConfig:\n    host: str\n    port: int\n    password: Optional[str] = None\n\n@dataclass\nclass AppConfig:\n    debug: bool\n    secret_key: str\n    database: DatabaseConfig\n    redis: RedisConfig\n\ndef load_config() -&gt; AppConfig:\n    \"\"\"Load configuration from environment variables.\"\"\"\n    return AppConfig(\n        debug=os.getenv(\"DEBUG\", \"false\").lower() == \"true\",\n        secret_key=os.getenv(\"SECRET_KEY\", \"dev-secret\"),\n        database=DatabaseConfig(\n            host=os.getenv(\"DB_HOST\", \"localhost\"),\n            port=int(os.getenv(\"DB_PORT\", \"5432\")),\n            database=os.getenv(\"DB_NAME\", \"myapp\"),\n            username=os.getenv(\"DB_USER\", \"postgres\"),\n            password=os.getenv(\"DB_PASSWORD\", \"password\")\n        ),\n        redis=RedisConfig(\n            host=os.getenv(\"REDIS_HOST\", \"localhost\"),\n            port=int(os.getenv(\"REDIS_PORT\", \"6379\")),\n            password=os.getenv(\"REDIS_PASSWORD\")\n        )\n    )\n\n# Container setup\ncontainer = Container()\nCONFIG = Token[AppConfig](\"config\", scope=Scope.SINGLETON)\ncontainer.register(CONFIG, load_config)\n\n# Services using configuration\n@inject\ndef database_service(config: AppConfig) -&gt; DatabaseService:\n    return DatabaseService(\n        host=config.database.host,\n        port=config.database.port,\n        database=config.database.database,\n        username=config.database.username,\n        password=config.database.password,\n        pool_size=config.database.pool_size\n    )\n\n@inject\ndef redis_service(config: AppConfig) -&gt; RedisService:\n    return RedisService(\n        host=config.redis.host,\n        port=config.redis.port,\n        password=config.redis.password\n    )\n\n# Register services that depend on config\nDATABASE_SERVICE = Token[DatabaseService](\"database_service\", scope=Scope.SINGLETON)\nREDIS_SERVICE = Token[RedisService](\"redis_service\", scope=Scope.SINGLETON)\n\ncontainer.register(DATABASE_SERVICE, database_service)\ncontainer.register(REDIS_SERVICE, redis_service)\n</code></pre> <p>This covers the main usage patterns for PyInj in real-world applications. The key benefits are clean separation of concerns, easy testing with mocks, and type-safe dependency resolution.</p>"}]}