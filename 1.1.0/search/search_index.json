{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyInj","text":"<p>Type-safe dependency injection for Python 3.13+</p> <p>Status: Beta \u2014 Active development; breaking changes may occur between pre-releases. Pin exact versions in production.</p> <p>PyInj is a minimal, type-safe DI container focused on clarity and performance:</p> <ul> <li>Thread-safe and async-safe resolution</li> <li>O(1) lookups and cached injection metadata</li> <li>Circular dependency detection and safe cleanup</li> <li>Protocol-based type safety and auto-registration via metaclass</li> <li>Zero runtime dependencies</li> </ul>"},{"location":"#quick-install","title":"Quick Install","text":"<pre><code># uv (recommended)\nuv add pyinj\n\n# or pip\npip install pyinj\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from pyinj import Container, Token, Scope\n\ncontainer = Container()\n\nDB_TOKEN = Token[Database](\"database\")\ncontainer.register(DB_TOKEN, create_database, Scope.SINGLETON)\n\ndb = container.get(DB_TOKEN)\nawait container.dispose()\n</code></pre> <p>Continue with Getting Started for basic patterns and Usage for type-safe injection, metaclass auto-registration, and async lifecycles.</p>"},{"location":"advanced/","title":"Advanced","text":""},{"location":"advanced/#protocol-based-resolution","title":"Protocol-Based Resolution","text":"<pre><code>@container.inject\ndef business_logic(logger: Logger, db: Database) -&gt; str:\n    logger.info(\"Processing\")\n    return db.query(\"SELECT 1\")\n</code></pre>"},{"location":"advanced/#scopes","title":"Scopes","text":"<ul> <li>SINGLETON: one instance per container</li> <li>TRANSIENT: new instance per resolve</li> <li>REQUEST: request-bound lifetime</li> </ul>"},{"location":"advanced/#testing-and-overrides","title":"Testing and Overrides","text":"<pre><code>mock = Mock(spec=Logger)\ncontainer.override(logger_token, mock)\n...\ncontainer.clear_overrides()\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>This API reference is generated automatically from the source using mkdocstrings.</p>"},{"location":"api/#top-level-package","title":"Top-level package","text":"<p>PyInj - Type-safe dependency injection for modern Python.</p> <p>Status: Beta - APIs may change between pre-releases. Pin exact versions in production.</p> <p>Highlights: - Immutable tokens with pre-computed hashes (O(1) lookups) - ContextVar-based scoping for async and thread safety - <code>@inject</code> decorator (FastAPI-inspired) and lightweight markers - Scala-style \"given\" instances for ergonomic overrides - Zero runtime dependencies</p> Quick start <p>from pyinj import Container, Token, Scope</p> <p>container = Container() DB = TokenDatabase container.register(DB, create_database, scope=Scope.SINGLETON)</p> <p>db = container.get(DB)</p>"},{"location":"api/#pyinj--use-db","title":"... use db ...","text":""},{"location":"api/#pyinj.CircularDependencyError","title":"<code>CircularDependencyError</code>","text":"<p>               Bases: <code>ResolutionError</code></p> <p>Raised when a circular dependency is detected during resolution.</p> Source code in <code>src/pyinj/exceptions.py</code> <pre><code>class CircularDependencyError(ResolutionError):\n    \"\"\"Raised when a circular dependency is detected during resolution.\"\"\"\n\n    def __init__(self, token: \"Token[Any]\", chain: list[\"Token[Any]\"]) -&gt; None:\n        \"\"\"Initialize circular dependency error.\n\n        Args:\n            token: The token that created the cycle\n            chain: The resolution chain showing the cycle\n        \"\"\"\n        super().__init__(\n            token,\n            chain,\n            f\"Circular dependency detected: {' -&gt; '.join(t.name for t in chain)} -&gt; {token.name}\",\n        )\n</code></pre>"},{"location":"api/#pyinj.CircularDependencyError.__init__","title":"<code>__init__(token, chain)</code>","text":"<p>Initialize circular dependency error.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>'Token[Any]'</code> <p>The token that created the cycle</p> required <code>chain</code> <code>list['Token[Any]']</code> <p>The resolution chain showing the cycle</p> required Source code in <code>src/pyinj/exceptions.py</code> <pre><code>def __init__(self, token: \"Token[Any]\", chain: list[\"Token[Any]\"]) -&gt; None:\n    \"\"\"Initialize circular dependency error.\n\n    Args:\n        token: The token that created the cycle\n        chain: The resolution chain showing the cycle\n    \"\"\"\n    super().__init__(\n        token,\n        chain,\n        f\"Circular dependency detected: {' -&gt; '.join(t.name for t in chain)} -&gt; {token.name}\",\n    )\n</code></pre>"},{"location":"api/#pyinj.Container","title":"<code>Container</code>","text":"<p>               Bases: <code>ContextualContainer</code></p> <p>Ergonomic, type-safe DI container with async support.</p> <p>Features: - O(1) lookups with a compact registry - Thread/async-safe singleton initialization - Contextual scoping using <code>contextvars</code> (request/session) - Scala-inspired \"given\" instances for testability - Method chaining for concise setup and batch operations</p> Example <p>container = Container() LOGGER = TokenLogger container.register_singleton(LOGGER, ConsoleLogger)</p> <p>@inject def handler(logger: Inject[Logger]):     logger.info(\"hello\")</p> Source code in <code>src/pyinj/container.py</code> <pre><code>class Container(ContextualContainer):\n    \"\"\"Ergonomic, type-safe DI container with async support.\n\n    Features:\n    - O(1) lookups with a compact registry\n    - Thread/async-safe singleton initialization\n    - Contextual scoping using ``contextvars`` (request/session)\n    - Scala-inspired \"given\" instances for testability\n    - Method chaining for concise setup and batch operations\n\n    Example:\n        container = Container()\n        LOGGER = Token[Logger](\"logger\")\n        container.register_singleton(LOGGER, ConsoleLogger)\n\n        @inject\n        def handler(logger: Inject[Logger]):\n            logger.info(\"hello\")\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize enhanced container.\"\"\"\n        super().__init__()\n\n        # Token factory for convenient creation\n        self.tokens: TokenFactory = TokenFactory()\n\n        # Given instances (Scala-inspired)\n        self._given_providers: dict[type[object], ProviderSync[object]] = {}\n\n        # Override less-precise base attributes with typed variants\n        self._providers: dict[Token[object], ProviderLike[object]] = {}\n        self._registrations: dict[Token[object], _Registration[object]] = {}\n        self._token_scopes: dict[Token[object], Scope] = {}\n        self._singletons: dict[Token[object], object] = {}\n        self._async_locks: dict[Token[object], asyncio.Lock] = {}\n\n        # Performance metrics\n        self._resolution_times: deque[float] = deque(maxlen=1000)\n        self._cache_hits: int = 0\n        self._cache_misses: int = 0\n\n        # Thread safety\n        self._lock: threading.RLock = threading.RLock()\n        self._singleton_locks: dict[Token[object], threading.Lock] = defaultdict(\n            threading.Lock\n        )\n\n        # Track dependencies for graph\n        self._dependencies: dict[Token[object], set[Token[object]]] = defaultdict(set)\n\n        # Per-context overrides (DI_SPEC requirement)\n        self._overrides: ContextVar[dict[Token[object], object] | None] = ContextVar(\n            \"pyinj_overrides\",\n            default=None,\n        )\n\n        # Resolution stack is tracked via ContextVar (task-local)\n\n        # Fast type-to-token index for O(1) resolution by type\n        self._type_index: dict[type[object], Token[object]] = {}\n        # Container-level cleanup stacks for singleton context-managed resources\n        self._singleton_cleanup_sync: list[Callable[[], None]] = []\n        self._singleton_cleanup_async: list[Callable[[], Awaitable[None]]] = []\n\n        # Auto-register classes marked with Injectable metaclass (plain DI)\n        self._auto_register()\n\n    def _auto_register(self) -&gt; None:\n        try:\n            from .metaclasses import Injectable  # avoid top-level cycle\n        except Exception:\n            return\n        registry = Injectable.get_registry()\n        for cls, token in registry.items():\n            # Determine scope from class metadata (default TRANSIENT)\n            scope = getattr(cls, \"__scope__\", Scope.TRANSIENT)\n            # Build provider; resolve constructor deps by type\n            try:\n                from typing import get_type_hints\n\n                hints = get_type_hints(cls.__init__)\n                deps: dict[str, type[object]] = {\n                    k: v for k, v in hints.items() if k not in (\"self\", \"return\")\n                }\n            except Exception:\n                deps = {}\n\n            if deps:\n                def make_factory(\n                    target_cls: type[Any] = cls,\n                    deps_map: dict[str, type[object]] = deps,\n                ) -&gt; Callable[[], Any]:\n                    def provider() -&gt; Any:\n                        kwargs: dict[str, Any] = {}\n                        for name, typ in deps_map.items():\n                            kwargs[name] = self.get(typ)\n                        return target_cls(**kwargs)\n                    return provider\n                self.register(token, make_factory(), scope=scope)\n            else:\n                # No deps, construct directly\n                self.register(token, cast(ProviderLike[Any], cls), scope=scope)\n\n    # ============= Internal Helpers (Phase 1) =============\n\n    def _coerce_to_token(self, spec: Token[U] | type[U]) -&gt; Token[U]:\n        if isinstance(spec, Token):\n            return spec\n        if isinstance(spec, type):\n            found = self._type_index.get(cast(type[object], spec))\n            if found is not None:\n                return cast(Token[U], found)\n            for registered in self._providers:\n                if registered.type_ == spec:\n                    return cast(Token[U], registered)\n            for registered in self._singletons:\n                if registered.type_ == spec:\n                    return cast(Token[U], registered)\n            return Token(spec.__name__, spec)\n        # Disallow string-based tokens for type safety\n        raise TypeError(\n            \"Token specification must be a Token or type; strings are not supported\"\n        )\n\n    def _get_override(self, token: Token[U]) -&gt; U | None:\n        current = self._overrides.get()\n        if current is not None:\n            val = current.get(cast(Token[object], token))\n            if val is not None:\n                return cast(U, val)\n        return None\n\n    @contextmanager\n    def _resolution_guard(self, token: Token[Any]):\n        stack = _resolution_stack.get()\n        if token in stack:\n            raise CircularDependencyError(token, list(stack))\n        reset_token = _resolution_stack.set(stack + (token,))\n        try:\n            yield\n        finally:\n            _resolution_stack.reset(reset_token)\n\n    # ============= Registration Methods =============\n\n    def register(\n        self,\n        token: Token[U] | type[U],\n        provider: ProviderLike[U],\n        scope: Scope | None = None,\n        *,\n        tags: tuple[str, ...] = (),\n    ) -&gt; \"Container\":\n        \"\"\"Register a provider for a token.\n\n        Args:\n            token: A ``Token[T]`` or a concrete ``type[T]``. If a type is\n                provided, a token is created automatically.\n            provider: Callable that returns the dependency instance.\n            scope: Optional lifecycle override (defaults to token.scope or TRANSIENT).\n            tags: Optional tags for discovery/metadata.\n\n        Returns:\n            Self, to allow method chaining.\n\n        Example:\n            container.register(Token[DB](\"db\"), create_db, scope=Scope.SINGLETON)\n        \"\"\"\n        # Validate token type\n        if not isinstance(token, (Token, type)):\n            raise TypeError(\n                \"Token specification must be a Token or type; strings are not supported\"\n            )\n\n        # Convert to Token if needed\n        if isinstance(token, type):\n            token = self.tokens.create(\n                token.__name__, token, scope=scope or Scope.TRANSIENT, tags=tags\n            )\n        elif scope is not None:\n            # Record desired scope without changing the token identity\n            self._token_scopes[cast(Token[object], token)] = scope\n\n        # Validate provider\n        if not callable(provider):\n            raise TypeError(\n                f\"Provider must be callable, got {type(provider).__name__}\\n\"\n                f\"  Fix: Pass a function or lambda that returns an instance\\n\"\n                f\"  Example: container.register(token, lambda: {token.type_.__name__}())\"\n            )\n\n        with self._lock:\n            obj_token = cast(Token[object], token)\n            # Enforce immutable registrations\n            if obj_token in self._providers or obj_token in self._registrations or obj_token in self._singletons:\n                raise ValueError(f\"Token '{obj_token.name}' is already registered\")\n            self._providers[obj_token] = cast(ProviderLike[object], provider)\n            self._registrations[obj_token] = _Registration(\n                provider=cast(Callable[[], Any], provider), cleanup=CleanupMode.NONE\n            )\n            # Update type index\n            self._type_index[obj_token.type_] = obj_token\n\n        return self  # Enable chaining\n\n    def register_singleton(\n        self, token: Token[U] | type[U], provider: ProviderLike[U]\n    ) -&gt; \"Container\":\n        \"\"\"Register a singleton-scoped dependency.\"\"\"\n        return self.register(token, provider, scope=Scope.SINGLETON)\n\n    def register_request(\n        self, token: Token[U] | type[U], provider: ProviderLike[U]\n    ) -&gt; \"Container\":\n        \"\"\"Register a request-scoped dependency.\"\"\"\n        return self.register(token, provider, scope=Scope.REQUEST)\n\n    def register_transient(\n        self, token: Token[U] | type[U], provider: ProviderLike[U]\n    ) -&gt; \"Container\":\n        \"\"\"Register a transient-scoped dependency.\"\"\"\n        return self.register(token, provider, scope=Scope.TRANSIENT)\n\n    @overload\n    def register_context(\n        self,\n        token: Token[U] | type[U],\n        cm_provider: Callable[[], ContextManager[U]],\n        *,\n        is_async: Literal[False],\n        scope: Scope | None = None,\n    ) -&gt; \"Container\":\n        ...\n\n    @overload\n    def register_context(\n        self,\n        token: Token[U] | type[U],\n        cm_provider: Callable[[], AsyncContextManager[U]],\n        *,\n        is_async: Literal[True],\n        scope: Scope | None = None,\n    ) -&gt; \"Container\":\n        ...\n\n    def register_context(\n        self,\n        token: Token[U] | type[U],\n        cm_provider: Callable[[], Any],\n        *,\n        is_async: bool,\n        scope: Scope | None = None,\n    ) -&gt; \"Container\":\n        \"\"\"Register a context-managed dependency.\n\n        - When ``is_async=False``, ``cm_provider`` must return a ``ContextManager[T]``.\n        - When ``is_async=True``, ``cm_provider`` must return an ``AsyncContextManager[T]``.\n\n        The context is entered on first resolution within the declared scope and\n        exited during scope cleanup (request/session), or on container close for\n        singletons.\n        \"\"\"\n        # Validate token\n        if not isinstance(token, (Token, type)):\n            raise TypeError(\n                \"Token specification must be a Token or type; strings are not supported\"\n            )\n        # To token\n        if isinstance(token, type):\n            token = self.tokens.create(token.__name__, token, scope=scope or Scope.TRANSIENT)\n        elif scope is not None:\n            self._token_scopes[cast(Token[object], token)] = scope\n\n        if not callable(cm_provider):\n            raise TypeError(\"cm_provider must be callable and return a (async) context manager\")\n\n        with self._lock:\n            obj_token = cast(Token[object], token)\n            # Enforce immutable registrations\n            if obj_token in self._providers or obj_token in self._registrations or obj_token in self._singletons:\n                raise ValueError(f\"Token '{obj_token.name}' is already registered\")\n            self._registrations[obj_token] = _Registration(\n                provider=cm_provider,\n                cleanup=CleanupMode.CONTEXT_ASYNC if is_async else CleanupMode.CONTEXT_SYNC,\n            )\n            self._type_index[obj_token.type_] = obj_token\n        return self\n\n    # Strongly-typed helpers separating sync/async context registration\n    def register_context_sync(\n        self,\n        token: Token[U] | type[U],\n        cm_provider: Callable[[], ContextManager[U]],\n        *,\n        scope: Scope | None = None,\n    ) -&gt; \"Container\":\n        \"\"\"Typed helper to register a sync context-managed provider.\n\n        Equivalent to ``register_context(..., is_async=False)``.\n        \"\"\"\n        return self.register_context(token, cm_provider, is_async=False, scope=scope)\n\n    def register_context_async(\n        self,\n        token: Token[U] | type[U],\n        cm_provider: Callable[[], AsyncContextManager[U]],\n        *,\n        scope: Scope | None = None,\n    ) -&gt; \"Container\":\n        \"\"\"Typed helper to register an async context-managed provider.\n\n        Equivalent to ``register_context(..., is_async=True)``.\n        \"\"\"\n        return self.register_context(token, cm_provider, is_async=True, scope=scope)\n\n    def register_value(self, token: Token[U] | type[U], value: U) -&gt; \"Container\":\n        \"\"\"Register a pre-created value as a singleton.\"\"\"\n        if isinstance(token, type):\n            token = self.tokens.singleton(token.__name__, token)\n        # token is now a Token[Any]\n\n        # Store directly as singleton (immutable)\n        obj_token = cast(Token[object], token)\n        if obj_token in self._providers or obj_token in self._registrations or obj_token in self._singletons:\n            raise ValueError(f\"Token '{obj_token.name}' is already registered\")\n        self._singletons[obj_token] = value\n        return self\n\n    def override(self, token: Token[U], value: U) -&gt; None:\n        \"\"\"Override a dependency for the current concurrent context only.\n\n        Uses a ContextVar-backed mapping so overrides are isolated between\n        threads/tasks. Prefer ``use_overrides`` for scoped overrides.\n        \"\"\"\n        parent = self._overrides.get()\n        merged: dict[Token[object], object] = dict(parent) if parent else {}\n        merged[cast(Token[object], token)] = value\n        self._overrides.set(merged)\n\n    # ============= Given Instances (Scala-inspired) =============\n\n    def given(self, type_: type[U], provider: ProviderSync[U] | U) -&gt; \"Container\":\n        \"\"\"Register a given instance for a type (Scala-style).\"\"\"\n        if callable(provider):\n            self._given_providers[type_] = cast(ProviderSync[object], provider)\n        else:\n            # Wrap value in lambda\n            self._given_providers[type_] = lambda p=provider: p\n\n        return self\n\n    def resolve_given(self, type_: type[U]) -&gt; U | None:\n        \"\"\"Resolve a given instance by type.\"\"\"\n        provider = self._given_providers.get(type_)\n        if provider:\n            return cast(ProviderSync[U], provider)()\n        return None\n\n    @contextmanager\n    def using(\n        self,\n        mapping: Mapping[type[object], object] | None = None,\n        **givens: object,\n    ) -&gt; Iterator[Container]:\n        \"\"\"Temporarily register \"given\" instances for the current block.\n\n        Supports both an explicit mapping of types to instances and\n        keyword arguments that match type names previously registered\n        via ``given()``.\n        \"\"\"\n        old_givens = self._given_providers.copy()\n\n        # Apply explicit mapping first (precise and type-safe)\n        if mapping:\n            for t, instance in mapping.items():\n                self.given(t, instance)\n\n        # Support kwargs by matching on type name for already-known givens\n        if givens:\n            known_types = list(self._given_providers.keys())\n            for name, instance in givens.items():\n                for t in known_types:\n                    if getattr(t, \"__name__\", \"\") == name:\n                        self.given(t, instance)\n                        break\n\n        try:\n            yield self\n        finally:\n            self._given_providers = old_givens\n\n    # ============= Resolution Methods =============\n\n    # --- Internal typed helpers to centralize invariance casts ---\n\n    def _obj_token(self, token: Token[U]) -&gt; Token[object]:\n        return cast(Token[object], token)\n\n    def _canonicalize(self, token: Token[U]) -&gt; Token[U]:\n        \"\"\"Return the registered token that matches by name and type (ignore scope).\n\n        This allows callers to construct a token with the same name/type but different\n        scope and still resolve the registered binding.\n        \"\"\"\n        obj_token = self._obj_token(token)\n        if obj_token in self._providers or obj_token in self._singletons:\n            return token\n        # Search providers first\n        for t in self._providers.keys():\n            if t.name == token.name and t.type_ == token.type_:\n                return cast(Token[U], t)\n        # Then singletons\n        for t in self._singletons.keys():\n            if t.name == token.name and t.type_ == token.type_:\n                return cast(Token[U], t)\n        return token\n\n    def _get_provider(self, token: Token[U]) -&gt; ProviderLike[U]:\n        token = self._canonicalize(token)\n        obj_token = self._obj_token(token)\n        provider = self._providers.get(obj_token)\n        if provider is None:\n            raise ResolutionError(\n                token,\n                [],\n                (\n                    f\"No provider registered for token '{token.name}'. \"\n                    f\"Fix: register a provider for this token before resolving.\"\n                ),\n            )\n        return cast(ProviderLike[U], provider)\n\n    def _get_scope(self, token: Token[U]) -&gt; Scope:\n        token = self._canonicalize(token)\n        return self._token_scopes.get(self._obj_token(token), token.scope)\n\n    def _get_singleton_cached(self, token: Token[U]) -&gt; U | None:\n        token = self._canonicalize(token)\n        obj_token = self._obj_token(token)\n        if obj_token in self._singletons:\n            return cast(U, self._singletons[obj_token])\n        return None\n\n    def _set_singleton_cached(self, token: Token[U], value: U) -&gt; None:\n        self._singletons[self._obj_token(token)] = value\n\n    def _ensure_async_lock(self, token: Token[U]) -&gt; asyncio.Lock:\n        obj_token = self._obj_token(token)\n        lock = self._async_locks.get(obj_token)\n        if lock is None:\n            lock = asyncio.Lock()\n            self._async_locks[obj_token] = lock\n        return lock\n\n    def get(self, token: Token[U] | type[U]) -&gt; U:\n        \"\"\"Resolve a dependency synchronously.\n\n        Args:\n            token: The ``Token[T]`` or ``type[T]`` to resolve.\n\n        Returns:\n            The resolved instance.\n\n        Raises:\n            ResolutionError: If no provider is registered or resolution fails.\n        \"\"\"\n        # Convert to token if needed and handle givens\n        if isinstance(token, type):\n            given = self.resolve_given(token)\n            if given is not None:\n                return given\n        token = self._coerce_to_token(token)\n        token = self._canonicalize(token)\n\n        # Check per-context overrides first\n        override = self._get_override(token)\n        if override is not None:\n            self._cache_hits += 1\n            return override\n\n        # Check context first (for request/session stored instances)\n        instance = self.resolve_from_context(token)\n        if instance is not None:\n            self._cache_hits += 1\n            return instance\n\n        self._cache_misses += 1\n\n        with self._resolution_guard(token):\n            obj_token = cast(Token[object], token)\n            reg = self._registrations.get(obj_token)\n            effective_scope = self._get_scope(token)\n            if reg and reg.cleanup is CleanupMode.CONTEXT_ASYNC:\n                # cannot enter async context in sync path\n                raise ResolutionError(\n                    token,\n                    [],\n                    \"Context-managed provider is async; Use aget() for async providers\",\n                )\n            if reg and reg.cleanup is CleanupMode.CONTEXT_SYNC:\n                # handle context-managed sync\n                if effective_scope == Scope.SINGLETON:\n                    with self._singleton_locks[self._obj_token(token)]:\n                        cached = self._get_singleton_cached(token)\n                        if cached is not None:\n                            return cached\n                        cm = reg.provider()\n                        value = cm.__enter__()\n                        self._set_singleton_cached(token, value)\n                        # schedule cleanup\n                        self._singleton_cleanup_sync.append(lambda cm=cm: cm.__exit__(None, None, None))\n                        self._resources.append(value)\n                        return cast(U, value)\n                else:\n                    cm = reg.provider()\n                    value = cm.__enter__()\n                    self.store_in_context(token, value)\n                    # register per-scope cleanup\n                    if effective_scope == Scope.REQUEST:\n                        self._register_request_cleanup_sync(lambda cm=cm: cm.__exit__(None, None, None))\n                    elif effective_scope == Scope.SESSION:\n                        self._register_session_cleanup_sync(lambda cm=cm: cm.__exit__(None, None, None))\n                    self._resources.append(value)\n                    return cast(U, value)\n\n            provider = self._get_provider(token)\n            # legacy non-context providers\n            if effective_scope == Scope.SINGLETON:\n                with self._singleton_locks[self._obj_token(token)]:\n                    cached = self._get_singleton_cached(token)\n                    if cached is not None:\n                        return cached\n                    if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                        raise ResolutionError(\n                            token,\n                            [],\n                            \"Provider is async; Use aget() for async providers\",\n                        )\n                    instance = cast(ProviderSync[U], provider)()\n                    self._validate_and_track(token, instance)\n                    self._set_singleton_cached(token, instance)\n                    return instance\n            else:\n                if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                    raise ResolutionError(\n                        token,\n                        [],\n                        \"Provider is async; Use aget() for async providers\",\n                    )\n                instance = cast(ProviderSync[U], provider)()\n                self._validate_and_track(token, instance)\n                # Only store in context for REQUEST/SESSION\n                if effective_scope in (Scope.REQUEST, Scope.SESSION):\n                    self.store_in_context(token, instance)\n                return instance\n\n    async def aget(self, token: Token[U] | type[U]) -&gt; U:\n        \"\"\"Resolve a dependency asynchronously.\n\n        Equivalent to :meth:`get` but awaits async providers and uses\n        async locks for singleton initialization.\n        \"\"\"\n        # Convert to token if needed\n        if isinstance(token, type):\n            given = self.resolve_given(token)\n            if given is not None:\n                return given\n        token = self._coerce_to_token(token)\n        token = self._canonicalize(token)\n\n        # Check per-context overrides first\n        override = self._get_override(token)\n        if override is not None:\n            self._cache_hits += 1\n            return override\n\n        # Check context first\n        instance = self.resolve_from_context(token)\n        if instance is not None:\n            self._cache_hits += 1\n            return instance\n\n        self._cache_misses += 1\n\n        with self._resolution_guard(token):\n            obj_token = cast(Token[object], token)\n            reg = self._registrations.get(obj_token)\n            effective_scope = self._get_scope(token)\n            if reg and reg.cleanup is CleanupMode.CONTEXT_ASYNC:\n                if effective_scope == Scope.SINGLETON:\n                    lock = self._ensure_async_lock(token)\n                    async with lock:\n                        cached = self._get_singleton_cached(token)\n                        if cached is not None:\n                            return cached\n                        cm = reg.provider()\n                        value = await cm.__aenter__()\n                        self._set_singleton_cached(token, value)\n                        self._singleton_cleanup_async.append(lambda cm=cm: cm.__aexit__(None, None, None))\n                        self._resources.append(value)\n                        return cast(U, value)\n                else:\n                    cm = reg.provider()\n                    value = await cm.__aenter__()\n                    self.store_in_context(token, value)\n                    if effective_scope == Scope.REQUEST:\n                        self._register_request_cleanup_async(lambda cm=cm: cm.__aexit__(None, None, None))\n                    elif effective_scope == Scope.SESSION:\n                        self._register_session_cleanup_async(lambda cm=cm: cm.__aexit__(None, None, None))\n                    self._resources.append(value)\n                    return cast(U, value)\n\n            # fallback legacy providers\n            provider = self._get_provider(token)\n            if effective_scope == Scope.SINGLETON:\n                lock = self._ensure_async_lock(token)\n                async with lock:\n                    cached = self._get_singleton_cached(token)\n                    if cached is not None:\n                        return cached\n\n                    if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                        instance = await cast(ProviderAsync[U], provider)()\n                    else:\n                        instance = cast(ProviderSync[U], provider)()\n                    self._validate_and_track(token, instance)\n                    self._set_singleton_cached(token, instance)\n                    return instance\n            else:\n                if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                    instance = await cast(ProviderAsync[U], provider)()\n                else:\n                    instance = cast(ProviderSync[U], provider)()\n                self._validate_and_track(token, instance)\n                if effective_scope in (Scope.REQUEST, Scope.SESSION):\n                    self.store_in_context(token, instance)\n                return instance\n\n    # ============= Batch Operations =============\n\n    def batch_register(\n        self, registrations: list[tuple[Token[object], ProviderLike[object]]]\n    ) -&gt; Container:\n        \"\"\"Register multiple dependencies at once.\"\"\"\n        for token, provider in registrations:\n            self.register(token, provider)\n        return self\n\n    def batch_resolve(self, tokens: list[Token[object]]) -&gt; dict[Token[object], object]:\n        \"\"\"Resolve multiple dependencies efficiently (sync).\"\"\"\n        sorted_tokens = sorted(tokens, key=lambda t: t.scope.value)\n        results: dict[Token[object], object] = {}\n        for _scope, group in groupby(sorted_tokens, key=lambda t: t.scope):\n            group_list = list(group)\n            for tk in group_list:\n                results[tk] = self.get(tk)\n        return results\n\n    async def batch_resolve_async(\n        self, tokens: list[Token[object]]\n    ) -&gt; dict[Token[object], object]:\n        \"\"\"Async batch resolution with parallel execution.\"\"\"\n        tasks = {token: self.aget(token) for token in tokens}\n        results_list: list[object] = await asyncio.gather(*tasks.values())\n        return dict(zip(tasks.keys(), results_list, strict=True))\n\n    # (Provider graph analysis intentionally omitted; can be added behind a feature flag.)\n\n    @lru_cache(maxsize=512)\n    def _get_resolution_path(self, token: Token[Any]) -&gt; tuple[Token[Any], ...]:\n        \"\"\"Get resolution path for a token (cached).\"\"\"\n        return (token,)\n\n    @property\n    def cache_hit_rate(self) -&gt; float:\n        total = self._cache_hits + self._cache_misses\n        return 0.0 if total == 0 else self._cache_hits / total\n\n    def get_stats(self) -&gt; dict[str, Any]:\n        return {\n            \"total_providers\": len(self._providers),\n            \"singletons\": len(self._singletons),\n            \"cache_hits\": self._cache_hits,\n            \"cache_misses\": self._cache_misses,\n            \"cache_hit_rate\": self.cache_hit_rate,\n            \"avg_resolution_time\": (\n                sum(self._resolution_times) / len(self._resolution_times)\n                if self._resolution_times\n                else 0\n            ),\n        }\n\n    # ============= Utilities =============\n\n    def get_providers_view(\n        self,\n    ) -&gt; MappingProxyType[Token[object], ProviderLike[object]]:\n        \"\"\"Return a read-only view of registered providers.\"\"\"\n        return MappingProxyType(self._providers)\n\n    def resources_view(self) -&gt; tuple[SupportsClose | SupportsAsyncClose, ...]:\n        \"\"\"Return a read-only snapshot of tracked resources for tests/inspection.\"\"\"\n        return tuple(self._resources)\n\n    # ============= Decorator Alias =============\n\n    def inject(\n        self, func: Callable[..., Any] | None = None, *, cache: bool = True\n    ) -&gt; Callable[..., Any]:\n        \"\"\"Alias to pyinj.injection.inject bound to this container.\n\n        Enables ``@container.inject`` usage in addition to\n        ``@inject(container=container)``.\n        \"\"\"\n        from .injection import inject as _inject\n\n        if func is None:\n            return _inject(container=self, cache=cache)\n        return _inject(func, container=self, cache=cache)\n\n    def has(self, token: Token[Any] | type[Any]) -&gt; bool:\n        \"\"\"Return True if the token/type is known to the container.\"\"\"\n        if isinstance(token, type):\n            if token in self._given_providers:\n                return True\n            token = Token(token.__name__, token)\n        obj_token = cast(Token[object], token)\n        return obj_token in self._providers or obj_token in self._singletons\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear caches and statistics; keep provider registrations intact.\"\"\"\n        with self._lock:\n            self._singletons.clear()\n            self._transients.clear()\n            self._given_providers.clear()\n            self._dependencies.clear()\n            self._cache_hits = 0\n            self._cache_misses = 0\n            self._resolution_times.clear()\n        self.clear_all_contexts()\n\n    def __repr__(self) -&gt; str:\n        return (\n            \"Container(\"\n            f\"providers={len(self._providers)}, \"\n            f\"singletons={len(self._singletons)}, \"\n            f\"cache_hit_rate={self.cache_hit_rate:.2%})\"\n        )\n\n    # ============= Context Managers &amp; Cleanup =============\n\n    def __enter__(self) -&gt; Container:  # pragma: no cover - trivial\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:  # pragma: no cover - trivial\n        # If any async singleton cleanups are registered, fail fast in sync context\n        if self._singleton_cleanup_async:\n            raise AsyncCleanupRequiredError(\n                \"singleton\",\n                \"Use 'await container.aclose()' or an async scope.\",\n            )\n        # Run sync cleanups for singletons (LIFO)\n        for fn in reversed(self._singleton_cleanup_sync):\n            try:\n                fn()\n            except Exception:\n                pass\n\n    async def __aenter__(self) -&gt; Container:  # pragma: no cover - trivial\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:  # pragma: no cover - trivial\n        # Run async cleanups for singletons (LIFO)\n        if self._singleton_cleanup_async:\n            tasks = [fn() for fn in reversed(self._singleton_cleanup_async)]\n            await asyncio.gather(*tasks, return_exceptions=True)\n        # Run sync cleanups too\n        for fn in reversed(self._singleton_cleanup_sync):\n            try:\n                fn()\n            except Exception:\n                pass\n\n    async def aclose(self) -&gt; None:\n        \"\"\"Async close: close tracked resources and clear caches.\"\"\"\n        await self.__aexit__(None, None, None)\n        self.clear()\n\n    async def dispose(self) -&gt; None:\n        \"\"\"Alias for aclose to align with tests and docs.\"\"\"\n        await self.aclose()\n\n    @contextmanager\n    def use_overrides(self, mapping: dict[Token[Any], object]) -&gt; Iterator[None]:\n        \"\"\"Temporarily override tokens for this concurrent context.\n\n        Example:\n            with container.use_overrides({LOGGER: fake_logger}):\n                svc = container.get(SERVICE)\n                ...\n        \"\"\"\n        parent = self._overrides.get()\n        merged: dict[Token[object], object] = dict(parent) if parent else {}\n        merged.update(cast(dict[Token[object], object], mapping))\n        token: CtxToken[dict[Token[object], object] | None] = self._overrides.set(\n            merged\n        )\n        try:\n            yield\n        finally:\n            self._overrides.reset(token)\n\n    def clear_overrides(self) -&gt; None:\n        \"\"\"Clear all overrides for the current context.\"\"\"\n        if self._overrides.get() is not None:\n            self._overrides.set(None)\n\n    # ============= Validation &amp; Resource Tracking =============\n\n    def _validate_and_track(self, token: Token[Any], instance: object) -&gt; None:\n        if not token.validate(instance):\n            raise TypeError(\n                f\"Provider for token '{token.name}' returned {type(instance).__name__}, expected {token.type_.__name__}\"\n            )\n</code></pre>"},{"location":"api/#pyinj.Container.__init__","title":"<code>__init__()</code>","text":"<p>Initialize enhanced container.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize enhanced container.\"\"\"\n    super().__init__()\n\n    # Token factory for convenient creation\n    self.tokens: TokenFactory = TokenFactory()\n\n    # Given instances (Scala-inspired)\n    self._given_providers: dict[type[object], ProviderSync[object]] = {}\n\n    # Override less-precise base attributes with typed variants\n    self._providers: dict[Token[object], ProviderLike[object]] = {}\n    self._registrations: dict[Token[object], _Registration[object]] = {}\n    self._token_scopes: dict[Token[object], Scope] = {}\n    self._singletons: dict[Token[object], object] = {}\n    self._async_locks: dict[Token[object], asyncio.Lock] = {}\n\n    # Performance metrics\n    self._resolution_times: deque[float] = deque(maxlen=1000)\n    self._cache_hits: int = 0\n    self._cache_misses: int = 0\n\n    # Thread safety\n    self._lock: threading.RLock = threading.RLock()\n    self._singleton_locks: dict[Token[object], threading.Lock] = defaultdict(\n        threading.Lock\n    )\n\n    # Track dependencies for graph\n    self._dependencies: dict[Token[object], set[Token[object]]] = defaultdict(set)\n\n    # Per-context overrides (DI_SPEC requirement)\n    self._overrides: ContextVar[dict[Token[object], object] | None] = ContextVar(\n        \"pyinj_overrides\",\n        default=None,\n    )\n\n    # Resolution stack is tracked via ContextVar (task-local)\n\n    # Fast type-to-token index for O(1) resolution by type\n    self._type_index: dict[type[object], Token[object]] = {}\n    # Container-level cleanup stacks for singleton context-managed resources\n    self._singleton_cleanup_sync: list[Callable[[], None]] = []\n    self._singleton_cleanup_async: list[Callable[[], Awaitable[None]]] = []\n\n    # Auto-register classes marked with Injectable metaclass (plain DI)\n    self._auto_register()\n</code></pre>"},{"location":"api/#pyinj.Container.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Async close: close tracked resources and clear caches.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"Async close: close tracked resources and clear caches.\"\"\"\n    await self.__aexit__(None, None, None)\n    self.clear()\n</code></pre>"},{"location":"api/#pyinj.Container.aget","title":"<code>aget(token)</code>  <code>async</code>","text":"<p>Resolve a dependency asynchronously.</p> <p>Equivalent to :meth:<code>get</code> but awaits async providers and uses async locks for singleton initialization.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def aget(self, token: Token[U] | type[U]) -&gt; U:\n    \"\"\"Resolve a dependency asynchronously.\n\n    Equivalent to :meth:`get` but awaits async providers and uses\n    async locks for singleton initialization.\n    \"\"\"\n    # Convert to token if needed\n    if isinstance(token, type):\n        given = self.resolve_given(token)\n        if given is not None:\n            return given\n    token = self._coerce_to_token(token)\n    token = self._canonicalize(token)\n\n    # Check per-context overrides first\n    override = self._get_override(token)\n    if override is not None:\n        self._cache_hits += 1\n        return override\n\n    # Check context first\n    instance = self.resolve_from_context(token)\n    if instance is not None:\n        self._cache_hits += 1\n        return instance\n\n    self._cache_misses += 1\n\n    with self._resolution_guard(token):\n        obj_token = cast(Token[object], token)\n        reg = self._registrations.get(obj_token)\n        effective_scope = self._get_scope(token)\n        if reg and reg.cleanup is CleanupMode.CONTEXT_ASYNC:\n            if effective_scope == Scope.SINGLETON:\n                lock = self._ensure_async_lock(token)\n                async with lock:\n                    cached = self._get_singleton_cached(token)\n                    if cached is not None:\n                        return cached\n                    cm = reg.provider()\n                    value = await cm.__aenter__()\n                    self._set_singleton_cached(token, value)\n                    self._singleton_cleanup_async.append(lambda cm=cm: cm.__aexit__(None, None, None))\n                    self._resources.append(value)\n                    return cast(U, value)\n            else:\n                cm = reg.provider()\n                value = await cm.__aenter__()\n                self.store_in_context(token, value)\n                if effective_scope == Scope.REQUEST:\n                    self._register_request_cleanup_async(lambda cm=cm: cm.__aexit__(None, None, None))\n                elif effective_scope == Scope.SESSION:\n                    self._register_session_cleanup_async(lambda cm=cm: cm.__aexit__(None, None, None))\n                self._resources.append(value)\n                return cast(U, value)\n\n        # fallback legacy providers\n        provider = self._get_provider(token)\n        if effective_scope == Scope.SINGLETON:\n            lock = self._ensure_async_lock(token)\n            async with lock:\n                cached = self._get_singleton_cached(token)\n                if cached is not None:\n                    return cached\n\n                if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                    instance = await cast(ProviderAsync[U], provider)()\n                else:\n                    instance = cast(ProviderSync[U], provider)()\n                self._validate_and_track(token, instance)\n                self._set_singleton_cached(token, instance)\n                return instance\n        else:\n            if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                instance = await cast(ProviderAsync[U], provider)()\n            else:\n                instance = cast(ProviderSync[U], provider)()\n            self._validate_and_track(token, instance)\n            if effective_scope in (Scope.REQUEST, Scope.SESSION):\n                self.store_in_context(token, instance)\n            return instance\n</code></pre>"},{"location":"api/#pyinj.Container.batch_register","title":"<code>batch_register(registrations)</code>","text":"<p>Register multiple dependencies at once.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def batch_register(\n    self, registrations: list[tuple[Token[object], ProviderLike[object]]]\n) -&gt; Container:\n    \"\"\"Register multiple dependencies at once.\"\"\"\n    for token, provider in registrations:\n        self.register(token, provider)\n    return self\n</code></pre>"},{"location":"api/#pyinj.Container.batch_resolve","title":"<code>batch_resolve(tokens)</code>","text":"<p>Resolve multiple dependencies efficiently (sync).</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def batch_resolve(self, tokens: list[Token[object]]) -&gt; dict[Token[object], object]:\n    \"\"\"Resolve multiple dependencies efficiently (sync).\"\"\"\n    sorted_tokens = sorted(tokens, key=lambda t: t.scope.value)\n    results: dict[Token[object], object] = {}\n    for _scope, group in groupby(sorted_tokens, key=lambda t: t.scope):\n        group_list = list(group)\n        for tk in group_list:\n            results[tk] = self.get(tk)\n    return results\n</code></pre>"},{"location":"api/#pyinj.Container.batch_resolve_async","title":"<code>batch_resolve_async(tokens)</code>  <code>async</code>","text":"<p>Async batch resolution with parallel execution.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def batch_resolve_async(\n    self, tokens: list[Token[object]]\n) -&gt; dict[Token[object], object]:\n    \"\"\"Async batch resolution with parallel execution.\"\"\"\n    tasks = {token: self.aget(token) for token in tokens}\n    results_list: list[object] = await asyncio.gather(*tasks.values())\n    return dict(zip(tasks.keys(), results_list, strict=True))\n</code></pre>"},{"location":"api/#pyinj.Container.clear","title":"<code>clear()</code>","text":"<p>Clear caches and statistics; keep provider registrations intact.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear caches and statistics; keep provider registrations intact.\"\"\"\n    with self._lock:\n        self._singletons.clear()\n        self._transients.clear()\n        self._given_providers.clear()\n        self._dependencies.clear()\n        self._cache_hits = 0\n        self._cache_misses = 0\n        self._resolution_times.clear()\n    self.clear_all_contexts()\n</code></pre>"},{"location":"api/#pyinj.Container.clear_overrides","title":"<code>clear_overrides()</code>","text":"<p>Clear all overrides for the current context.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def clear_overrides(self) -&gt; None:\n    \"\"\"Clear all overrides for the current context.\"\"\"\n    if self._overrides.get() is not None:\n        self._overrides.set(None)\n</code></pre>"},{"location":"api/#pyinj.Container.dispose","title":"<code>dispose()</code>  <code>async</code>","text":"<p>Alias for aclose to align with tests and docs.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def dispose(self) -&gt; None:\n    \"\"\"Alias for aclose to align with tests and docs.\"\"\"\n    await self.aclose()\n</code></pre>"},{"location":"api/#pyinj.Container.get","title":"<code>get(token)</code>","text":"<p>Resolve a dependency synchronously.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[U] | type[U]</code> <p>The <code>Token[T]</code> or <code>type[T]</code> to resolve.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resolved instance.</p> <p>Raises:</p> Type Description <code>ResolutionError</code> <p>If no provider is registered or resolution fails.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def get(self, token: Token[U] | type[U]) -&gt; U:\n    \"\"\"Resolve a dependency synchronously.\n\n    Args:\n        token: The ``Token[T]`` or ``type[T]`` to resolve.\n\n    Returns:\n        The resolved instance.\n\n    Raises:\n        ResolutionError: If no provider is registered or resolution fails.\n    \"\"\"\n    # Convert to token if needed and handle givens\n    if isinstance(token, type):\n        given = self.resolve_given(token)\n        if given is not None:\n            return given\n    token = self._coerce_to_token(token)\n    token = self._canonicalize(token)\n\n    # Check per-context overrides first\n    override = self._get_override(token)\n    if override is not None:\n        self._cache_hits += 1\n        return override\n\n    # Check context first (for request/session stored instances)\n    instance = self.resolve_from_context(token)\n    if instance is not None:\n        self._cache_hits += 1\n        return instance\n\n    self._cache_misses += 1\n\n    with self._resolution_guard(token):\n        obj_token = cast(Token[object], token)\n        reg = self._registrations.get(obj_token)\n        effective_scope = self._get_scope(token)\n        if reg and reg.cleanup is CleanupMode.CONTEXT_ASYNC:\n            # cannot enter async context in sync path\n            raise ResolutionError(\n                token,\n                [],\n                \"Context-managed provider is async; Use aget() for async providers\",\n            )\n        if reg and reg.cleanup is CleanupMode.CONTEXT_SYNC:\n            # handle context-managed sync\n            if effective_scope == Scope.SINGLETON:\n                with self._singleton_locks[self._obj_token(token)]:\n                    cached = self._get_singleton_cached(token)\n                    if cached is not None:\n                        return cached\n                    cm = reg.provider()\n                    value = cm.__enter__()\n                    self._set_singleton_cached(token, value)\n                    # schedule cleanup\n                    self._singleton_cleanup_sync.append(lambda cm=cm: cm.__exit__(None, None, None))\n                    self._resources.append(value)\n                    return cast(U, value)\n            else:\n                cm = reg.provider()\n                value = cm.__enter__()\n                self.store_in_context(token, value)\n                # register per-scope cleanup\n                if effective_scope == Scope.REQUEST:\n                    self._register_request_cleanup_sync(lambda cm=cm: cm.__exit__(None, None, None))\n                elif effective_scope == Scope.SESSION:\n                    self._register_session_cleanup_sync(lambda cm=cm: cm.__exit__(None, None, None))\n                self._resources.append(value)\n                return cast(U, value)\n\n        provider = self._get_provider(token)\n        # legacy non-context providers\n        if effective_scope == Scope.SINGLETON:\n            with self._singleton_locks[self._obj_token(token)]:\n                cached = self._get_singleton_cached(token)\n                if cached is not None:\n                    return cached\n                if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                    raise ResolutionError(\n                        token,\n                        [],\n                        \"Provider is async; Use aget() for async providers\",\n                    )\n                instance = cast(ProviderSync[U], provider)()\n                self._validate_and_track(token, instance)\n                self._set_singleton_cached(token, instance)\n                return instance\n        else:\n            if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                raise ResolutionError(\n                    token,\n                    [],\n                    \"Provider is async; Use aget() for async providers\",\n                )\n            instance = cast(ProviderSync[U], provider)()\n            self._validate_and_track(token, instance)\n            # Only store in context for REQUEST/SESSION\n            if effective_scope in (Scope.REQUEST, Scope.SESSION):\n                self.store_in_context(token, instance)\n            return instance\n</code></pre>"},{"location":"api/#pyinj.Container.get_providers_view","title":"<code>get_providers_view()</code>","text":"<p>Return a read-only view of registered providers.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def get_providers_view(\n    self,\n) -&gt; MappingProxyType[Token[object], ProviderLike[object]]:\n    \"\"\"Return a read-only view of registered providers.\"\"\"\n    return MappingProxyType(self._providers)\n</code></pre>"},{"location":"api/#pyinj.Container.given","title":"<code>given(type_, provider)</code>","text":"<p>Register a given instance for a type (Scala-style).</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def given(self, type_: type[U], provider: ProviderSync[U] | U) -&gt; \"Container\":\n    \"\"\"Register a given instance for a type (Scala-style).\"\"\"\n    if callable(provider):\n        self._given_providers[type_] = cast(ProviderSync[object], provider)\n    else:\n        # Wrap value in lambda\n        self._given_providers[type_] = lambda p=provider: p\n\n    return self\n</code></pre>"},{"location":"api/#pyinj.Container.has","title":"<code>has(token)</code>","text":"<p>Return True if the token/type is known to the container.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def has(self, token: Token[Any] | type[Any]) -&gt; bool:\n    \"\"\"Return True if the token/type is known to the container.\"\"\"\n    if isinstance(token, type):\n        if token in self._given_providers:\n            return True\n        token = Token(token.__name__, token)\n    obj_token = cast(Token[object], token)\n    return obj_token in self._providers or obj_token in self._singletons\n</code></pre>"},{"location":"api/#pyinj.Container.inject","title":"<code>inject(func=None, *, cache=True)</code>","text":"<p>Alias to pyinj.injection.inject bound to this container.</p> <p>Enables <code>@container.inject</code> usage in addition to <code>@inject(container=container)</code>.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def inject(\n    self, func: Callable[..., Any] | None = None, *, cache: bool = True\n) -&gt; Callable[..., Any]:\n    \"\"\"Alias to pyinj.injection.inject bound to this container.\n\n    Enables ``@container.inject`` usage in addition to\n    ``@inject(container=container)``.\n    \"\"\"\n    from .injection import inject as _inject\n\n    if func is None:\n        return _inject(container=self, cache=cache)\n    return _inject(func, container=self, cache=cache)\n</code></pre>"},{"location":"api/#pyinj.Container.override","title":"<code>override(token, value)</code>","text":"<p>Override a dependency for the current concurrent context only.</p> <p>Uses a ContextVar-backed mapping so overrides are isolated between threads/tasks. Prefer <code>use_overrides</code> for scoped overrides.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def override(self, token: Token[U], value: U) -&gt; None:\n    \"\"\"Override a dependency for the current concurrent context only.\n\n    Uses a ContextVar-backed mapping so overrides are isolated between\n    threads/tasks. Prefer ``use_overrides`` for scoped overrides.\n    \"\"\"\n    parent = self._overrides.get()\n    merged: dict[Token[object], object] = dict(parent) if parent else {}\n    merged[cast(Token[object], token)] = value\n    self._overrides.set(merged)\n</code></pre>"},{"location":"api/#pyinj.Container.register","title":"<code>register(token, provider, scope=None, *, tags=())</code>","text":"<p>Register a provider for a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[U] | type[U]</code> <p>A <code>Token[T]</code> or a concrete <code>type[T]</code>. If a type is provided, a token is created automatically.</p> required <code>provider</code> <code>ProviderLike[U]</code> <p>Callable that returns the dependency instance.</p> required <code>scope</code> <code>Scope | None</code> <p>Optional lifecycle override (defaults to token.scope or TRANSIENT).</p> <code>None</code> <code>tags</code> <code>tuple[str, ...]</code> <p>Optional tags for discovery/metadata.</p> <code>()</code> <p>Returns:</p> Type Description <code>'Container'</code> <p>Self, to allow method chaining.</p> Example <p>container.register(TokenDB, create_db, scope=Scope.SINGLETON)</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register(\n    self,\n    token: Token[U] | type[U],\n    provider: ProviderLike[U],\n    scope: Scope | None = None,\n    *,\n    tags: tuple[str, ...] = (),\n) -&gt; \"Container\":\n    \"\"\"Register a provider for a token.\n\n    Args:\n        token: A ``Token[T]`` or a concrete ``type[T]``. If a type is\n            provided, a token is created automatically.\n        provider: Callable that returns the dependency instance.\n        scope: Optional lifecycle override (defaults to token.scope or TRANSIENT).\n        tags: Optional tags for discovery/metadata.\n\n    Returns:\n        Self, to allow method chaining.\n\n    Example:\n        container.register(Token[DB](\"db\"), create_db, scope=Scope.SINGLETON)\n    \"\"\"\n    # Validate token type\n    if not isinstance(token, (Token, type)):\n        raise TypeError(\n            \"Token specification must be a Token or type; strings are not supported\"\n        )\n\n    # Convert to Token if needed\n    if isinstance(token, type):\n        token = self.tokens.create(\n            token.__name__, token, scope=scope or Scope.TRANSIENT, tags=tags\n        )\n    elif scope is not None:\n        # Record desired scope without changing the token identity\n        self._token_scopes[cast(Token[object], token)] = scope\n\n    # Validate provider\n    if not callable(provider):\n        raise TypeError(\n            f\"Provider must be callable, got {type(provider).__name__}\\n\"\n            f\"  Fix: Pass a function or lambda that returns an instance\\n\"\n            f\"  Example: container.register(token, lambda: {token.type_.__name__}())\"\n        )\n\n    with self._lock:\n        obj_token = cast(Token[object], token)\n        # Enforce immutable registrations\n        if obj_token in self._providers or obj_token in self._registrations or obj_token in self._singletons:\n            raise ValueError(f\"Token '{obj_token.name}' is already registered\")\n        self._providers[obj_token] = cast(ProviderLike[object], provider)\n        self._registrations[obj_token] = _Registration(\n            provider=cast(Callable[[], Any], provider), cleanup=CleanupMode.NONE\n        )\n        # Update type index\n        self._type_index[obj_token.type_] = obj_token\n\n    return self  # Enable chaining\n</code></pre>"},{"location":"api/#pyinj.Container.register_context","title":"<code>register_context(token, cm_provider, *, is_async, scope=None)</code>","text":"<pre><code>register_context(token: Token[U] | type[U], cm_provider: Callable[[], ContextManager[U]], *, is_async: Literal[False], scope: Scope | None = None) -&gt; 'Container'\n</code></pre><pre><code>register_context(token: Token[U] | type[U], cm_provider: Callable[[], AsyncContextManager[U]], *, is_async: Literal[True], scope: Scope | None = None) -&gt; 'Container'\n</code></pre> <p>Register a context-managed dependency.</p> <ul> <li>When <code>is_async=False</code>, <code>cm_provider</code> must return a <code>ContextManager[T]</code>.</li> <li>When <code>is_async=True</code>, <code>cm_provider</code> must return an <code>AsyncContextManager[T]</code>.</li> </ul> <p>The context is entered on first resolution within the declared scope and exited during scope cleanup (request/session), or on container close for singletons.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_context(\n    self,\n    token: Token[U] | type[U],\n    cm_provider: Callable[[], Any],\n    *,\n    is_async: bool,\n    scope: Scope | None = None,\n) -&gt; \"Container\":\n    \"\"\"Register a context-managed dependency.\n\n    - When ``is_async=False``, ``cm_provider`` must return a ``ContextManager[T]``.\n    - When ``is_async=True``, ``cm_provider`` must return an ``AsyncContextManager[T]``.\n\n    The context is entered on first resolution within the declared scope and\n    exited during scope cleanup (request/session), or on container close for\n    singletons.\n    \"\"\"\n    # Validate token\n    if not isinstance(token, (Token, type)):\n        raise TypeError(\n            \"Token specification must be a Token or type; strings are not supported\"\n        )\n    # To token\n    if isinstance(token, type):\n        token = self.tokens.create(token.__name__, token, scope=scope or Scope.TRANSIENT)\n    elif scope is not None:\n        self._token_scopes[cast(Token[object], token)] = scope\n\n    if not callable(cm_provider):\n        raise TypeError(\"cm_provider must be callable and return a (async) context manager\")\n\n    with self._lock:\n        obj_token = cast(Token[object], token)\n        # Enforce immutable registrations\n        if obj_token in self._providers or obj_token in self._registrations or obj_token in self._singletons:\n            raise ValueError(f\"Token '{obj_token.name}' is already registered\")\n        self._registrations[obj_token] = _Registration(\n            provider=cm_provider,\n            cleanup=CleanupMode.CONTEXT_ASYNC if is_async else CleanupMode.CONTEXT_SYNC,\n        )\n        self._type_index[obj_token.type_] = obj_token\n    return self\n</code></pre>"},{"location":"api/#pyinj.Container.register_context_async","title":"<code>register_context_async(token, cm_provider, *, scope=None)</code>","text":"<p>Typed helper to register an async context-managed provider.</p> <p>Equivalent to <code>register_context(..., is_async=True)</code>.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_context_async(\n    self,\n    token: Token[U] | type[U],\n    cm_provider: Callable[[], AsyncContextManager[U]],\n    *,\n    scope: Scope | None = None,\n) -&gt; \"Container\":\n    \"\"\"Typed helper to register an async context-managed provider.\n\n    Equivalent to ``register_context(..., is_async=True)``.\n    \"\"\"\n    return self.register_context(token, cm_provider, is_async=True, scope=scope)\n</code></pre>"},{"location":"api/#pyinj.Container.register_context_sync","title":"<code>register_context_sync(token, cm_provider, *, scope=None)</code>","text":"<p>Typed helper to register a sync context-managed provider.</p> <p>Equivalent to <code>register_context(..., is_async=False)</code>.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_context_sync(\n    self,\n    token: Token[U] | type[U],\n    cm_provider: Callable[[], ContextManager[U]],\n    *,\n    scope: Scope | None = None,\n) -&gt; \"Container\":\n    \"\"\"Typed helper to register a sync context-managed provider.\n\n    Equivalent to ``register_context(..., is_async=False)``.\n    \"\"\"\n    return self.register_context(token, cm_provider, is_async=False, scope=scope)\n</code></pre>"},{"location":"api/#pyinj.Container.register_request","title":"<code>register_request(token, provider)</code>","text":"<p>Register a request-scoped dependency.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_request(\n    self, token: Token[U] | type[U], provider: ProviderLike[U]\n) -&gt; \"Container\":\n    \"\"\"Register a request-scoped dependency.\"\"\"\n    return self.register(token, provider, scope=Scope.REQUEST)\n</code></pre>"},{"location":"api/#pyinj.Container.register_singleton","title":"<code>register_singleton(token, provider)</code>","text":"<p>Register a singleton-scoped dependency.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_singleton(\n    self, token: Token[U] | type[U], provider: ProviderLike[U]\n) -&gt; \"Container\":\n    \"\"\"Register a singleton-scoped dependency.\"\"\"\n    return self.register(token, provider, scope=Scope.SINGLETON)\n</code></pre>"},{"location":"api/#pyinj.Container.register_transient","title":"<code>register_transient(token, provider)</code>","text":"<p>Register a transient-scoped dependency.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_transient(\n    self, token: Token[U] | type[U], provider: ProviderLike[U]\n) -&gt; \"Container\":\n    \"\"\"Register a transient-scoped dependency.\"\"\"\n    return self.register(token, provider, scope=Scope.TRANSIENT)\n</code></pre>"},{"location":"api/#pyinj.Container.register_value","title":"<code>register_value(token, value)</code>","text":"<p>Register a pre-created value as a singleton.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_value(self, token: Token[U] | type[U], value: U) -&gt; \"Container\":\n    \"\"\"Register a pre-created value as a singleton.\"\"\"\n    if isinstance(token, type):\n        token = self.tokens.singleton(token.__name__, token)\n    # token is now a Token[Any]\n\n    # Store directly as singleton (immutable)\n    obj_token = cast(Token[object], token)\n    if obj_token in self._providers or obj_token in self._registrations or obj_token in self._singletons:\n        raise ValueError(f\"Token '{obj_token.name}' is already registered\")\n    self._singletons[obj_token] = value\n    return self\n</code></pre>"},{"location":"api/#pyinj.Container.resolve_given","title":"<code>resolve_given(type_)</code>","text":"<p>Resolve a given instance by type.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def resolve_given(self, type_: type[U]) -&gt; U | None:\n    \"\"\"Resolve a given instance by type.\"\"\"\n    provider = self._given_providers.get(type_)\n    if provider:\n        return cast(ProviderSync[U], provider)()\n    return None\n</code></pre>"},{"location":"api/#pyinj.Container.resources_view","title":"<code>resources_view()</code>","text":"<p>Return a read-only snapshot of tracked resources for tests/inspection.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def resources_view(self) -&gt; tuple[SupportsClose | SupportsAsyncClose, ...]:\n    \"\"\"Return a read-only snapshot of tracked resources for tests/inspection.\"\"\"\n    return tuple(self._resources)\n</code></pre>"},{"location":"api/#pyinj.Container.use_overrides","title":"<code>use_overrides(mapping)</code>","text":"<p>Temporarily override tokens for this concurrent context.</p> Example <p>with container.use_overrides({LOGGER: fake_logger}):     svc = container.get(SERVICE)     ...</p> Source code in <code>src/pyinj/container.py</code> <pre><code>@contextmanager\ndef use_overrides(self, mapping: dict[Token[Any], object]) -&gt; Iterator[None]:\n    \"\"\"Temporarily override tokens for this concurrent context.\n\n    Example:\n        with container.use_overrides({LOGGER: fake_logger}):\n            svc = container.get(SERVICE)\n            ...\n    \"\"\"\n    parent = self._overrides.get()\n    merged: dict[Token[object], object] = dict(parent) if parent else {}\n    merged.update(cast(dict[Token[object], object], mapping))\n    token: CtxToken[dict[Token[object], object] | None] = self._overrides.set(\n        merged\n    )\n    try:\n        yield\n    finally:\n        self._overrides.reset(token)\n</code></pre>"},{"location":"api/#pyinj.Container.using","title":"<code>using(mapping=None, **givens)</code>","text":"<p>Temporarily register \"given\" instances for the current block.</p> <p>Supports both an explicit mapping of types to instances and keyword arguments that match type names previously registered via <code>given()</code>.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>@contextmanager\ndef using(\n    self,\n    mapping: Mapping[type[object], object] | None = None,\n    **givens: object,\n) -&gt; Iterator[Container]:\n    \"\"\"Temporarily register \"given\" instances for the current block.\n\n    Supports both an explicit mapping of types to instances and\n    keyword arguments that match type names previously registered\n    via ``given()``.\n    \"\"\"\n    old_givens = self._given_providers.copy()\n\n    # Apply explicit mapping first (precise and type-safe)\n    if mapping:\n        for t, instance in mapping.items():\n            self.given(t, instance)\n\n    # Support kwargs by matching on type name for already-known givens\n    if givens:\n        known_types = list(self._given_providers.keys())\n        for name, instance in givens.items():\n            for t in known_types:\n                if getattr(t, \"__name__\", \"\") == name:\n                    self.given(t, instance)\n                    break\n\n    try:\n        yield self\n    finally:\n        self._given_providers = old_givens\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer","title":"<code>ContextualContainer</code>","text":"<p>Base container adding request/session context via <code>contextvars</code>.</p> <p>Context flows implicitly across awaits; request/session lifetimes are enforced by the :class:<code>ScopeManager</code>.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>class ContextualContainer:\n    \"\"\"Base container adding request/session context via ``contextvars``.\n\n    Context flows implicitly across awaits; request/session lifetimes\n    are enforced by the :class:`ScopeManager`.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize contextual container.\"\"\"\n        # Singleton cache (process-wide)\n        self._singletons: dict[Token[object], object] = {}\n\n        # Weak cache for transients (auto-cleanup)\n        self._transients: WeakValueDictionary[Token[object], object] = (\n            WeakValueDictionary()\n        )\n\n        # Providers registry (value type depends on concrete container)\n        self._providers: dict[Token[object], Any] = {}\n\n        # Async locks for thread-safe singleton creation\n        self._async_locks: dict[Token[object], asyncio.Lock] = {}\n\n        # Track resources for cleanup\n        from .protocols import SupportsAsyncClose, SupportsClose\n\n        self._resources: list[SupportsClose | SupportsAsyncClose] = []\n\n        # Scope manager (RAII contexts, precedence enforcement)\n        self._scope_manager = ScopeManager(self)\n\n    # ---- Registration of per-scope cleanup operations (used by Container) ----\n\n    def _register_request_cleanup_sync(self, fn: Callable[[], None]) -&gt; None:\n        \"\"\"Register a sync cleanup for the current request scope.\n\n        Internal API called by the container when a sync context-managed resource\n        is entered within a request scope. Cleanups run in LIFO order on scope exit.\n        \"\"\"\n        stack = _request_cleanup_sync.get()\n        if stack is None:\n            raise RuntimeError(\"No active request scope for registering cleanup\")\n        stack.append(fn)\n\n    def _register_request_cleanup_async(\n        self, fn: Callable[[], Awaitable[None]]\n    ) -&gt; None:\n        \"\"\"Register an async cleanup for the current request scope.\n\n        Internal API called by the container for async context-managed resources.\n        Cleanups run before sync cleanups on async scope exit.\n        \"\"\"\n        stack = _request_cleanup_async.get()\n        if stack is None:\n            raise RuntimeError(\"No active request scope for registering async cleanup\")\n        stack.append(fn)\n\n    def _register_session_cleanup_sync(self, fn: Callable[[], None]) -&gt; None:\n        \"\"\"Register a sync cleanup for the active session scope.\n\n        Internal API used for session-scoped sync context-managed resources.\n        \"\"\"\n        stack = _session_cleanup_sync.get()\n        if stack is None:\n            raise RuntimeError(\"No active session scope for registering cleanup\")\n        stack.append(fn)\n\n    def _register_session_cleanup_async(\n        self, fn: Callable[[], Awaitable[None]]\n    ) -&gt; None:\n        \"\"\"Register an async cleanup for the active session scope.\n\n        Internal API used for session-scoped async context-managed resources.\n        \"\"\"\n        stack = _session_cleanup_async.get()\n        if stack is None:\n            raise RuntimeError(\"No active session scope for registering async cleanup\")\n        stack.append(fn)\n\n    def _put_in_current_request_cache(self, token: Token[T], instance: T) -&gt; None:\n        \"\"\"Insert a value into the current request cache unconditionally.\n\n        This bypasses scope checks and is intended for temporary overrides\n        that should only affect the current context.\n        \"\"\"\n        context = _context_stack.get()\n        if context is not None and hasattr(context, \"maps\") and len(context.maps) &gt; 0:\n            # The top-most map holds request-local values\n            context.maps[0][cast(Token[object], token)] = cast(object, instance)\n\n    @contextmanager\n    def request_scope(self) -&gt; Iterator[ContextualContainer]:\n        \"\"\"Create a request scope (similar to a web request lifecycle).\n\n        Example:\n            with container.request_scope():\n                service = container.get(ServiceToken)\n\n        Yields:\n            Self for chaining.\n        \"\"\"\n        with self._scope_manager.request_scope():\n            yield self\n\n    @asynccontextmanager\n    async def async_request_scope(self) -&gt; AsyncIterator[ContextualContainer]:\n        \"\"\"Async context manager variant of :meth:`request_scope`.\n\n        Example:\n            async with container.async_request_scope():\n                service = await container.aget(ServiceToken)\n        \"\"\"\n        async with self._scope_manager.async_request_scope():\n            yield self\n\n    @contextmanager\n    def session_scope(self) -&gt; Iterator[ContextualContainer]:\n        \"\"\"\n        Create a session scope (longer-lived than request).\n\n        Session scopes persist across multiple requests but are\n        isolated between different sessions (e.g., users).\n        \"\"\"\n        with self._scope_manager.session_scope():\n            yield self\n\n    def _cleanup_scope(self, cache: dict[Token[object], Any]) -&gt; None:\n        \"\"\"\n        Clean up resources in LIFO order.\n\n        Args:\n            cache: Cache of resources to clean up\n        \"\"\"\n        for resource in reversed(list(cache.values())):\n            try:\n                # Early fail if async cleanup is required in a sync context\n                aclose = getattr(resource, \"aclose\", None)\n                aexit = getattr(resource, \"__aexit__\", None)\n                supports_sync = hasattr(resource, \"close\") or hasattr(\n                    resource, \"__exit__\"\n                )\n                if (\n                    (aclose and inspect.iscoroutinefunction(aclose))\n                    or (aexit and inspect.iscoroutinefunction(aexit))\n                ) and not supports_sync:\n                    raise AsyncCleanupRequiredError(\n                        type(resource).__name__,\n                        \"Use an async request/session scope.\",\n                    )\n                close = getattr(resource, \"close\", None)\n                if close is not None and inspect.iscoroutinefunction(close):\n                    raise AsyncCleanupRequiredError(\n                        type(resource).__name__,\n                        \"Use an async request/session scope.\",\n                    )\n                # Prefer context-manager exit over ad-hoc close for sync path\n                if hasattr(resource, \"__exit__\"):\n                    resource.__exit__(None, None, None)\n                elif close is not None:\n                    close()\n            except AsyncCleanupRequiredError:\n                raise\n            except Exception:\n                # Log but don't fail cleanup\n                pass\n\n    async def _async_cleanup_scope(self, cache: dict[Token[object], Any]) -&gt; None:\n        \"\"\"\n        Async cleanup of resources.\n\n        Args:\n            cache: Cache of resources to clean up\n        \"\"\"\n        tasks: list[Any] = []\n        loop = asyncio.get_running_loop()\n\n        for resource in reversed(list(cache.values())):\n            aclose = getattr(resource, \"aclose\", None)\n            if aclose and callable(aclose):\n                res = aclose()\n                if inspect.isawaitable(res):\n                    tasks.append(res)\n                    continue\n            aexit = getattr(resource, \"__aexit__\", None)\n            if aexit and callable(aexit):\n                res = aexit(None, None, None)\n                if inspect.isawaitable(res):\n                    tasks.append(res)\n                    continue\n            close = getattr(resource, \"close\", None)\n            if close:\n                if inspect.iscoroutinefunction(close):\n                    tasks.append(close())\n                else:\n                    tasks.append(loop.run_in_executor(None, close))\n\n        if tasks:\n            # Gather with return_exceptions to prevent one failure from stopping others\n            await asyncio.gather(*tasks, return_exceptions=True)\n\n    def resolve_from_context(self, token: Token[T]) -&gt; T | None:\n        \"\"\"\n        Resolve dependency from current context.\n\n        Args:\n            token: Token to resolve\n\n        Returns:\n            Resolved instance or None if not in context\n        \"\"\"\n        return self._scope_manager.resolve_from_context(token)\n\n    def store_in_context(self, token: Token[T], instance: T) -&gt; None:\n        \"\"\"\n        Store instance in appropriate context.\n\n        Args:\n            token: Token for the instance\n            instance: Instance to store\n        \"\"\"\n        self._scope_manager.store_in_context(token, instance)\n\n    def clear_request_context(self) -&gt; None:\n        \"\"\"Clear current request context.\"\"\"\n        self._scope_manager.clear_request_context()\n\n    def clear_session_context(self) -&gt; None:\n        \"\"\"Clear current session context.\"\"\"\n        self._scope_manager.clear_session_context()\n\n    def clear_all_contexts(self) -&gt; None:\n        \"\"\"Clear all contexts including singletons.\"\"\"\n        self._scope_manager.clear_all_contexts()\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.__init__","title":"<code>__init__()</code>","text":"<p>Initialize contextual container.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize contextual container.\"\"\"\n    # Singleton cache (process-wide)\n    self._singletons: dict[Token[object], object] = {}\n\n    # Weak cache for transients (auto-cleanup)\n    self._transients: WeakValueDictionary[Token[object], object] = (\n        WeakValueDictionary()\n    )\n\n    # Providers registry (value type depends on concrete container)\n    self._providers: dict[Token[object], Any] = {}\n\n    # Async locks for thread-safe singleton creation\n    self._async_locks: dict[Token[object], asyncio.Lock] = {}\n\n    # Track resources for cleanup\n    from .protocols import SupportsAsyncClose, SupportsClose\n\n    self._resources: list[SupportsClose | SupportsAsyncClose] = []\n\n    # Scope manager (RAII contexts, precedence enforcement)\n    self._scope_manager = ScopeManager(self)\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.async_request_scope","title":"<code>async_request_scope()</code>  <code>async</code>","text":"<p>Async context manager variant of :meth:<code>request_scope</code>.</p> Example <p>async with container.async_request_scope():     service = await container.aget(ServiceToken)</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>@asynccontextmanager\nasync def async_request_scope(self) -&gt; AsyncIterator[ContextualContainer]:\n    \"\"\"Async context manager variant of :meth:`request_scope`.\n\n    Example:\n        async with container.async_request_scope():\n            service = await container.aget(ServiceToken)\n    \"\"\"\n    async with self._scope_manager.async_request_scope():\n        yield self\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.clear_all_contexts","title":"<code>clear_all_contexts()</code>","text":"<p>Clear all contexts including singletons.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def clear_all_contexts(self) -&gt; None:\n    \"\"\"Clear all contexts including singletons.\"\"\"\n    self._scope_manager.clear_all_contexts()\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.clear_request_context","title":"<code>clear_request_context()</code>","text":"<p>Clear current request context.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def clear_request_context(self) -&gt; None:\n    \"\"\"Clear current request context.\"\"\"\n    self._scope_manager.clear_request_context()\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.clear_session_context","title":"<code>clear_session_context()</code>","text":"<p>Clear current session context.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def clear_session_context(self) -&gt; None:\n    \"\"\"Clear current session context.\"\"\"\n    self._scope_manager.clear_session_context()\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.request_scope","title":"<code>request_scope()</code>","text":"<p>Create a request scope (similar to a web request lifecycle).</p> Example <p>with container.request_scope():     service = container.get(ServiceToken)</p> <p>Yields:</p> Type Description <code>ContextualContainer</code> <p>Self for chaining.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>@contextmanager\ndef request_scope(self) -&gt; Iterator[ContextualContainer]:\n    \"\"\"Create a request scope (similar to a web request lifecycle).\n\n    Example:\n        with container.request_scope():\n            service = container.get(ServiceToken)\n\n    Yields:\n        Self for chaining.\n    \"\"\"\n    with self._scope_manager.request_scope():\n        yield self\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.resolve_from_context","title":"<code>resolve_from_context(token)</code>","text":"<p>Resolve dependency from current context.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[T]</code> <p>Token to resolve</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>Resolved instance or None if not in context</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def resolve_from_context(self, token: Token[T]) -&gt; T | None:\n    \"\"\"\n    Resolve dependency from current context.\n\n    Args:\n        token: Token to resolve\n\n    Returns:\n        Resolved instance or None if not in context\n    \"\"\"\n    return self._scope_manager.resolve_from_context(token)\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.session_scope","title":"<code>session_scope()</code>","text":"<p>Create a session scope (longer-lived than request).</p> <p>Session scopes persist across multiple requests but are isolated between different sessions (e.g., users).</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>@contextmanager\ndef session_scope(self) -&gt; Iterator[ContextualContainer]:\n    \"\"\"\n    Create a session scope (longer-lived than request).\n\n    Session scopes persist across multiple requests but are\n    isolated between different sessions (e.g., users).\n    \"\"\"\n    with self._scope_manager.session_scope():\n        yield self\n</code></pre>"},{"location":"api/#pyinj.ContextualContainer.store_in_context","title":"<code>store_in_context(token, instance)</code>","text":"<p>Store instance in appropriate context.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[T]</code> <p>Token for the instance</p> required <code>instance</code> <code>T</code> <p>Instance to store</p> required Source code in <code>src/pyinj/contextual.py</code> <pre><code>def store_in_context(self, token: Token[T], instance: T) -&gt; None:\n    \"\"\"\n    Store instance in appropriate context.\n\n    Args:\n        token: Token for the instance\n        instance: Instance to store\n    \"\"\"\n    self._scope_manager.store_in_context(token, instance)\n</code></pre>"},{"location":"api/#pyinj.Given","title":"<code>Given</code>","text":"<p>Scala-style given marker for implicit dependencies.</p> Usage <p>def handler(db: Given[Database]):     # db is resolved from given instances     ...</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>class Given:\n    \"\"\"\n    Scala-style given marker for implicit dependencies.\n\n    Usage:\n        def handler(db: Given[Database]):\n            # db is resolved from given instances\n            ...\n    \"\"\"\n\n    def __class_getitem__(cls, item: type[T]) -&gt; builtins.type[\"Inject[T]\"]:\n        \"\"\"Support Given[Type] syntax by delegating to Inject.\"\"\"\n        return Inject[item]\n</code></pre>"},{"location":"api/#pyinj.Given.__class_getitem__","title":"<code>__class_getitem__(item)</code>","text":"<p>Support Given[Type] syntax by delegating to Inject.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __class_getitem__(cls, item: type[T]) -&gt; builtins.type[\"Inject[T]\"]:\n    \"\"\"Support Given[Type] syntax by delegating to Inject.\"\"\"\n    return Inject[item]\n</code></pre>"},{"location":"api/#pyinj.Inject","title":"<code>Inject</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Marker for injected dependencies (similar to FastAPI's <code>Depends</code>).</p> Usage <p>def handler(db: Inject[Database]):     # db is auto-injected     ...</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>class Inject(Generic[T]):\n    \"\"\"\n    Marker for injected dependencies (similar to FastAPI's ``Depends``).\n\n    Usage:\n        def handler(db: Inject[Database]):\n            # db is auto-injected\n            ...\n\n        # Or with default provider\n        def handler(db: Inject[Database] = Inject(create_db)):\n            ...\n    \"\"\"\n\n    def __init__(self, provider: Callable[..., T] | None = None) -&gt; None:\n        \"\"\"\n        Initialize an injection marker optionally carrying a provider.\n\n        Args:\n            provider: Optional provider function\n        \"\"\"\n        self.provider = provider\n        self._type: type[T] | None = None\n\n    _typed_cache: ClassVar[dict[type[object], builtins.type]] = {}\n\n    def __class_getitem__(cls, item: builtins.type[T]) -&gt; builtins.type[\"Inject[T]\"]:\n        \"\"\"Support Inject[Type] syntax without recursion and with caching.\n\n        Returns a cached subclass carrying the injection type, so that\n        repeated references to Inject[T] are identical across calls.\n        \"\"\"\n        cached = cls._typed_cache.get(item)\n        if cached is not None:\n            return cached\n\n        name = f\"Inject_{getattr(item, '__name__', 'T')}\"\n        TypedInject = type(name, (cls,), {\"_inject_type\": item})\n        cls._typed_cache[item] = TypedInject\n        return tcast(builtins.type, TypedInject)\n\n    @property\n    def type(self) -&gt; builtins.type[T] | None:\n        \"\"\"Get the injected type if available.\"\"\"\n        t = getattr(self.__class__, \"_inject_type\", None)\n        if isinstance(t, type):\n            return t\n        return self._type\n\n    def set_type(self, type_: builtins.type[T]) -&gt; None:\n        \"\"\"Set the injected type explicitly (used by analyzers).\"\"\"\n        self._type = type_\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Readable representation.\"\"\"\n        if self.type:\n            return f\"Inject[{self.type.__name__}]\"\n        return \"Inject()\"\n</code></pre>"},{"location":"api/#pyinj.Inject--or-with-default-provider","title":"Or with default provider","text":"<p>def handler(db: Inject[Database] = Inject(create_db)):     ...</p>"},{"location":"api/#pyinj.Inject.type","title":"<code>type</code>  <code>property</code>","text":"<p>Get the injected type if available.</p>"},{"location":"api/#pyinj.Inject.__class_getitem__","title":"<code>__class_getitem__(item)</code>","text":"<p>Support Inject[Type] syntax without recursion and with caching.</p> <p>Returns a cached subclass carrying the injection type, so that repeated references to Inject[T] are identical across calls.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __class_getitem__(cls, item: builtins.type[T]) -&gt; builtins.type[\"Inject[T]\"]:\n    \"\"\"Support Inject[Type] syntax without recursion and with caching.\n\n    Returns a cached subclass carrying the injection type, so that\n    repeated references to Inject[T] are identical across calls.\n    \"\"\"\n    cached = cls._typed_cache.get(item)\n    if cached is not None:\n        return cached\n\n    name = f\"Inject_{getattr(item, '__name__', 'T')}\"\n    TypedInject = type(name, (cls,), {\"_inject_type\": item})\n    cls._typed_cache[item] = TypedInject\n    return tcast(builtins.type, TypedInject)\n</code></pre>"},{"location":"api/#pyinj.Inject.__init__","title":"<code>__init__(provider=None)</code>","text":"<p>Initialize an injection marker optionally carrying a provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>Callable[..., T] | None</code> <p>Optional provider function</p> <code>None</code> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __init__(self, provider: Callable[..., T] | None = None) -&gt; None:\n    \"\"\"\n    Initialize an injection marker optionally carrying a provider.\n\n    Args:\n        provider: Optional provider function\n    \"\"\"\n    self.provider = provider\n    self._type: type[T] | None = None\n</code></pre>"},{"location":"api/#pyinj.Inject.__repr__","title":"<code>__repr__()</code>","text":"<p>Readable representation.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Readable representation.\"\"\"\n    if self.type:\n        return f\"Inject[{self.type.__name__}]\"\n    return \"Inject()\"\n</code></pre>"},{"location":"api/#pyinj.Inject.set_type","title":"<code>set_type(type_)</code>","text":"<p>Set the injected type explicitly (used by analyzers).</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def set_type(self, type_: builtins.type[T]) -&gt; None:\n    \"\"\"Set the injected type explicitly (used by analyzers).\"\"\"\n    self._type = type_\n</code></pre>"},{"location":"api/#pyinj.Injectable","title":"<code>Injectable</code>","text":"<p>               Bases: <code>ABCMeta</code></p> <p>Metaclass for automatic dependency registration.</p> <p>Classes using this metaclass can be automatically registered in the container by setting class attributes:</p> Example <p>class DatabaseService(metaclass=Injectable):     injectable = True     token_name = \"database\"     scope = Scope.SINGLETON</p> Source code in <code>src/pyinj/metaclasses.py</code> <pre><code>class Injectable(ABCMeta):\n    \"\"\"Metaclass for automatic dependency registration.\n\n    Classes using this metaclass can be automatically registered in\n    the container by setting class attributes:\n\n    Example:\n        class DatabaseService(metaclass=Injectable):\n            __injectable__ = True\n            __token_name__ = \"database\"\n            __scope__ = Scope.SINGLETON\n    \"\"\"\n\n    _registry: ClassVar[dict[type[Any], Token[Any]]] = {}\n\n    def __new__(\n        mcs,\n        name: str,\n        bases: tuple[type, ...],\n        namespace: dict[str, Any],\n        **kwargs: Any,\n    ) -&gt; Injectable:\n        \"\"\"Create a new class and optionally register it for injection.\n\n        Args:\n            name: The class name\n            bases: Base classes\n            namespace: Class namespace dictionary\n            **kwargs: Additional keyword arguments\n\n        Returns:\n            The newly created class\n        \"\"\"\n        cls = super().__new__(mcs, name, bases, namespace)\n\n        # Only register if explicitly marked as injectable\n        if namespace.get(\"__injectable__\", False):\n            token_name = namespace.get(\"__token_name__\", name.lower())\n            if not isinstance(token_name, str):\n                token_name = str(token_name)\n            scope_val = namespace.get(\"__scope__\", Scope.TRANSIENT)\n            scope = scope_val if isinstance(scope_val, Scope) else Scope.TRANSIENT\n\n            # Create type-safe token\n            token = Token(name=token_name, type_=cls)\n\n            # Store in registry\n            mcs._registry[cls] = token\n\n            # Add metadata to class\n            cls.__token__ = token  # type: ignore[attr-defined]\n            cls.__scope__ = scope  # type: ignore[attr-defined]\n\n        return cls\n\n    @classmethod\n    def get_registry(cls) -&gt; dict[type[Any], Token[Any]]:\n        \"\"\"Get a copy of the injection registry.\n\n        Returns:\n            Dictionary mapping class types to their tokens\n        \"\"\"\n        return cls._registry.copy()\n</code></pre>"},{"location":"api/#pyinj.Injectable.__new__","title":"<code>__new__(mcs, name, bases, namespace, **kwargs)</code>","text":"<p>Create a new class and optionally register it for injection.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The class name</p> required <code>bases</code> <code>tuple[type, ...]</code> <p>Base classes</p> required <code>namespace</code> <code>dict[str, Any]</code> <p>Class namespace dictionary</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>Injectable</code> <p>The newly created class</p> Source code in <code>src/pyinj/metaclasses.py</code> <pre><code>def __new__(\n    mcs,\n    name: str,\n    bases: tuple[type, ...],\n    namespace: dict[str, Any],\n    **kwargs: Any,\n) -&gt; Injectable:\n    \"\"\"Create a new class and optionally register it for injection.\n\n    Args:\n        name: The class name\n        bases: Base classes\n        namespace: Class namespace dictionary\n        **kwargs: Additional keyword arguments\n\n    Returns:\n        The newly created class\n    \"\"\"\n    cls = super().__new__(mcs, name, bases, namespace)\n\n    # Only register if explicitly marked as injectable\n    if namespace.get(\"__injectable__\", False):\n        token_name = namespace.get(\"__token_name__\", name.lower())\n        if not isinstance(token_name, str):\n            token_name = str(token_name)\n        scope_val = namespace.get(\"__scope__\", Scope.TRANSIENT)\n        scope = scope_val if isinstance(scope_val, Scope) else Scope.TRANSIENT\n\n        # Create type-safe token\n        token = Token(name=token_name, type_=cls)\n\n        # Store in registry\n        mcs._registry[cls] = token\n\n        # Add metadata to class\n        cls.__token__ = token  # type: ignore[attr-defined]\n        cls.__scope__ = scope  # type: ignore[attr-defined]\n\n    return cls\n</code></pre>"},{"location":"api/#pyinj.Injectable.get_registry","title":"<code>get_registry()</code>  <code>classmethod</code>","text":"<p>Get a copy of the injection registry.</p> <p>Returns:</p> Type Description <code>dict[type[Any], Token[Any]]</code> <p>Dictionary mapping class types to their tokens</p> Source code in <code>src/pyinj/metaclasses.py</code> <pre><code>@classmethod\ndef get_registry(cls) -&gt; dict[type[Any], Token[Any]]:\n    \"\"\"Get a copy of the injection registry.\n\n    Returns:\n        Dictionary mapping class types to their tokens\n    \"\"\"\n    return cls._registry.copy()\n</code></pre>"},{"location":"api/#pyinj.PyInjError","title":"<code>PyInjError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all pyinj errors.</p> Source code in <code>src/pyinj/exceptions.py</code> <pre><code>class PyInjError(Exception):\n    \"\"\"Base exception for all pyinj errors.\"\"\"\n</code></pre>"},{"location":"api/#pyinj.RequestScope","title":"<code>RequestScope</code>","text":"<p>Helper class for request-scoped dependencies.</p> Example <p>async with RequestScope(container) as scope:     service = scope.resolve(ServiceToken)</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>class RequestScope:\n    \"\"\"\n    Helper class for request-scoped dependencies.\n\n    Example:\n        async with RequestScope(container) as scope:\n            service = scope.resolve(ServiceToken)\n    \"\"\"\n\n    def __init__(self, container: ContextualContainer):\n        \"\"\"Initialize request scope.\"\"\"\n        self.container = container\n        self._context_manager = None\n        self._async_context_manager = None\n\n    def __enter__(self) -&gt; RequestScope:\n        \"\"\"Enter request scope.\"\"\"\n        self._context_manager = self.container.request_scope()\n        self._context_manager.__enter__()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Exit request scope.\"\"\"\n        if self._context_manager:\n            self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n\n    async def __aenter__(self) -&gt; RequestScope:\n        \"\"\"Async enter request scope.\"\"\"\n        self._async_context_manager = self.container.async_request_scope()\n        await self._async_context_manager.__aenter__()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Async exit request scope.\"\"\"\n        if self._async_context_manager:\n            await self._async_context_manager.__aexit__(exc_type, exc_val, exc_tb)\n\n    def resolve(self, token: Token[T]) -&gt; T | None:\n        \"\"\"Resolve dependency in this scope.\"\"\"\n        return self.container.resolve_from_context(token)\n</code></pre>"},{"location":"api/#pyinj.RequestScope.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Async enter request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>async def __aenter__(self) -&gt; RequestScope:\n    \"\"\"Async enter request scope.\"\"\"\n    self._async_context_manager = self.container.async_request_scope()\n    await self._async_context_manager.__aenter__()\n    return self\n</code></pre>"},{"location":"api/#pyinj.RequestScope.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Async exit request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Async exit request scope.\"\"\"\n    if self._async_context_manager:\n        await self._async_context_manager.__aexit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.RequestScope.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __enter__(self) -&gt; RequestScope:\n    \"\"\"Enter request scope.\"\"\"\n    self._context_manager = self.container.request_scope()\n    self._context_manager.__enter__()\n    return self\n</code></pre>"},{"location":"api/#pyinj.RequestScope.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit request scope.\"\"\"\n    if self._context_manager:\n        self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.RequestScope.__init__","title":"<code>__init__(container)</code>","text":"<p>Initialize request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __init__(self, container: ContextualContainer):\n    \"\"\"Initialize request scope.\"\"\"\n    self.container = container\n    self._context_manager = None\n    self._async_context_manager = None\n</code></pre>"},{"location":"api/#pyinj.RequestScope.resolve","title":"<code>resolve(token)</code>","text":"<p>Resolve dependency in this scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def resolve(self, token: Token[T]) -&gt; T | None:\n    \"\"\"Resolve dependency in this scope.\"\"\"\n    return self.container.resolve_from_context(token)\n</code></pre>"},{"location":"api/#pyinj.ResolutionError","title":"<code>ResolutionError</code>","text":"<p>               Bases: <code>PyInjError</code></p> <p>Raised when a dependency cannot be resolved.</p> Source code in <code>src/pyinj/exceptions.py</code> <pre><code>class ResolutionError(PyInjError):\n    \"\"\"Raised when a dependency cannot be resolved.\"\"\"\n\n    def __init__(\n        self, token: \"Token[Any]\", chain: list[\"Token[Any]\"], cause: str\n    ) -&gt; None:\n        \"\"\"Initialize resolution error with context.\n\n        Args:\n            token: The token that couldn't be resolved\n            chain: The current resolution chain\n            cause: Human-readable cause description\n        \"\"\"\n        self.token = token\n        self.chain = chain\n        self.cause = cause\n\n        chain_str = \" -&gt; \".join(t.name for t in chain) if chain else \"root\"\n        super().__init__(\n            f\"Cannot resolve token '{token.name}':\\n\"\n            f\"  Resolution chain: {chain_str}\\n\"\n            f\"  Cause: {cause}\"\n        )\n</code></pre>"},{"location":"api/#pyinj.ResolutionError.__init__","title":"<code>__init__(token, chain, cause)</code>","text":"<p>Initialize resolution error with context.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>'Token[Any]'</code> <p>The token that couldn't be resolved</p> required <code>chain</code> <code>list['Token[Any]']</code> <p>The current resolution chain</p> required <code>cause</code> <code>str</code> <p>Human-readable cause description</p> required Source code in <code>src/pyinj/exceptions.py</code> <pre><code>def __init__(\n    self, token: \"Token[Any]\", chain: list[\"Token[Any]\"], cause: str\n) -&gt; None:\n    \"\"\"Initialize resolution error with context.\n\n    Args:\n        token: The token that couldn't be resolved\n        chain: The current resolution chain\n        cause: Human-readable cause description\n    \"\"\"\n    self.token = token\n    self.chain = chain\n    self.cause = cause\n\n    chain_str = \" -&gt; \".join(t.name for t in chain) if chain else \"root\"\n    super().__init__(\n        f\"Cannot resolve token '{token.name}':\\n\"\n        f\"  Resolution chain: {chain_str}\\n\"\n        f\"  Cause: {cause}\"\n    )\n</code></pre>"},{"location":"api/#pyinj.Scope","title":"<code>Scope</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Lifecycle scope for dependencies.</p> Values <p>SINGLETON: One instance for the process/container. REQUEST: One instance per request context. SESSION: One instance per longer-lived session context. TRANSIENT: A new instance for every resolution.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>class Scope(Enum):\n    \"\"\"Lifecycle scope for dependencies.\n\n    Values:\n        SINGLETON: One instance for the process/container.\n        REQUEST: One instance per request context.\n        SESSION: One instance per longer-lived session context.\n        TRANSIENT: A new instance for every resolution.\n    \"\"\"\n\n    SINGLETON = auto()  # Process-wide singleton\n    REQUEST = auto()  # Request/context scoped\n    SESSION = auto()  # Session scoped\n    TRANSIENT = auto()  # New instance every time\n</code></pre>"},{"location":"api/#pyinj.SessionScope","title":"<code>SessionScope</code>","text":"<p>Helper class for session-scoped dependencies.</p> Example <p>with SessionScope(container) as scope:     user = scope.resolve(UserToken)</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>class SessionScope:\n    \"\"\"\n    Helper class for session-scoped dependencies.\n\n    Example:\n        with SessionScope(container) as scope:\n            user = scope.resolve(UserToken)\n    \"\"\"\n\n    def __init__(self, container: ContextualContainer):\n        \"\"\"Initialize session scope.\"\"\"\n        self.container = container\n        self._context_manager = None\n\n    def __enter__(self) -&gt; SessionScope:\n        \"\"\"Enter session scope.\"\"\"\n        self._context_manager = self.container.session_scope()\n        self._context_manager.__enter__()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Exit session scope.\"\"\"\n        if self._context_manager:\n            self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.SessionScope.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter session scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __enter__(self) -&gt; SessionScope:\n    \"\"\"Enter session scope.\"\"\"\n    self._context_manager = self.container.session_scope()\n    self._context_manager.__enter__()\n    return self\n</code></pre>"},{"location":"api/#pyinj.SessionScope.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit session scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit session scope.\"\"\"\n    if self._context_manager:\n        self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.SessionScope.__init__","title":"<code>__init__(container)</code>","text":"<p>Initialize session scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __init__(self, container: ContextualContainer):\n    \"\"\"Initialize session scope.\"\"\"\n    self.container = container\n    self._context_manager = None\n</code></pre>"},{"location":"api/#pyinj.Token","title":"<code>Token</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Immutable, hashable identifier for a typed dependency.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Human-readable name for the binding.</p> required <code>type_</code> <code>type[T]</code> <p>The expected Python type of the dependency.</p> required <code>scope</code> <code>Scope</code> <p>Lifecycle scope. Defaults to TRANSIENT.</p> <code>TRANSIENT</code> <code>qualifier</code> <code>str | None</code> <p>Optional qualifier to differentiate multiple bindings of the same type.</p> <code>None</code> <code>tags</code> <code>tuple[str, ...]</code> <p>Optional tags for discovery/metadata.</p> <code>tuple()</code> Example <p>LOGGER = TokenLogger</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass Token(Generic[T]):\n    \"\"\"Immutable, hashable identifier for a typed dependency.\n\n    Args:\n        name: Human-readable name for the binding.\n        type_: The expected Python type of the dependency.\n        scope: Lifecycle scope. Defaults to TRANSIENT.\n        qualifier: Optional qualifier to differentiate multiple bindings of the same type.\n        tags: Optional tags for discovery/metadata.\n\n    Example:\n        LOGGER = Token[Logger](\"logger\", scope=Scope.SINGLETON)\n    \"\"\"\n\n    name: str\n    type_: type[T]\n    scope: Scope = Scope.TRANSIENT\n    qualifier: str | None = None\n    tags: tuple[str, ...] = field(default_factory=tuple)\n    _hash: int = field(init=False, repr=False, compare=False)\n    _metadata: dict[str, Any] = field(default_factory=dict, repr=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        # Pre-compute hash for performance\n        hash_tuple = (\n            self.name,\n            self.type_.__module__ if hasattr(self.type_, \"__module__\") else \"\",\n            self.type_.__name__ if hasattr(self.type_, \"__name__\") else str(self.type_),\n            self.scope.value,\n            self.qualifier,\n            self.tags,\n        )\n        object.__setattr__(self, \"_hash\", hash(hash_tuple))\n\n        # Make metadata immutable\n        if self._metadata:\n            object.__setattr__(self, \"_metadata\", MappingProxyType(self._metadata))\n\n    def __hash__(self) -&gt; int:  # pragma: no cover - trivial\n        return self._hash\n\n    def __eq__(self, other: object) -&gt; bool:  # pragma: no cover - trivial\n        if not isinstance(other, Token):\n            return False\n        other_token = cast(\"Token[object]\", other)\n        if self._hash != other_token._hash:\n            return False\n        return (\n            self.name == other.name\n            and self.type_ == other_token.type_\n            and self.scope == other_token.scope\n            and self.qualifier == other_token.qualifier\n            and self.tags == other_token.tags\n        )\n\n    @property\n    def metadata(self) -&gt; MappingProxyType[str, Any]:\n        \"\"\"Read-only view of metadata.\"\"\"\n        return self._metadata  # type: ignore[return-value]\n\n    @property\n    def qualified_name(self) -&gt; str:\n        \"\"\"Fully qualified name including module, type, qualifier, and token name.\"\"\"\n        parts: list[str] = []\n        if hasattr(self.type_, \"__module__\"):\n            parts.append(self.type_.__module__)  # type: ignore[arg-type]\n        parts.append(getattr(self.type_, \"__name__\", str(self.type_)))\n        if self.qualifier:\n            parts.append(self.qualifier)\n        parts.append(self.name)\n        return \".\".join(parts)\n\n    def with_scope(self, scope: Scope) -&gt; Token[T]:\n        \"\"\"Return a copy of this token with a different scope.\"\"\"\n        return Token(\n            name=self.name,\n            type_=self.type_,\n            scope=scope,\n            qualifier=self.qualifier,\n            tags=self.tags,\n            _metadata=dict(self._metadata) if self._metadata else {},\n        )\n\n    def with_qualifier(self, qualifier: str) -&gt; Token[T]:\n        \"\"\"Return a copy of this token with a qualifier.\"\"\"\n        return Token(\n            name=self.name,\n            type_=self.type_,\n            scope=self.scope,\n            qualifier=qualifier,\n            tags=self.tags,\n            _metadata=dict(self._metadata) if self._metadata else {},\n        )\n\n    def with_tags(self, *tags: str) -&gt; Token[T]:\n        \"\"\"Return a copy of this token with tags merged in (set semantics).\"\"\"\n        return Token(\n            name=self.name,\n            type_=self.type_,\n            scope=self.scope,\n            qualifier=self.qualifier,\n            tags=tuple(set(self.tags) | set(tags)),\n            _metadata=dict(self._metadata) if self._metadata else {},\n        )\n\n    def __repr__(self) -&gt; str:  # pragma: no cover - representation\n        type_name = getattr(self.type_, \"__name__\", str(self.type_))\n        parts = [f\"Token('{self.name}', {type_name}\"]\n        if self.scope != Scope.TRANSIENT:\n            parts.append(f\", scope={self.scope.name}\")\n        if self.qualifier:\n            parts.append(f\", qualifier='{self.qualifier}'\")\n        if self.tags:\n            parts.append(f\", tags={self.tags}\")\n        return \"\".join(parts) + \")\"\n\n    def validate(self, instance: object) -&gt; bool:\n        \"\"\"Validate instance type against the token's expected type.\n\n        Returns False only when ``isinstance(instance, type_)`` is definitively False.\n        If runtime type information is insufficient, returns True.\n        \"\"\"\n        try:\n            return isinstance(instance, self.type_)\n        except Exception:\n            return True\n</code></pre>"},{"location":"api/#pyinj.Token.metadata","title":"<code>metadata</code>  <code>property</code>","text":"<p>Read-only view of metadata.</p>"},{"location":"api/#pyinj.Token.qualified_name","title":"<code>qualified_name</code>  <code>property</code>","text":"<p>Fully qualified name including module, type, qualifier, and token name.</p>"},{"location":"api/#pyinj.Token.validate","title":"<code>validate(instance)</code>","text":"<p>Validate instance type against the token's expected type.</p> <p>Returns False only when <code>isinstance(instance, type_)</code> is definitively False. If runtime type information is insufficient, returns True.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def validate(self, instance: object) -&gt; bool:\n    \"\"\"Validate instance type against the token's expected type.\n\n    Returns False only when ``isinstance(instance, type_)`` is definitively False.\n    If runtime type information is insufficient, returns True.\n    \"\"\"\n    try:\n        return isinstance(instance, self.type_)\n    except Exception:\n        return True\n</code></pre>"},{"location":"api/#pyinj.Token.with_qualifier","title":"<code>with_qualifier(qualifier)</code>","text":"<p>Return a copy of this token with a qualifier.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def with_qualifier(self, qualifier: str) -&gt; Token[T]:\n    \"\"\"Return a copy of this token with a qualifier.\"\"\"\n    return Token(\n        name=self.name,\n        type_=self.type_,\n        scope=self.scope,\n        qualifier=qualifier,\n        tags=self.tags,\n        _metadata=dict(self._metadata) if self._metadata else {},\n    )\n</code></pre>"},{"location":"api/#pyinj.Token.with_scope","title":"<code>with_scope(scope)</code>","text":"<p>Return a copy of this token with a different scope.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def with_scope(self, scope: Scope) -&gt; Token[T]:\n    \"\"\"Return a copy of this token with a different scope.\"\"\"\n    return Token(\n        name=self.name,\n        type_=self.type_,\n        scope=scope,\n        qualifier=self.qualifier,\n        tags=self.tags,\n        _metadata=dict(self._metadata) if self._metadata else {},\n    )\n</code></pre>"},{"location":"api/#pyinj.Token.with_tags","title":"<code>with_tags(*tags)</code>","text":"<p>Return a copy of this token with tags merged in (set semantics).</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def with_tags(self, *tags: str) -&gt; Token[T]:\n    \"\"\"Return a copy of this token with tags merged in (set semantics).\"\"\"\n    return Token(\n        name=self.name,\n        type_=self.type_,\n        scope=self.scope,\n        qualifier=self.qualifier,\n        tags=tuple(set(self.tags) | set(tags)),\n        _metadata=dict(self._metadata) if self._metadata else {},\n    )\n</code></pre>"},{"location":"api/#pyinj.TokenFactory","title":"<code>TokenFactory</code>","text":"<p>Factory for creating and caching commonly used tokens.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>class TokenFactory:\n    \"\"\"Factory for creating and caching commonly used tokens.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._cache: dict[tuple[str, type[Any], Scope, str | None], Token[Any]] = {}\n\n    def create(\n        self,\n        name: str,\n        type_: type[T],\n        scope: Scope = Scope.TRANSIENT,\n        qualifier: str | None = None,\n        tags: tuple[str, ...] = (),\n    ) -&gt; Token[T]:\n        \"\"\"Create a token, with a small internal cache for common shapes.\"\"\"\n        cache_key = (name, type_, scope, qualifier)\n        if not tags and cache_key in self._cache:\n            return cast(Token[T], self._cache[cache_key])\n        token: Token[T] = Token(\n            name=name, type_=type_, scope=scope, qualifier=qualifier, tags=tags\n        )\n        if not tags:\n            self._cache[cache_key] = cast(Token[Any], token)\n        return token\n\n    def singleton(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a singleton-scoped token.\"\"\"\n        return self.create(name, type_, scope=Scope.SINGLETON)\n\n    def request(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a request-scoped token.\"\"\"\n        return self.create(name, type_, scope=Scope.REQUEST)\n\n    def session(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a session-scoped token.\"\"\"\n        return self.create(name, type_, scope=Scope.SESSION)\n\n    def transient(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a transient-scoped token (default).\"\"\"\n        return self.create(name, type_, scope=Scope.TRANSIENT)\n\n    def qualified(\n        self, qualifier: str, type_: type[T], scope: Scope = Scope.TRANSIENT\n    ) -&gt; Token[T]:\n        \"\"\"Create a qualified token for the given type and scope.\"\"\"\n        name = getattr(type_, \"__name__\", str(type_))\n        return self.create(name, type_, scope=scope, qualifier=qualifier)\n\n    def clear_cache(self) -&gt; None:\n        \"\"\"Clear the internal token cache (harmless).\"\"\"\n        self._cache.clear()\n\n    @property\n    def cache_size(self) -&gt; int:\n        \"\"\"Number of cached token shapes currently held.\"\"\"\n        return len(self._cache)\n</code></pre>"},{"location":"api/#pyinj.TokenFactory.cache_size","title":"<code>cache_size</code>  <code>property</code>","text":"<p>Number of cached token shapes currently held.</p>"},{"location":"api/#pyinj.TokenFactory.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear the internal token cache (harmless).</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear the internal token cache (harmless).\"\"\"\n    self._cache.clear()\n</code></pre>"},{"location":"api/#pyinj.TokenFactory.create","title":"<code>create(name, type_, scope=Scope.TRANSIENT, qualifier=None, tags=())</code>","text":"<p>Create a token, with a small internal cache for common shapes.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def create(\n    self,\n    name: str,\n    type_: type[T],\n    scope: Scope = Scope.TRANSIENT,\n    qualifier: str | None = None,\n    tags: tuple[str, ...] = (),\n) -&gt; Token[T]:\n    \"\"\"Create a token, with a small internal cache for common shapes.\"\"\"\n    cache_key = (name, type_, scope, qualifier)\n    if not tags and cache_key in self._cache:\n        return cast(Token[T], self._cache[cache_key])\n    token: Token[T] = Token(\n        name=name, type_=type_, scope=scope, qualifier=qualifier, tags=tags\n    )\n    if not tags:\n        self._cache[cache_key] = cast(Token[Any], token)\n    return token\n</code></pre>"},{"location":"api/#pyinj.TokenFactory.qualified","title":"<code>qualified(qualifier, type_, scope=Scope.TRANSIENT)</code>","text":"<p>Create a qualified token for the given type and scope.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def qualified(\n    self, qualifier: str, type_: type[T], scope: Scope = Scope.TRANSIENT\n) -&gt; Token[T]:\n    \"\"\"Create a qualified token for the given type and scope.\"\"\"\n    name = getattr(type_, \"__name__\", str(type_))\n    return self.create(name, type_, scope=scope, qualifier=qualifier)\n</code></pre>"},{"location":"api/#pyinj.TokenFactory.request","title":"<code>request(name, type_)</code>","text":"<p>Create a request-scoped token.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def request(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a request-scoped token.\"\"\"\n    return self.create(name, type_, scope=Scope.REQUEST)\n</code></pre>"},{"location":"api/#pyinj.TokenFactory.session","title":"<code>session(name, type_)</code>","text":"<p>Create a session-scoped token.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def session(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a session-scoped token.\"\"\"\n    return self.create(name, type_, scope=Scope.SESSION)\n</code></pre>"},{"location":"api/#pyinj.TokenFactory.singleton","title":"<code>singleton(name, type_)</code>","text":"<p>Create a singleton-scoped token.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def singleton(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a singleton-scoped token.\"\"\"\n    return self.create(name, type_, scope=Scope.SINGLETON)\n</code></pre>"},{"location":"api/#pyinj.TokenFactory.transient","title":"<code>transient(name, type_)</code>","text":"<p>Create a transient-scoped token (default).</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def transient(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a transient-scoped token (default).\"\"\"\n    return self.create(name, type_, scope=Scope.TRANSIENT)\n</code></pre>"},{"location":"api/#pyinj.Depends","title":"<code>Depends(provider)</code>","text":"<p>FastAPI-compatible <code>Depends</code> marker.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>Callable[..., T]</code> <p>Provider function for the dependency</p> required <p>Returns:</p> Name Type Description <code>An</code> <code>T</code> <p>class:<code>Inject</code> marker usable as a default parameter value.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def Depends[T](provider: Callable[..., T]) -&gt; T:  # noqa: N802\n    \"\"\"\n    FastAPI-compatible ``Depends`` marker.\n\n    Args:\n        provider: Provider function for the dependency\n\n    Returns:\n        An :class:`Inject` marker usable as a default parameter value.\n    \"\"\"\n    return Inject(provider)  # type: ignore\n</code></pre>"},{"location":"api/#pyinj.get_default_container","title":"<code>get_default_container()</code>","text":"<p>Get the global default container.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def get_default_container() -&gt; Container:\n    \"\"\"Get the global default container.\"\"\"\n    global _default_container\n    if _default_container is None:\n        _default_container = Container()\n    return _default_container\n</code></pre>"},{"location":"api/#pyinj.inject","title":"<code>inject(func=None, *, container=None, cache=True)</code>","text":"<pre><code>inject(func: Callable[P, R], *, container: Resolvable[Any] | None = ..., cache: bool = ...) -&gt; Callable[P, R]\n</code></pre><pre><code>inject(func: None = ..., *, container: Resolvable[Any] | None = ..., cache: bool = ...) -&gt; Callable[[Callable[P, R]], Callable[P, R]]\n</code></pre> <p>Decorator that injects dependencies into function parameters.</p> <p>This is the main entry point for dependency injection, inspired by FastAPI's dependency injection system.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R] | None</code> <p>Function to decorate (or None if using with parameters)</p> <code>None</code> <code>container</code> <code>Resolvable[Any] | None</code> <p>Container to resolve dependencies from</p> <code>None</code> <code>cache</code> <code>bool</code> <p>Whether to cache dependency analysis</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable[P, R] | Callable[[Callable[P, R]], Callable[P, R]]</code> <p>Decorated function with automatic dependency injection</p> <p>Examples:</p> <p>@inject def service(db: Inject[Database]):     return db.query()</p> <p>@inject(container=my_container) async def handler(cache: Inject[Cache]):     return await cache.get(\"key\")</p> <p>@inject async def endpoint(     user_id: int,     db: Inject[Database],     cache: Given[Cache],     settings: Settings = Inject() ):     # Mixed regular and injected parameters     pass</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def inject(\n    func: Callable[P, R] | None = None,\n    *,\n    container: Resolvable[Any] | None = None,\n    cache: bool = True,\n) -&gt; Callable[P, R] | Callable[[Callable[P, R]], Callable[P, R]]:\n    \"\"\"\n    Decorator that injects dependencies into function parameters.\n\n    This is the main entry point for dependency injection, inspired by\n    FastAPI's dependency injection system.\n\n    Args:\n        func: Function to decorate (or None if using with parameters)\n        container: Container to resolve dependencies from\n        cache: Whether to cache dependency analysis\n\n    Returns:\n        Decorated function with automatic dependency injection\n\n    Examples:\n        @inject\n        def service(db: Inject[Database]):\n            return db.query()\n\n        @inject(container=my_container)\n        async def handler(cache: Inject[Cache]):\n            return await cache.get(\"key\")\n\n        @inject\n        async def endpoint(\n            user_id: int,\n            db: Inject[Database],\n            cache: Given[Cache],\n            settings: Settings = Inject()\n        ):\n            # Mixed regular and injected parameters\n            pass\n    \"\"\"\n\n    def decorator(fn: Callable[P, R]) -&gt; Callable[P, R]:\n        # Analyze dependencies (cached if cache=True)\n        deps = InjectionAnalyzer.build_plan(fn) if cache else None\n\n        if iscoroutinefunction(fn):\n\n            @wraps(fn)\n            async def async_wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n                # Get dependencies if not cached\n                nonlocal deps\n                if deps is None:\n                    deps = InjectionAnalyzer.build_plan(fn)\n\n                if not deps:\n                    # No dependencies, call original\n                    return await fn(*args, **kwargs)\n\n                # Get container\n                nonlocal container\n                if container is None:\n                    # Try to get default container via indirection (patchable)\n                    from .injection import get_default_container as _gdc\n                    container = tcast(Resolvable[Any], _gdc())\n\n                # Extract overrides from kwargs\n                overrides: dict[str, Any] = {}\n                for name in deps:\n                    if name in kwargs:  # type: ignore[operator]\n                        overrides[name] = cast(Any, kwargs.pop(name))  # type: ignore[call-arg]\n\n                # Resolve dependencies\n                resolved = await resolve_dependencies_async(deps, container, overrides)\n\n                # Rebind arguments: skip injected params from positional binding\n                sig = signature(fn)\n                new_kwargs: dict[str, Any] = {}\n                arg_i = 0\n                for pname, param in sig.parameters.items():\n                    if pname in resolved:\n                        # will be injected\n                        continue\n                    if param.kind in (Parameter.POSITIONAL_ONLY, Parameter.POSITIONAL_OR_KEYWORD) and arg_i &lt; len(args):\n                        new_kwargs[pname] = args[arg_i]\n                        arg_i += 1\n                # bring through any explicit kwargs provided\n                new_kwargs.update(kwargs)\n                # inject resolved deps\n                new_kwargs.update(resolved)\n\n                return await fn(**new_kwargs)\n\n            return tcast(Callable[P, R], async_wrapper)\n\n        else:\n\n            @wraps(fn)\n            def sync_wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n                # Get dependencies if not cached\n                nonlocal deps\n                if deps is None:\n                    deps = InjectionAnalyzer.build_plan(fn)\n\n                if not deps:\n                    # No dependencies, call original\n                    return fn(*args, **kwargs)\n\n                # Get container\n                nonlocal container\n                if container is None:\n                    from .injection import get_default_container as _gdc\n                    container = tcast(Resolvable[Any], _gdc())\n\n                # Extract overrides from kwargs\n                overrides: dict[str, Any] = {}\n                for name in deps:\n                    if name in kwargs:  # type: ignore[operator]\n                        overrides[name] = cast(Any, kwargs.pop(name))  # type: ignore[call-arg]\n\n                # Resolve dependencies\n                resolved = resolve_dependencies(deps, container, overrides)\n\n                # Rebind arguments: skip injected params from positional binding\n                sig = signature(fn)\n                new_kwargs: dict[str, Any] = {}\n                arg_i = 0\n                for pname, param in sig.parameters.items():\n                    if pname in resolved:\n                        continue\n                    if param.kind in (Parameter.POSITIONAL_ONLY, Parameter.POSITIONAL_OR_KEYWORD) and arg_i &lt; len(args):\n                        new_kwargs[pname] = args[arg_i]\n                        arg_i += 1\n                new_kwargs.update(kwargs)\n                new_kwargs.update(resolved)\n\n                return fn(**new_kwargs)\n\n            return tcast(Callable[P, R], sync_wrapper)\n\n    # Handle both @inject and @inject(...) syntax\n    if func is None:\n        # Called with parameters: @inject(container=...)\n        return decorator\n    else:\n        # Called without parameters: @inject\n        return decorator(func)\n</code></pre>"},{"location":"api/#pyinj.set_default_container","title":"<code>set_default_container(container)</code>","text":"<p>Set the global default container.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def set_default_container(container: Container) -&gt; None:\n    \"\"\"Set the global default container.\"\"\"\n    global _default_container\n    _default_container = container\n</code></pre>"},{"location":"api/#container","title":"Container","text":"<p>               Bases: <code>ContextualContainer</code></p> <p>Ergonomic, type-safe DI container with async support.</p> <p>Features: - O(1) lookups with a compact registry - Thread/async-safe singleton initialization - Contextual scoping using <code>contextvars</code> (request/session) - Scala-inspired \"given\" instances for testability - Method chaining for concise setup and batch operations</p> Example <p>container = Container() LOGGER = TokenLogger container.register_singleton(LOGGER, ConsoleLogger)</p> <p>@inject def handler(logger: Inject[Logger]):     logger.info(\"hello\")</p> Source code in <code>src/pyinj/container.py</code> <pre><code>class Container(ContextualContainer):\n    \"\"\"Ergonomic, type-safe DI container with async support.\n\n    Features:\n    - O(1) lookups with a compact registry\n    - Thread/async-safe singleton initialization\n    - Contextual scoping using ``contextvars`` (request/session)\n    - Scala-inspired \"given\" instances for testability\n    - Method chaining for concise setup and batch operations\n\n    Example:\n        container = Container()\n        LOGGER = Token[Logger](\"logger\")\n        container.register_singleton(LOGGER, ConsoleLogger)\n\n        @inject\n        def handler(logger: Inject[Logger]):\n            logger.info(\"hello\")\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize enhanced container.\"\"\"\n        super().__init__()\n\n        # Token factory for convenient creation\n        self.tokens: TokenFactory = TokenFactory()\n\n        # Given instances (Scala-inspired)\n        self._given_providers: dict[type[object], ProviderSync[object]] = {}\n\n        # Override less-precise base attributes with typed variants\n        self._providers: dict[Token[object], ProviderLike[object]] = {}\n        self._registrations: dict[Token[object], _Registration[object]] = {}\n        self._token_scopes: dict[Token[object], Scope] = {}\n        self._singletons: dict[Token[object], object] = {}\n        self._async_locks: dict[Token[object], asyncio.Lock] = {}\n\n        # Performance metrics\n        self._resolution_times: deque[float] = deque(maxlen=1000)\n        self._cache_hits: int = 0\n        self._cache_misses: int = 0\n\n        # Thread safety\n        self._lock: threading.RLock = threading.RLock()\n        self._singleton_locks: dict[Token[object], threading.Lock] = defaultdict(\n            threading.Lock\n        )\n\n        # Track dependencies for graph\n        self._dependencies: dict[Token[object], set[Token[object]]] = defaultdict(set)\n\n        # Per-context overrides (DI_SPEC requirement)\n        self._overrides: ContextVar[dict[Token[object], object] | None] = ContextVar(\n            \"pyinj_overrides\",\n            default=None,\n        )\n\n        # Resolution stack is tracked via ContextVar (task-local)\n\n        # Fast type-to-token index for O(1) resolution by type\n        self._type_index: dict[type[object], Token[object]] = {}\n        # Container-level cleanup stacks for singleton context-managed resources\n        self._singleton_cleanup_sync: list[Callable[[], None]] = []\n        self._singleton_cleanup_async: list[Callable[[], Awaitable[None]]] = []\n\n        # Auto-register classes marked with Injectable metaclass (plain DI)\n        self._auto_register()\n\n    def _auto_register(self) -&gt; None:\n        try:\n            from .metaclasses import Injectable  # avoid top-level cycle\n        except Exception:\n            return\n        registry = Injectable.get_registry()\n        for cls, token in registry.items():\n            # Determine scope from class metadata (default TRANSIENT)\n            scope = getattr(cls, \"__scope__\", Scope.TRANSIENT)\n            # Build provider; resolve constructor deps by type\n            try:\n                from typing import get_type_hints\n\n                hints = get_type_hints(cls.__init__)\n                deps: dict[str, type[object]] = {\n                    k: v for k, v in hints.items() if k not in (\"self\", \"return\")\n                }\n            except Exception:\n                deps = {}\n\n            if deps:\n                def make_factory(\n                    target_cls: type[Any] = cls,\n                    deps_map: dict[str, type[object]] = deps,\n                ) -&gt; Callable[[], Any]:\n                    def provider() -&gt; Any:\n                        kwargs: dict[str, Any] = {}\n                        for name, typ in deps_map.items():\n                            kwargs[name] = self.get(typ)\n                        return target_cls(**kwargs)\n                    return provider\n                self.register(token, make_factory(), scope=scope)\n            else:\n                # No deps, construct directly\n                self.register(token, cast(ProviderLike[Any], cls), scope=scope)\n\n    # ============= Internal Helpers (Phase 1) =============\n\n    def _coerce_to_token(self, spec: Token[U] | type[U]) -&gt; Token[U]:\n        if isinstance(spec, Token):\n            return spec\n        if isinstance(spec, type):\n            found = self._type_index.get(cast(type[object], spec))\n            if found is not None:\n                return cast(Token[U], found)\n            for registered in self._providers:\n                if registered.type_ == spec:\n                    return cast(Token[U], registered)\n            for registered in self._singletons:\n                if registered.type_ == spec:\n                    return cast(Token[U], registered)\n            return Token(spec.__name__, spec)\n        # Disallow string-based tokens for type safety\n        raise TypeError(\n            \"Token specification must be a Token or type; strings are not supported\"\n        )\n\n    def _get_override(self, token: Token[U]) -&gt; U | None:\n        current = self._overrides.get()\n        if current is not None:\n            val = current.get(cast(Token[object], token))\n            if val is not None:\n                return cast(U, val)\n        return None\n\n    @contextmanager\n    def _resolution_guard(self, token: Token[Any]):\n        stack = _resolution_stack.get()\n        if token in stack:\n            raise CircularDependencyError(token, list(stack))\n        reset_token = _resolution_stack.set(stack + (token,))\n        try:\n            yield\n        finally:\n            _resolution_stack.reset(reset_token)\n\n    # ============= Registration Methods =============\n\n    def register(\n        self,\n        token: Token[U] | type[U],\n        provider: ProviderLike[U],\n        scope: Scope | None = None,\n        *,\n        tags: tuple[str, ...] = (),\n    ) -&gt; \"Container\":\n        \"\"\"Register a provider for a token.\n\n        Args:\n            token: A ``Token[T]`` or a concrete ``type[T]``. If a type is\n                provided, a token is created automatically.\n            provider: Callable that returns the dependency instance.\n            scope: Optional lifecycle override (defaults to token.scope or TRANSIENT).\n            tags: Optional tags for discovery/metadata.\n\n        Returns:\n            Self, to allow method chaining.\n\n        Example:\n            container.register(Token[DB](\"db\"), create_db, scope=Scope.SINGLETON)\n        \"\"\"\n        # Validate token type\n        if not isinstance(token, (Token, type)):\n            raise TypeError(\n                \"Token specification must be a Token or type; strings are not supported\"\n            )\n\n        # Convert to Token if needed\n        if isinstance(token, type):\n            token = self.tokens.create(\n                token.__name__, token, scope=scope or Scope.TRANSIENT, tags=tags\n            )\n        elif scope is not None:\n            # Record desired scope without changing the token identity\n            self._token_scopes[cast(Token[object], token)] = scope\n\n        # Validate provider\n        if not callable(provider):\n            raise TypeError(\n                f\"Provider must be callable, got {type(provider).__name__}\\n\"\n                f\"  Fix: Pass a function or lambda that returns an instance\\n\"\n                f\"  Example: container.register(token, lambda: {token.type_.__name__}())\"\n            )\n\n        with self._lock:\n            obj_token = cast(Token[object], token)\n            # Enforce immutable registrations\n            if obj_token in self._providers or obj_token in self._registrations or obj_token in self._singletons:\n                raise ValueError(f\"Token '{obj_token.name}' is already registered\")\n            self._providers[obj_token] = cast(ProviderLike[object], provider)\n            self._registrations[obj_token] = _Registration(\n                provider=cast(Callable[[], Any], provider), cleanup=CleanupMode.NONE\n            )\n            # Update type index\n            self._type_index[obj_token.type_] = obj_token\n\n        return self  # Enable chaining\n\n    def register_singleton(\n        self, token: Token[U] | type[U], provider: ProviderLike[U]\n    ) -&gt; \"Container\":\n        \"\"\"Register a singleton-scoped dependency.\"\"\"\n        return self.register(token, provider, scope=Scope.SINGLETON)\n\n    def register_request(\n        self, token: Token[U] | type[U], provider: ProviderLike[U]\n    ) -&gt; \"Container\":\n        \"\"\"Register a request-scoped dependency.\"\"\"\n        return self.register(token, provider, scope=Scope.REQUEST)\n\n    def register_transient(\n        self, token: Token[U] | type[U], provider: ProviderLike[U]\n    ) -&gt; \"Container\":\n        \"\"\"Register a transient-scoped dependency.\"\"\"\n        return self.register(token, provider, scope=Scope.TRANSIENT)\n\n    @overload\n    def register_context(\n        self,\n        token: Token[U] | type[U],\n        cm_provider: Callable[[], ContextManager[U]],\n        *,\n        is_async: Literal[False],\n        scope: Scope | None = None,\n    ) -&gt; \"Container\":\n        ...\n\n    @overload\n    def register_context(\n        self,\n        token: Token[U] | type[U],\n        cm_provider: Callable[[], AsyncContextManager[U]],\n        *,\n        is_async: Literal[True],\n        scope: Scope | None = None,\n    ) -&gt; \"Container\":\n        ...\n\n    def register_context(\n        self,\n        token: Token[U] | type[U],\n        cm_provider: Callable[[], Any],\n        *,\n        is_async: bool,\n        scope: Scope | None = None,\n    ) -&gt; \"Container\":\n        \"\"\"Register a context-managed dependency.\n\n        - When ``is_async=False``, ``cm_provider`` must return a ``ContextManager[T]``.\n        - When ``is_async=True``, ``cm_provider`` must return an ``AsyncContextManager[T]``.\n\n        The context is entered on first resolution within the declared scope and\n        exited during scope cleanup (request/session), or on container close for\n        singletons.\n        \"\"\"\n        # Validate token\n        if not isinstance(token, (Token, type)):\n            raise TypeError(\n                \"Token specification must be a Token or type; strings are not supported\"\n            )\n        # To token\n        if isinstance(token, type):\n            token = self.tokens.create(token.__name__, token, scope=scope or Scope.TRANSIENT)\n        elif scope is not None:\n            self._token_scopes[cast(Token[object], token)] = scope\n\n        if not callable(cm_provider):\n            raise TypeError(\"cm_provider must be callable and return a (async) context manager\")\n\n        with self._lock:\n            obj_token = cast(Token[object], token)\n            # Enforce immutable registrations\n            if obj_token in self._providers or obj_token in self._registrations or obj_token in self._singletons:\n                raise ValueError(f\"Token '{obj_token.name}' is already registered\")\n            self._registrations[obj_token] = _Registration(\n                provider=cm_provider,\n                cleanup=CleanupMode.CONTEXT_ASYNC if is_async else CleanupMode.CONTEXT_SYNC,\n            )\n            self._type_index[obj_token.type_] = obj_token\n        return self\n\n    # Strongly-typed helpers separating sync/async context registration\n    def register_context_sync(\n        self,\n        token: Token[U] | type[U],\n        cm_provider: Callable[[], ContextManager[U]],\n        *,\n        scope: Scope | None = None,\n    ) -&gt; \"Container\":\n        \"\"\"Typed helper to register a sync context-managed provider.\n\n        Equivalent to ``register_context(..., is_async=False)``.\n        \"\"\"\n        return self.register_context(token, cm_provider, is_async=False, scope=scope)\n\n    def register_context_async(\n        self,\n        token: Token[U] | type[U],\n        cm_provider: Callable[[], AsyncContextManager[U]],\n        *,\n        scope: Scope | None = None,\n    ) -&gt; \"Container\":\n        \"\"\"Typed helper to register an async context-managed provider.\n\n        Equivalent to ``register_context(..., is_async=True)``.\n        \"\"\"\n        return self.register_context(token, cm_provider, is_async=True, scope=scope)\n\n    def register_value(self, token: Token[U] | type[U], value: U) -&gt; \"Container\":\n        \"\"\"Register a pre-created value as a singleton.\"\"\"\n        if isinstance(token, type):\n            token = self.tokens.singleton(token.__name__, token)\n        # token is now a Token[Any]\n\n        # Store directly as singleton (immutable)\n        obj_token = cast(Token[object], token)\n        if obj_token in self._providers or obj_token in self._registrations or obj_token in self._singletons:\n            raise ValueError(f\"Token '{obj_token.name}' is already registered\")\n        self._singletons[obj_token] = value\n        return self\n\n    def override(self, token: Token[U], value: U) -&gt; None:\n        \"\"\"Override a dependency for the current concurrent context only.\n\n        Uses a ContextVar-backed mapping so overrides are isolated between\n        threads/tasks. Prefer ``use_overrides`` for scoped overrides.\n        \"\"\"\n        parent = self._overrides.get()\n        merged: dict[Token[object], object] = dict(parent) if parent else {}\n        merged[cast(Token[object], token)] = value\n        self._overrides.set(merged)\n\n    # ============= Given Instances (Scala-inspired) =============\n\n    def given(self, type_: type[U], provider: ProviderSync[U] | U) -&gt; \"Container\":\n        \"\"\"Register a given instance for a type (Scala-style).\"\"\"\n        if callable(provider):\n            self._given_providers[type_] = cast(ProviderSync[object], provider)\n        else:\n            # Wrap value in lambda\n            self._given_providers[type_] = lambda p=provider: p\n\n        return self\n\n    def resolve_given(self, type_: type[U]) -&gt; U | None:\n        \"\"\"Resolve a given instance by type.\"\"\"\n        provider = self._given_providers.get(type_)\n        if provider:\n            return cast(ProviderSync[U], provider)()\n        return None\n\n    @contextmanager\n    def using(\n        self,\n        mapping: Mapping[type[object], object] | None = None,\n        **givens: object,\n    ) -&gt; Iterator[Container]:\n        \"\"\"Temporarily register \"given\" instances for the current block.\n\n        Supports both an explicit mapping of types to instances and\n        keyword arguments that match type names previously registered\n        via ``given()``.\n        \"\"\"\n        old_givens = self._given_providers.copy()\n\n        # Apply explicit mapping first (precise and type-safe)\n        if mapping:\n            for t, instance in mapping.items():\n                self.given(t, instance)\n\n        # Support kwargs by matching on type name for already-known givens\n        if givens:\n            known_types = list(self._given_providers.keys())\n            for name, instance in givens.items():\n                for t in known_types:\n                    if getattr(t, \"__name__\", \"\") == name:\n                        self.given(t, instance)\n                        break\n\n        try:\n            yield self\n        finally:\n            self._given_providers = old_givens\n\n    # ============= Resolution Methods =============\n\n    # --- Internal typed helpers to centralize invariance casts ---\n\n    def _obj_token(self, token: Token[U]) -&gt; Token[object]:\n        return cast(Token[object], token)\n\n    def _canonicalize(self, token: Token[U]) -&gt; Token[U]:\n        \"\"\"Return the registered token that matches by name and type (ignore scope).\n\n        This allows callers to construct a token with the same name/type but different\n        scope and still resolve the registered binding.\n        \"\"\"\n        obj_token = self._obj_token(token)\n        if obj_token in self._providers or obj_token in self._singletons:\n            return token\n        # Search providers first\n        for t in self._providers.keys():\n            if t.name == token.name and t.type_ == token.type_:\n                return cast(Token[U], t)\n        # Then singletons\n        for t in self._singletons.keys():\n            if t.name == token.name and t.type_ == token.type_:\n                return cast(Token[U], t)\n        return token\n\n    def _get_provider(self, token: Token[U]) -&gt; ProviderLike[U]:\n        token = self._canonicalize(token)\n        obj_token = self._obj_token(token)\n        provider = self._providers.get(obj_token)\n        if provider is None:\n            raise ResolutionError(\n                token,\n                [],\n                (\n                    f\"No provider registered for token '{token.name}'. \"\n                    f\"Fix: register a provider for this token before resolving.\"\n                ),\n            )\n        return cast(ProviderLike[U], provider)\n\n    def _get_scope(self, token: Token[U]) -&gt; Scope:\n        token = self._canonicalize(token)\n        return self._token_scopes.get(self._obj_token(token), token.scope)\n\n    def _get_singleton_cached(self, token: Token[U]) -&gt; U | None:\n        token = self._canonicalize(token)\n        obj_token = self._obj_token(token)\n        if obj_token in self._singletons:\n            return cast(U, self._singletons[obj_token])\n        return None\n\n    def _set_singleton_cached(self, token: Token[U], value: U) -&gt; None:\n        self._singletons[self._obj_token(token)] = value\n\n    def _ensure_async_lock(self, token: Token[U]) -&gt; asyncio.Lock:\n        obj_token = self._obj_token(token)\n        lock = self._async_locks.get(obj_token)\n        if lock is None:\n            lock = asyncio.Lock()\n            self._async_locks[obj_token] = lock\n        return lock\n\n    def get(self, token: Token[U] | type[U]) -&gt; U:\n        \"\"\"Resolve a dependency synchronously.\n\n        Args:\n            token: The ``Token[T]`` or ``type[T]`` to resolve.\n\n        Returns:\n            The resolved instance.\n\n        Raises:\n            ResolutionError: If no provider is registered or resolution fails.\n        \"\"\"\n        # Convert to token if needed and handle givens\n        if isinstance(token, type):\n            given = self.resolve_given(token)\n            if given is not None:\n                return given\n        token = self._coerce_to_token(token)\n        token = self._canonicalize(token)\n\n        # Check per-context overrides first\n        override = self._get_override(token)\n        if override is not None:\n            self._cache_hits += 1\n            return override\n\n        # Check context first (for request/session stored instances)\n        instance = self.resolve_from_context(token)\n        if instance is not None:\n            self._cache_hits += 1\n            return instance\n\n        self._cache_misses += 1\n\n        with self._resolution_guard(token):\n            obj_token = cast(Token[object], token)\n            reg = self._registrations.get(obj_token)\n            effective_scope = self._get_scope(token)\n            if reg and reg.cleanup is CleanupMode.CONTEXT_ASYNC:\n                # cannot enter async context in sync path\n                raise ResolutionError(\n                    token,\n                    [],\n                    \"Context-managed provider is async; Use aget() for async providers\",\n                )\n            if reg and reg.cleanup is CleanupMode.CONTEXT_SYNC:\n                # handle context-managed sync\n                if effective_scope == Scope.SINGLETON:\n                    with self._singleton_locks[self._obj_token(token)]:\n                        cached = self._get_singleton_cached(token)\n                        if cached is not None:\n                            return cached\n                        cm = reg.provider()\n                        value = cm.__enter__()\n                        self._set_singleton_cached(token, value)\n                        # schedule cleanup\n                        self._singleton_cleanup_sync.append(lambda cm=cm: cm.__exit__(None, None, None))\n                        self._resources.append(value)\n                        return cast(U, value)\n                else:\n                    cm = reg.provider()\n                    value = cm.__enter__()\n                    self.store_in_context(token, value)\n                    # register per-scope cleanup\n                    if effective_scope == Scope.REQUEST:\n                        self._register_request_cleanup_sync(lambda cm=cm: cm.__exit__(None, None, None))\n                    elif effective_scope == Scope.SESSION:\n                        self._register_session_cleanup_sync(lambda cm=cm: cm.__exit__(None, None, None))\n                    self._resources.append(value)\n                    return cast(U, value)\n\n            provider = self._get_provider(token)\n            # legacy non-context providers\n            if effective_scope == Scope.SINGLETON:\n                with self._singleton_locks[self._obj_token(token)]:\n                    cached = self._get_singleton_cached(token)\n                    if cached is not None:\n                        return cached\n                    if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                        raise ResolutionError(\n                            token,\n                            [],\n                            \"Provider is async; Use aget() for async providers\",\n                        )\n                    instance = cast(ProviderSync[U], provider)()\n                    self._validate_and_track(token, instance)\n                    self._set_singleton_cached(token, instance)\n                    return instance\n            else:\n                if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                    raise ResolutionError(\n                        token,\n                        [],\n                        \"Provider is async; Use aget() for async providers\",\n                    )\n                instance = cast(ProviderSync[U], provider)()\n                self._validate_and_track(token, instance)\n                # Only store in context for REQUEST/SESSION\n                if effective_scope in (Scope.REQUEST, Scope.SESSION):\n                    self.store_in_context(token, instance)\n                return instance\n\n    async def aget(self, token: Token[U] | type[U]) -&gt; U:\n        \"\"\"Resolve a dependency asynchronously.\n\n        Equivalent to :meth:`get` but awaits async providers and uses\n        async locks for singleton initialization.\n        \"\"\"\n        # Convert to token if needed\n        if isinstance(token, type):\n            given = self.resolve_given(token)\n            if given is not None:\n                return given\n        token = self._coerce_to_token(token)\n        token = self._canonicalize(token)\n\n        # Check per-context overrides first\n        override = self._get_override(token)\n        if override is not None:\n            self._cache_hits += 1\n            return override\n\n        # Check context first\n        instance = self.resolve_from_context(token)\n        if instance is not None:\n            self._cache_hits += 1\n            return instance\n\n        self._cache_misses += 1\n\n        with self._resolution_guard(token):\n            obj_token = cast(Token[object], token)\n            reg = self._registrations.get(obj_token)\n            effective_scope = self._get_scope(token)\n            if reg and reg.cleanup is CleanupMode.CONTEXT_ASYNC:\n                if effective_scope == Scope.SINGLETON:\n                    lock = self._ensure_async_lock(token)\n                    async with lock:\n                        cached = self._get_singleton_cached(token)\n                        if cached is not None:\n                            return cached\n                        cm = reg.provider()\n                        value = await cm.__aenter__()\n                        self._set_singleton_cached(token, value)\n                        self._singleton_cleanup_async.append(lambda cm=cm: cm.__aexit__(None, None, None))\n                        self._resources.append(value)\n                        return cast(U, value)\n                else:\n                    cm = reg.provider()\n                    value = await cm.__aenter__()\n                    self.store_in_context(token, value)\n                    if effective_scope == Scope.REQUEST:\n                        self._register_request_cleanup_async(lambda cm=cm: cm.__aexit__(None, None, None))\n                    elif effective_scope == Scope.SESSION:\n                        self._register_session_cleanup_async(lambda cm=cm: cm.__aexit__(None, None, None))\n                    self._resources.append(value)\n                    return cast(U, value)\n\n            # fallback legacy providers\n            provider = self._get_provider(token)\n            if effective_scope == Scope.SINGLETON:\n                lock = self._ensure_async_lock(token)\n                async with lock:\n                    cached = self._get_singleton_cached(token)\n                    if cached is not None:\n                        return cached\n\n                    if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                        instance = await cast(ProviderAsync[U], provider)()\n                    else:\n                        instance = cast(ProviderSync[U], provider)()\n                    self._validate_and_track(token, instance)\n                    self._set_singleton_cached(token, instance)\n                    return instance\n            else:\n                if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                    instance = await cast(ProviderAsync[U], provider)()\n                else:\n                    instance = cast(ProviderSync[U], provider)()\n                self._validate_and_track(token, instance)\n                if effective_scope in (Scope.REQUEST, Scope.SESSION):\n                    self.store_in_context(token, instance)\n                return instance\n\n    # ============= Batch Operations =============\n\n    def batch_register(\n        self, registrations: list[tuple[Token[object], ProviderLike[object]]]\n    ) -&gt; Container:\n        \"\"\"Register multiple dependencies at once.\"\"\"\n        for token, provider in registrations:\n            self.register(token, provider)\n        return self\n\n    def batch_resolve(self, tokens: list[Token[object]]) -&gt; dict[Token[object], object]:\n        \"\"\"Resolve multiple dependencies efficiently (sync).\"\"\"\n        sorted_tokens = sorted(tokens, key=lambda t: t.scope.value)\n        results: dict[Token[object], object] = {}\n        for _scope, group in groupby(sorted_tokens, key=lambda t: t.scope):\n            group_list = list(group)\n            for tk in group_list:\n                results[tk] = self.get(tk)\n        return results\n\n    async def batch_resolve_async(\n        self, tokens: list[Token[object]]\n    ) -&gt; dict[Token[object], object]:\n        \"\"\"Async batch resolution with parallel execution.\"\"\"\n        tasks = {token: self.aget(token) for token in tokens}\n        results_list: list[object] = await asyncio.gather(*tasks.values())\n        return dict(zip(tasks.keys(), results_list, strict=True))\n\n    # (Provider graph analysis intentionally omitted; can be added behind a feature flag.)\n\n    @lru_cache(maxsize=512)\n    def _get_resolution_path(self, token: Token[Any]) -&gt; tuple[Token[Any], ...]:\n        \"\"\"Get resolution path for a token (cached).\"\"\"\n        return (token,)\n\n    @property\n    def cache_hit_rate(self) -&gt; float:\n        total = self._cache_hits + self._cache_misses\n        return 0.0 if total == 0 else self._cache_hits / total\n\n    def get_stats(self) -&gt; dict[str, Any]:\n        return {\n            \"total_providers\": len(self._providers),\n            \"singletons\": len(self._singletons),\n            \"cache_hits\": self._cache_hits,\n            \"cache_misses\": self._cache_misses,\n            \"cache_hit_rate\": self.cache_hit_rate,\n            \"avg_resolution_time\": (\n                sum(self._resolution_times) / len(self._resolution_times)\n                if self._resolution_times\n                else 0\n            ),\n        }\n\n    # ============= Utilities =============\n\n    def get_providers_view(\n        self,\n    ) -&gt; MappingProxyType[Token[object], ProviderLike[object]]:\n        \"\"\"Return a read-only view of registered providers.\"\"\"\n        return MappingProxyType(self._providers)\n\n    def resources_view(self) -&gt; tuple[SupportsClose | SupportsAsyncClose, ...]:\n        \"\"\"Return a read-only snapshot of tracked resources for tests/inspection.\"\"\"\n        return tuple(self._resources)\n\n    # ============= Decorator Alias =============\n\n    def inject(\n        self, func: Callable[..., Any] | None = None, *, cache: bool = True\n    ) -&gt; Callable[..., Any]:\n        \"\"\"Alias to pyinj.injection.inject bound to this container.\n\n        Enables ``@container.inject`` usage in addition to\n        ``@inject(container=container)``.\n        \"\"\"\n        from .injection import inject as _inject\n\n        if func is None:\n            return _inject(container=self, cache=cache)\n        return _inject(func, container=self, cache=cache)\n\n    def has(self, token: Token[Any] | type[Any]) -&gt; bool:\n        \"\"\"Return True if the token/type is known to the container.\"\"\"\n        if isinstance(token, type):\n            if token in self._given_providers:\n                return True\n            token = Token(token.__name__, token)\n        obj_token = cast(Token[object], token)\n        return obj_token in self._providers or obj_token in self._singletons\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear caches and statistics; keep provider registrations intact.\"\"\"\n        with self._lock:\n            self._singletons.clear()\n            self._transients.clear()\n            self._given_providers.clear()\n            self._dependencies.clear()\n            self._cache_hits = 0\n            self._cache_misses = 0\n            self._resolution_times.clear()\n        self.clear_all_contexts()\n\n    def __repr__(self) -&gt; str:\n        return (\n            \"Container(\"\n            f\"providers={len(self._providers)}, \"\n            f\"singletons={len(self._singletons)}, \"\n            f\"cache_hit_rate={self.cache_hit_rate:.2%})\"\n        )\n\n    # ============= Context Managers &amp; Cleanup =============\n\n    def __enter__(self) -&gt; Container:  # pragma: no cover - trivial\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:  # pragma: no cover - trivial\n        # If any async singleton cleanups are registered, fail fast in sync context\n        if self._singleton_cleanup_async:\n            raise AsyncCleanupRequiredError(\n                \"singleton\",\n                \"Use 'await container.aclose()' or an async scope.\",\n            )\n        # Run sync cleanups for singletons (LIFO)\n        for fn in reversed(self._singleton_cleanup_sync):\n            try:\n                fn()\n            except Exception:\n                pass\n\n    async def __aenter__(self) -&gt; Container:  # pragma: no cover - trivial\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:  # pragma: no cover - trivial\n        # Run async cleanups for singletons (LIFO)\n        if self._singleton_cleanup_async:\n            tasks = [fn() for fn in reversed(self._singleton_cleanup_async)]\n            await asyncio.gather(*tasks, return_exceptions=True)\n        # Run sync cleanups too\n        for fn in reversed(self._singleton_cleanup_sync):\n            try:\n                fn()\n            except Exception:\n                pass\n\n    async def aclose(self) -&gt; None:\n        \"\"\"Async close: close tracked resources and clear caches.\"\"\"\n        await self.__aexit__(None, None, None)\n        self.clear()\n\n    async def dispose(self) -&gt; None:\n        \"\"\"Alias for aclose to align with tests and docs.\"\"\"\n        await self.aclose()\n\n    @contextmanager\n    def use_overrides(self, mapping: dict[Token[Any], object]) -&gt; Iterator[None]:\n        \"\"\"Temporarily override tokens for this concurrent context.\n\n        Example:\n            with container.use_overrides({LOGGER: fake_logger}):\n                svc = container.get(SERVICE)\n                ...\n        \"\"\"\n        parent = self._overrides.get()\n        merged: dict[Token[object], object] = dict(parent) if parent else {}\n        merged.update(cast(dict[Token[object], object], mapping))\n        token: CtxToken[dict[Token[object], object] | None] = self._overrides.set(\n            merged\n        )\n        try:\n            yield\n        finally:\n            self._overrides.reset(token)\n\n    def clear_overrides(self) -&gt; None:\n        \"\"\"Clear all overrides for the current context.\"\"\"\n        if self._overrides.get() is not None:\n            self._overrides.set(None)\n\n    # ============= Validation &amp; Resource Tracking =============\n\n    def _validate_and_track(self, token: Token[Any], instance: object) -&gt; None:\n        if not token.validate(instance):\n            raise TypeError(\n                f\"Provider for token '{token.name}' returned {type(instance).__name__}, expected {token.type_.__name__}\"\n            )\n</code></pre>"},{"location":"api/#pyinj.container.Container.__init__","title":"<code>__init__()</code>","text":"<p>Initialize enhanced container.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize enhanced container.\"\"\"\n    super().__init__()\n\n    # Token factory for convenient creation\n    self.tokens: TokenFactory = TokenFactory()\n\n    # Given instances (Scala-inspired)\n    self._given_providers: dict[type[object], ProviderSync[object]] = {}\n\n    # Override less-precise base attributes with typed variants\n    self._providers: dict[Token[object], ProviderLike[object]] = {}\n    self._registrations: dict[Token[object], _Registration[object]] = {}\n    self._token_scopes: dict[Token[object], Scope] = {}\n    self._singletons: dict[Token[object], object] = {}\n    self._async_locks: dict[Token[object], asyncio.Lock] = {}\n\n    # Performance metrics\n    self._resolution_times: deque[float] = deque(maxlen=1000)\n    self._cache_hits: int = 0\n    self._cache_misses: int = 0\n\n    # Thread safety\n    self._lock: threading.RLock = threading.RLock()\n    self._singleton_locks: dict[Token[object], threading.Lock] = defaultdict(\n        threading.Lock\n    )\n\n    # Track dependencies for graph\n    self._dependencies: dict[Token[object], set[Token[object]]] = defaultdict(set)\n\n    # Per-context overrides (DI_SPEC requirement)\n    self._overrides: ContextVar[dict[Token[object], object] | None] = ContextVar(\n        \"pyinj_overrides\",\n        default=None,\n    )\n\n    # Resolution stack is tracked via ContextVar (task-local)\n\n    # Fast type-to-token index for O(1) resolution by type\n    self._type_index: dict[type[object], Token[object]] = {}\n    # Container-level cleanup stacks for singleton context-managed resources\n    self._singleton_cleanup_sync: list[Callable[[], None]] = []\n    self._singleton_cleanup_async: list[Callable[[], Awaitable[None]]] = []\n\n    # Auto-register classes marked with Injectable metaclass (plain DI)\n    self._auto_register()\n</code></pre>"},{"location":"api/#pyinj.container.Container.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Async close: close tracked resources and clear caches.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"Async close: close tracked resources and clear caches.\"\"\"\n    await self.__aexit__(None, None, None)\n    self.clear()\n</code></pre>"},{"location":"api/#pyinj.container.Container.aget","title":"<code>aget(token)</code>  <code>async</code>","text":"<p>Resolve a dependency asynchronously.</p> <p>Equivalent to :meth:<code>get</code> but awaits async providers and uses async locks for singleton initialization.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def aget(self, token: Token[U] | type[U]) -&gt; U:\n    \"\"\"Resolve a dependency asynchronously.\n\n    Equivalent to :meth:`get` but awaits async providers and uses\n    async locks for singleton initialization.\n    \"\"\"\n    # Convert to token if needed\n    if isinstance(token, type):\n        given = self.resolve_given(token)\n        if given is not None:\n            return given\n    token = self._coerce_to_token(token)\n    token = self._canonicalize(token)\n\n    # Check per-context overrides first\n    override = self._get_override(token)\n    if override is not None:\n        self._cache_hits += 1\n        return override\n\n    # Check context first\n    instance = self.resolve_from_context(token)\n    if instance is not None:\n        self._cache_hits += 1\n        return instance\n\n    self._cache_misses += 1\n\n    with self._resolution_guard(token):\n        obj_token = cast(Token[object], token)\n        reg = self._registrations.get(obj_token)\n        effective_scope = self._get_scope(token)\n        if reg and reg.cleanup is CleanupMode.CONTEXT_ASYNC:\n            if effective_scope == Scope.SINGLETON:\n                lock = self._ensure_async_lock(token)\n                async with lock:\n                    cached = self._get_singleton_cached(token)\n                    if cached is not None:\n                        return cached\n                    cm = reg.provider()\n                    value = await cm.__aenter__()\n                    self._set_singleton_cached(token, value)\n                    self._singleton_cleanup_async.append(lambda cm=cm: cm.__aexit__(None, None, None))\n                    self._resources.append(value)\n                    return cast(U, value)\n            else:\n                cm = reg.provider()\n                value = await cm.__aenter__()\n                self.store_in_context(token, value)\n                if effective_scope == Scope.REQUEST:\n                    self._register_request_cleanup_async(lambda cm=cm: cm.__aexit__(None, None, None))\n                elif effective_scope == Scope.SESSION:\n                    self._register_session_cleanup_async(lambda cm=cm: cm.__aexit__(None, None, None))\n                self._resources.append(value)\n                return cast(U, value)\n\n        # fallback legacy providers\n        provider = self._get_provider(token)\n        if effective_scope == Scope.SINGLETON:\n            lock = self._ensure_async_lock(token)\n            async with lock:\n                cached = self._get_singleton_cached(token)\n                if cached is not None:\n                    return cached\n\n                if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                    instance = await cast(ProviderAsync[U], provider)()\n                else:\n                    instance = cast(ProviderSync[U], provider)()\n                self._validate_and_track(token, instance)\n                self._set_singleton_cached(token, instance)\n                return instance\n        else:\n            if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                instance = await cast(ProviderAsync[U], provider)()\n            else:\n                instance = cast(ProviderSync[U], provider)()\n            self._validate_and_track(token, instance)\n            if effective_scope in (Scope.REQUEST, Scope.SESSION):\n                self.store_in_context(token, instance)\n            return instance\n</code></pre>"},{"location":"api/#pyinj.container.Container.batch_register","title":"<code>batch_register(registrations)</code>","text":"<p>Register multiple dependencies at once.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def batch_register(\n    self, registrations: list[tuple[Token[object], ProviderLike[object]]]\n) -&gt; Container:\n    \"\"\"Register multiple dependencies at once.\"\"\"\n    for token, provider in registrations:\n        self.register(token, provider)\n    return self\n</code></pre>"},{"location":"api/#pyinj.container.Container.batch_resolve","title":"<code>batch_resolve(tokens)</code>","text":"<p>Resolve multiple dependencies efficiently (sync).</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def batch_resolve(self, tokens: list[Token[object]]) -&gt; dict[Token[object], object]:\n    \"\"\"Resolve multiple dependencies efficiently (sync).\"\"\"\n    sorted_tokens = sorted(tokens, key=lambda t: t.scope.value)\n    results: dict[Token[object], object] = {}\n    for _scope, group in groupby(sorted_tokens, key=lambda t: t.scope):\n        group_list = list(group)\n        for tk in group_list:\n            results[tk] = self.get(tk)\n    return results\n</code></pre>"},{"location":"api/#pyinj.container.Container.batch_resolve_async","title":"<code>batch_resolve_async(tokens)</code>  <code>async</code>","text":"<p>Async batch resolution with parallel execution.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def batch_resolve_async(\n    self, tokens: list[Token[object]]\n) -&gt; dict[Token[object], object]:\n    \"\"\"Async batch resolution with parallel execution.\"\"\"\n    tasks = {token: self.aget(token) for token in tokens}\n    results_list: list[object] = await asyncio.gather(*tasks.values())\n    return dict(zip(tasks.keys(), results_list, strict=True))\n</code></pre>"},{"location":"api/#pyinj.container.Container.clear","title":"<code>clear()</code>","text":"<p>Clear caches and statistics; keep provider registrations intact.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear caches and statistics; keep provider registrations intact.\"\"\"\n    with self._lock:\n        self._singletons.clear()\n        self._transients.clear()\n        self._given_providers.clear()\n        self._dependencies.clear()\n        self._cache_hits = 0\n        self._cache_misses = 0\n        self._resolution_times.clear()\n    self.clear_all_contexts()\n</code></pre>"},{"location":"api/#pyinj.container.Container.clear_overrides","title":"<code>clear_overrides()</code>","text":"<p>Clear all overrides for the current context.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def clear_overrides(self) -&gt; None:\n    \"\"\"Clear all overrides for the current context.\"\"\"\n    if self._overrides.get() is not None:\n        self._overrides.set(None)\n</code></pre>"},{"location":"api/#pyinj.container.Container.dispose","title":"<code>dispose()</code>  <code>async</code>","text":"<p>Alias for aclose to align with tests and docs.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>async def dispose(self) -&gt; None:\n    \"\"\"Alias for aclose to align with tests and docs.\"\"\"\n    await self.aclose()\n</code></pre>"},{"location":"api/#pyinj.container.Container.get","title":"<code>get(token)</code>","text":"<p>Resolve a dependency synchronously.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[U] | type[U]</code> <p>The <code>Token[T]</code> or <code>type[T]</code> to resolve.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The resolved instance.</p> <p>Raises:</p> Type Description <code>ResolutionError</code> <p>If no provider is registered or resolution fails.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def get(self, token: Token[U] | type[U]) -&gt; U:\n    \"\"\"Resolve a dependency synchronously.\n\n    Args:\n        token: The ``Token[T]`` or ``type[T]`` to resolve.\n\n    Returns:\n        The resolved instance.\n\n    Raises:\n        ResolutionError: If no provider is registered or resolution fails.\n    \"\"\"\n    # Convert to token if needed and handle givens\n    if isinstance(token, type):\n        given = self.resolve_given(token)\n        if given is not None:\n            return given\n    token = self._coerce_to_token(token)\n    token = self._canonicalize(token)\n\n    # Check per-context overrides first\n    override = self._get_override(token)\n    if override is not None:\n        self._cache_hits += 1\n        return override\n\n    # Check context first (for request/session stored instances)\n    instance = self.resolve_from_context(token)\n    if instance is not None:\n        self._cache_hits += 1\n        return instance\n\n    self._cache_misses += 1\n\n    with self._resolution_guard(token):\n        obj_token = cast(Token[object], token)\n        reg = self._registrations.get(obj_token)\n        effective_scope = self._get_scope(token)\n        if reg and reg.cleanup is CleanupMode.CONTEXT_ASYNC:\n            # cannot enter async context in sync path\n            raise ResolutionError(\n                token,\n                [],\n                \"Context-managed provider is async; Use aget() for async providers\",\n            )\n        if reg and reg.cleanup is CleanupMode.CONTEXT_SYNC:\n            # handle context-managed sync\n            if effective_scope == Scope.SINGLETON:\n                with self._singleton_locks[self._obj_token(token)]:\n                    cached = self._get_singleton_cached(token)\n                    if cached is not None:\n                        return cached\n                    cm = reg.provider()\n                    value = cm.__enter__()\n                    self._set_singleton_cached(token, value)\n                    # schedule cleanup\n                    self._singleton_cleanup_sync.append(lambda cm=cm: cm.__exit__(None, None, None))\n                    self._resources.append(value)\n                    return cast(U, value)\n            else:\n                cm = reg.provider()\n                value = cm.__enter__()\n                self.store_in_context(token, value)\n                # register per-scope cleanup\n                if effective_scope == Scope.REQUEST:\n                    self._register_request_cleanup_sync(lambda cm=cm: cm.__exit__(None, None, None))\n                elif effective_scope == Scope.SESSION:\n                    self._register_session_cleanup_sync(lambda cm=cm: cm.__exit__(None, None, None))\n                self._resources.append(value)\n                return cast(U, value)\n\n        provider = self._get_provider(token)\n        # legacy non-context providers\n        if effective_scope == Scope.SINGLETON:\n            with self._singleton_locks[self._obj_token(token)]:\n                cached = self._get_singleton_cached(token)\n                if cached is not None:\n                    return cached\n                if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                    raise ResolutionError(\n                        token,\n                        [],\n                        \"Provider is async; Use aget() for async providers\",\n                    )\n                instance = cast(ProviderSync[U], provider)()\n                self._validate_and_track(token, instance)\n                self._set_singleton_cached(token, instance)\n                return instance\n        else:\n            if asyncio.iscoroutinefunction(cast(Callable[..., Any], provider)):\n                raise ResolutionError(\n                    token,\n                    [],\n                    \"Provider is async; Use aget() for async providers\",\n                )\n            instance = cast(ProviderSync[U], provider)()\n            self._validate_and_track(token, instance)\n            # Only store in context for REQUEST/SESSION\n            if effective_scope in (Scope.REQUEST, Scope.SESSION):\n                self.store_in_context(token, instance)\n            return instance\n</code></pre>"},{"location":"api/#pyinj.container.Container.get_providers_view","title":"<code>get_providers_view()</code>","text":"<p>Return a read-only view of registered providers.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def get_providers_view(\n    self,\n) -&gt; MappingProxyType[Token[object], ProviderLike[object]]:\n    \"\"\"Return a read-only view of registered providers.\"\"\"\n    return MappingProxyType(self._providers)\n</code></pre>"},{"location":"api/#pyinj.container.Container.given","title":"<code>given(type_, provider)</code>","text":"<p>Register a given instance for a type (Scala-style).</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def given(self, type_: type[U], provider: ProviderSync[U] | U) -&gt; \"Container\":\n    \"\"\"Register a given instance for a type (Scala-style).\"\"\"\n    if callable(provider):\n        self._given_providers[type_] = cast(ProviderSync[object], provider)\n    else:\n        # Wrap value in lambda\n        self._given_providers[type_] = lambda p=provider: p\n\n    return self\n</code></pre>"},{"location":"api/#pyinj.container.Container.has","title":"<code>has(token)</code>","text":"<p>Return True if the token/type is known to the container.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def has(self, token: Token[Any] | type[Any]) -&gt; bool:\n    \"\"\"Return True if the token/type is known to the container.\"\"\"\n    if isinstance(token, type):\n        if token in self._given_providers:\n            return True\n        token = Token(token.__name__, token)\n    obj_token = cast(Token[object], token)\n    return obj_token in self._providers or obj_token in self._singletons\n</code></pre>"},{"location":"api/#pyinj.container.Container.inject","title":"<code>inject(func=None, *, cache=True)</code>","text":"<p>Alias to pyinj.injection.inject bound to this container.</p> <p>Enables <code>@container.inject</code> usage in addition to <code>@inject(container=container)</code>.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def inject(\n    self, func: Callable[..., Any] | None = None, *, cache: bool = True\n) -&gt; Callable[..., Any]:\n    \"\"\"Alias to pyinj.injection.inject bound to this container.\n\n    Enables ``@container.inject`` usage in addition to\n    ``@inject(container=container)``.\n    \"\"\"\n    from .injection import inject as _inject\n\n    if func is None:\n        return _inject(container=self, cache=cache)\n    return _inject(func, container=self, cache=cache)\n</code></pre>"},{"location":"api/#pyinj.container.Container.override","title":"<code>override(token, value)</code>","text":"<p>Override a dependency for the current concurrent context only.</p> <p>Uses a ContextVar-backed mapping so overrides are isolated between threads/tasks. Prefer <code>use_overrides</code> for scoped overrides.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def override(self, token: Token[U], value: U) -&gt; None:\n    \"\"\"Override a dependency for the current concurrent context only.\n\n    Uses a ContextVar-backed mapping so overrides are isolated between\n    threads/tasks. Prefer ``use_overrides`` for scoped overrides.\n    \"\"\"\n    parent = self._overrides.get()\n    merged: dict[Token[object], object] = dict(parent) if parent else {}\n    merged[cast(Token[object], token)] = value\n    self._overrides.set(merged)\n</code></pre>"},{"location":"api/#pyinj.container.Container.register","title":"<code>register(token, provider, scope=None, *, tags=())</code>","text":"<p>Register a provider for a token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[U] | type[U]</code> <p>A <code>Token[T]</code> or a concrete <code>type[T]</code>. If a type is provided, a token is created automatically.</p> required <code>provider</code> <code>ProviderLike[U]</code> <p>Callable that returns the dependency instance.</p> required <code>scope</code> <code>Scope | None</code> <p>Optional lifecycle override (defaults to token.scope or TRANSIENT).</p> <code>None</code> <code>tags</code> <code>tuple[str, ...]</code> <p>Optional tags for discovery/metadata.</p> <code>()</code> <p>Returns:</p> Type Description <code>'Container'</code> <p>Self, to allow method chaining.</p> Example <p>container.register(TokenDB, create_db, scope=Scope.SINGLETON)</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register(\n    self,\n    token: Token[U] | type[U],\n    provider: ProviderLike[U],\n    scope: Scope | None = None,\n    *,\n    tags: tuple[str, ...] = (),\n) -&gt; \"Container\":\n    \"\"\"Register a provider for a token.\n\n    Args:\n        token: A ``Token[T]`` or a concrete ``type[T]``. If a type is\n            provided, a token is created automatically.\n        provider: Callable that returns the dependency instance.\n        scope: Optional lifecycle override (defaults to token.scope or TRANSIENT).\n        tags: Optional tags for discovery/metadata.\n\n    Returns:\n        Self, to allow method chaining.\n\n    Example:\n        container.register(Token[DB](\"db\"), create_db, scope=Scope.SINGLETON)\n    \"\"\"\n    # Validate token type\n    if not isinstance(token, (Token, type)):\n        raise TypeError(\n            \"Token specification must be a Token or type; strings are not supported\"\n        )\n\n    # Convert to Token if needed\n    if isinstance(token, type):\n        token = self.tokens.create(\n            token.__name__, token, scope=scope or Scope.TRANSIENT, tags=tags\n        )\n    elif scope is not None:\n        # Record desired scope without changing the token identity\n        self._token_scopes[cast(Token[object], token)] = scope\n\n    # Validate provider\n    if not callable(provider):\n        raise TypeError(\n            f\"Provider must be callable, got {type(provider).__name__}\\n\"\n            f\"  Fix: Pass a function or lambda that returns an instance\\n\"\n            f\"  Example: container.register(token, lambda: {token.type_.__name__}())\"\n        )\n\n    with self._lock:\n        obj_token = cast(Token[object], token)\n        # Enforce immutable registrations\n        if obj_token in self._providers or obj_token in self._registrations or obj_token in self._singletons:\n            raise ValueError(f\"Token '{obj_token.name}' is already registered\")\n        self._providers[obj_token] = cast(ProviderLike[object], provider)\n        self._registrations[obj_token] = _Registration(\n            provider=cast(Callable[[], Any], provider), cleanup=CleanupMode.NONE\n        )\n        # Update type index\n        self._type_index[obj_token.type_] = obj_token\n\n    return self  # Enable chaining\n</code></pre>"},{"location":"api/#pyinj.container.Container.register_context","title":"<code>register_context(token, cm_provider, *, is_async, scope=None)</code>","text":"<pre><code>register_context(token: Token[U] | type[U], cm_provider: Callable[[], ContextManager[U]], *, is_async: Literal[False], scope: Scope | None = None) -&gt; 'Container'\n</code></pre><pre><code>register_context(token: Token[U] | type[U], cm_provider: Callable[[], AsyncContextManager[U]], *, is_async: Literal[True], scope: Scope | None = None) -&gt; 'Container'\n</code></pre> <p>Register a context-managed dependency.</p> <ul> <li>When <code>is_async=False</code>, <code>cm_provider</code> must return a <code>ContextManager[T]</code>.</li> <li>When <code>is_async=True</code>, <code>cm_provider</code> must return an <code>AsyncContextManager[T]</code>.</li> </ul> <p>The context is entered on first resolution within the declared scope and exited during scope cleanup (request/session), or on container close for singletons.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_context(\n    self,\n    token: Token[U] | type[U],\n    cm_provider: Callable[[], Any],\n    *,\n    is_async: bool,\n    scope: Scope | None = None,\n) -&gt; \"Container\":\n    \"\"\"Register a context-managed dependency.\n\n    - When ``is_async=False``, ``cm_provider`` must return a ``ContextManager[T]``.\n    - When ``is_async=True``, ``cm_provider`` must return an ``AsyncContextManager[T]``.\n\n    The context is entered on first resolution within the declared scope and\n    exited during scope cleanup (request/session), or on container close for\n    singletons.\n    \"\"\"\n    # Validate token\n    if not isinstance(token, (Token, type)):\n        raise TypeError(\n            \"Token specification must be a Token or type; strings are not supported\"\n        )\n    # To token\n    if isinstance(token, type):\n        token = self.tokens.create(token.__name__, token, scope=scope or Scope.TRANSIENT)\n    elif scope is not None:\n        self._token_scopes[cast(Token[object], token)] = scope\n\n    if not callable(cm_provider):\n        raise TypeError(\"cm_provider must be callable and return a (async) context manager\")\n\n    with self._lock:\n        obj_token = cast(Token[object], token)\n        # Enforce immutable registrations\n        if obj_token in self._providers or obj_token in self._registrations or obj_token in self._singletons:\n            raise ValueError(f\"Token '{obj_token.name}' is already registered\")\n        self._registrations[obj_token] = _Registration(\n            provider=cm_provider,\n            cleanup=CleanupMode.CONTEXT_ASYNC if is_async else CleanupMode.CONTEXT_SYNC,\n        )\n        self._type_index[obj_token.type_] = obj_token\n    return self\n</code></pre>"},{"location":"api/#pyinj.container.Container.register_context_async","title":"<code>register_context_async(token, cm_provider, *, scope=None)</code>","text":"<p>Typed helper to register an async context-managed provider.</p> <p>Equivalent to <code>register_context(..., is_async=True)</code>.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_context_async(\n    self,\n    token: Token[U] | type[U],\n    cm_provider: Callable[[], AsyncContextManager[U]],\n    *,\n    scope: Scope | None = None,\n) -&gt; \"Container\":\n    \"\"\"Typed helper to register an async context-managed provider.\n\n    Equivalent to ``register_context(..., is_async=True)``.\n    \"\"\"\n    return self.register_context(token, cm_provider, is_async=True, scope=scope)\n</code></pre>"},{"location":"api/#pyinj.container.Container.register_context_sync","title":"<code>register_context_sync(token, cm_provider, *, scope=None)</code>","text":"<p>Typed helper to register a sync context-managed provider.</p> <p>Equivalent to <code>register_context(..., is_async=False)</code>.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_context_sync(\n    self,\n    token: Token[U] | type[U],\n    cm_provider: Callable[[], ContextManager[U]],\n    *,\n    scope: Scope | None = None,\n) -&gt; \"Container\":\n    \"\"\"Typed helper to register a sync context-managed provider.\n\n    Equivalent to ``register_context(..., is_async=False)``.\n    \"\"\"\n    return self.register_context(token, cm_provider, is_async=False, scope=scope)\n</code></pre>"},{"location":"api/#pyinj.container.Container.register_request","title":"<code>register_request(token, provider)</code>","text":"<p>Register a request-scoped dependency.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_request(\n    self, token: Token[U] | type[U], provider: ProviderLike[U]\n) -&gt; \"Container\":\n    \"\"\"Register a request-scoped dependency.\"\"\"\n    return self.register(token, provider, scope=Scope.REQUEST)\n</code></pre>"},{"location":"api/#pyinj.container.Container.register_singleton","title":"<code>register_singleton(token, provider)</code>","text":"<p>Register a singleton-scoped dependency.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_singleton(\n    self, token: Token[U] | type[U], provider: ProviderLike[U]\n) -&gt; \"Container\":\n    \"\"\"Register a singleton-scoped dependency.\"\"\"\n    return self.register(token, provider, scope=Scope.SINGLETON)\n</code></pre>"},{"location":"api/#pyinj.container.Container.register_transient","title":"<code>register_transient(token, provider)</code>","text":"<p>Register a transient-scoped dependency.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_transient(\n    self, token: Token[U] | type[U], provider: ProviderLike[U]\n) -&gt; \"Container\":\n    \"\"\"Register a transient-scoped dependency.\"\"\"\n    return self.register(token, provider, scope=Scope.TRANSIENT)\n</code></pre>"},{"location":"api/#pyinj.container.Container.register_value","title":"<code>register_value(token, value)</code>","text":"<p>Register a pre-created value as a singleton.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def register_value(self, token: Token[U] | type[U], value: U) -&gt; \"Container\":\n    \"\"\"Register a pre-created value as a singleton.\"\"\"\n    if isinstance(token, type):\n        token = self.tokens.singleton(token.__name__, token)\n    # token is now a Token[Any]\n\n    # Store directly as singleton (immutable)\n    obj_token = cast(Token[object], token)\n    if obj_token in self._providers or obj_token in self._registrations or obj_token in self._singletons:\n        raise ValueError(f\"Token '{obj_token.name}' is already registered\")\n    self._singletons[obj_token] = value\n    return self\n</code></pre>"},{"location":"api/#pyinj.container.Container.resolve_given","title":"<code>resolve_given(type_)</code>","text":"<p>Resolve a given instance by type.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def resolve_given(self, type_: type[U]) -&gt; U | None:\n    \"\"\"Resolve a given instance by type.\"\"\"\n    provider = self._given_providers.get(type_)\n    if provider:\n        return cast(ProviderSync[U], provider)()\n    return None\n</code></pre>"},{"location":"api/#pyinj.container.Container.resources_view","title":"<code>resources_view()</code>","text":"<p>Return a read-only snapshot of tracked resources for tests/inspection.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>def resources_view(self) -&gt; tuple[SupportsClose | SupportsAsyncClose, ...]:\n    \"\"\"Return a read-only snapshot of tracked resources for tests/inspection.\"\"\"\n    return tuple(self._resources)\n</code></pre>"},{"location":"api/#pyinj.container.Container.use_overrides","title":"<code>use_overrides(mapping)</code>","text":"<p>Temporarily override tokens for this concurrent context.</p> Example <p>with container.use_overrides({LOGGER: fake_logger}):     svc = container.get(SERVICE)     ...</p> Source code in <code>src/pyinj/container.py</code> <pre><code>@contextmanager\ndef use_overrides(self, mapping: dict[Token[Any], object]) -&gt; Iterator[None]:\n    \"\"\"Temporarily override tokens for this concurrent context.\n\n    Example:\n        with container.use_overrides({LOGGER: fake_logger}):\n            svc = container.get(SERVICE)\n            ...\n    \"\"\"\n    parent = self._overrides.get()\n    merged: dict[Token[object], object] = dict(parent) if parent else {}\n    merged.update(cast(dict[Token[object], object], mapping))\n    token: CtxToken[dict[Token[object], object] | None] = self._overrides.set(\n        merged\n    )\n    try:\n        yield\n    finally:\n        self._overrides.reset(token)\n</code></pre>"},{"location":"api/#pyinj.container.Container.using","title":"<code>using(mapping=None, **givens)</code>","text":"<p>Temporarily register \"given\" instances for the current block.</p> <p>Supports both an explicit mapping of types to instances and keyword arguments that match type names previously registered via <code>given()</code>.</p> Source code in <code>src/pyinj/container.py</code> <pre><code>@contextmanager\ndef using(\n    self,\n    mapping: Mapping[type[object], object] | None = None,\n    **givens: object,\n) -&gt; Iterator[Container]:\n    \"\"\"Temporarily register \"given\" instances for the current block.\n\n    Supports both an explicit mapping of types to instances and\n    keyword arguments that match type names previously registered\n    via ``given()``.\n    \"\"\"\n    old_givens = self._given_providers.copy()\n\n    # Apply explicit mapping first (precise and type-safe)\n    if mapping:\n        for t, instance in mapping.items():\n            self.given(t, instance)\n\n    # Support kwargs by matching on type name for already-known givens\n    if givens:\n        known_types = list(self._given_providers.keys())\n        for name, instance in givens.items():\n            for t in known_types:\n                if getattr(t, \"__name__\", \"\") == name:\n                    self.given(t, instance)\n                    break\n\n    try:\n        yield self\n    finally:\n        self._given_providers = old_givens\n</code></pre>"},{"location":"api/#contextual-scopes","title":"Contextual Scopes","text":"<p>Contextual abstractions for dependency injection using contextvars.</p>"},{"location":"api/#pyinj.contextual.ContextualContainer","title":"<code>ContextualContainer</code>","text":"<p>Base container adding request/session context via <code>contextvars</code>.</p> <p>Context flows implicitly across awaits; request/session lifetimes are enforced by the :class:<code>ScopeManager</code>.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>class ContextualContainer:\n    \"\"\"Base container adding request/session context via ``contextvars``.\n\n    Context flows implicitly across awaits; request/session lifetimes\n    are enforced by the :class:`ScopeManager`.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize contextual container.\"\"\"\n        # Singleton cache (process-wide)\n        self._singletons: dict[Token[object], object] = {}\n\n        # Weak cache for transients (auto-cleanup)\n        self._transients: WeakValueDictionary[Token[object], object] = (\n            WeakValueDictionary()\n        )\n\n        # Providers registry (value type depends on concrete container)\n        self._providers: dict[Token[object], Any] = {}\n\n        # Async locks for thread-safe singleton creation\n        self._async_locks: dict[Token[object], asyncio.Lock] = {}\n\n        # Track resources for cleanup\n        from .protocols import SupportsAsyncClose, SupportsClose\n\n        self._resources: list[SupportsClose | SupportsAsyncClose] = []\n\n        # Scope manager (RAII contexts, precedence enforcement)\n        self._scope_manager = ScopeManager(self)\n\n    # ---- Registration of per-scope cleanup operations (used by Container) ----\n\n    def _register_request_cleanup_sync(self, fn: Callable[[], None]) -&gt; None:\n        \"\"\"Register a sync cleanup for the current request scope.\n\n        Internal API called by the container when a sync context-managed resource\n        is entered within a request scope. Cleanups run in LIFO order on scope exit.\n        \"\"\"\n        stack = _request_cleanup_sync.get()\n        if stack is None:\n            raise RuntimeError(\"No active request scope for registering cleanup\")\n        stack.append(fn)\n\n    def _register_request_cleanup_async(\n        self, fn: Callable[[], Awaitable[None]]\n    ) -&gt; None:\n        \"\"\"Register an async cleanup for the current request scope.\n\n        Internal API called by the container for async context-managed resources.\n        Cleanups run before sync cleanups on async scope exit.\n        \"\"\"\n        stack = _request_cleanup_async.get()\n        if stack is None:\n            raise RuntimeError(\"No active request scope for registering async cleanup\")\n        stack.append(fn)\n\n    def _register_session_cleanup_sync(self, fn: Callable[[], None]) -&gt; None:\n        \"\"\"Register a sync cleanup for the active session scope.\n\n        Internal API used for session-scoped sync context-managed resources.\n        \"\"\"\n        stack = _session_cleanup_sync.get()\n        if stack is None:\n            raise RuntimeError(\"No active session scope for registering cleanup\")\n        stack.append(fn)\n\n    def _register_session_cleanup_async(\n        self, fn: Callable[[], Awaitable[None]]\n    ) -&gt; None:\n        \"\"\"Register an async cleanup for the active session scope.\n\n        Internal API used for session-scoped async context-managed resources.\n        \"\"\"\n        stack = _session_cleanup_async.get()\n        if stack is None:\n            raise RuntimeError(\"No active session scope for registering async cleanup\")\n        stack.append(fn)\n\n    def _put_in_current_request_cache(self, token: Token[T], instance: T) -&gt; None:\n        \"\"\"Insert a value into the current request cache unconditionally.\n\n        This bypasses scope checks and is intended for temporary overrides\n        that should only affect the current context.\n        \"\"\"\n        context = _context_stack.get()\n        if context is not None and hasattr(context, \"maps\") and len(context.maps) &gt; 0:\n            # The top-most map holds request-local values\n            context.maps[0][cast(Token[object], token)] = cast(object, instance)\n\n    @contextmanager\n    def request_scope(self) -&gt; Iterator[ContextualContainer]:\n        \"\"\"Create a request scope (similar to a web request lifecycle).\n\n        Example:\n            with container.request_scope():\n                service = container.get(ServiceToken)\n\n        Yields:\n            Self for chaining.\n        \"\"\"\n        with self._scope_manager.request_scope():\n            yield self\n\n    @asynccontextmanager\n    async def async_request_scope(self) -&gt; AsyncIterator[ContextualContainer]:\n        \"\"\"Async context manager variant of :meth:`request_scope`.\n\n        Example:\n            async with container.async_request_scope():\n                service = await container.aget(ServiceToken)\n        \"\"\"\n        async with self._scope_manager.async_request_scope():\n            yield self\n\n    @contextmanager\n    def session_scope(self) -&gt; Iterator[ContextualContainer]:\n        \"\"\"\n        Create a session scope (longer-lived than request).\n\n        Session scopes persist across multiple requests but are\n        isolated between different sessions (e.g., users).\n        \"\"\"\n        with self._scope_manager.session_scope():\n            yield self\n\n    def _cleanup_scope(self, cache: dict[Token[object], Any]) -&gt; None:\n        \"\"\"\n        Clean up resources in LIFO order.\n\n        Args:\n            cache: Cache of resources to clean up\n        \"\"\"\n        for resource in reversed(list(cache.values())):\n            try:\n                # Early fail if async cleanup is required in a sync context\n                aclose = getattr(resource, \"aclose\", None)\n                aexit = getattr(resource, \"__aexit__\", None)\n                supports_sync = hasattr(resource, \"close\") or hasattr(\n                    resource, \"__exit__\"\n                )\n                if (\n                    (aclose and inspect.iscoroutinefunction(aclose))\n                    or (aexit and inspect.iscoroutinefunction(aexit))\n                ) and not supports_sync:\n                    raise AsyncCleanupRequiredError(\n                        type(resource).__name__,\n                        \"Use an async request/session scope.\",\n                    )\n                close = getattr(resource, \"close\", None)\n                if close is not None and inspect.iscoroutinefunction(close):\n                    raise AsyncCleanupRequiredError(\n                        type(resource).__name__,\n                        \"Use an async request/session scope.\",\n                    )\n                # Prefer context-manager exit over ad-hoc close for sync path\n                if hasattr(resource, \"__exit__\"):\n                    resource.__exit__(None, None, None)\n                elif close is not None:\n                    close()\n            except AsyncCleanupRequiredError:\n                raise\n            except Exception:\n                # Log but don't fail cleanup\n                pass\n\n    async def _async_cleanup_scope(self, cache: dict[Token[object], Any]) -&gt; None:\n        \"\"\"\n        Async cleanup of resources.\n\n        Args:\n            cache: Cache of resources to clean up\n        \"\"\"\n        tasks: list[Any] = []\n        loop = asyncio.get_running_loop()\n\n        for resource in reversed(list(cache.values())):\n            aclose = getattr(resource, \"aclose\", None)\n            if aclose and callable(aclose):\n                res = aclose()\n                if inspect.isawaitable(res):\n                    tasks.append(res)\n                    continue\n            aexit = getattr(resource, \"__aexit__\", None)\n            if aexit and callable(aexit):\n                res = aexit(None, None, None)\n                if inspect.isawaitable(res):\n                    tasks.append(res)\n                    continue\n            close = getattr(resource, \"close\", None)\n            if close:\n                if inspect.iscoroutinefunction(close):\n                    tasks.append(close())\n                else:\n                    tasks.append(loop.run_in_executor(None, close))\n\n        if tasks:\n            # Gather with return_exceptions to prevent one failure from stopping others\n            await asyncio.gather(*tasks, return_exceptions=True)\n\n    def resolve_from_context(self, token: Token[T]) -&gt; T | None:\n        \"\"\"\n        Resolve dependency from current context.\n\n        Args:\n            token: Token to resolve\n\n        Returns:\n            Resolved instance or None if not in context\n        \"\"\"\n        return self._scope_manager.resolve_from_context(token)\n\n    def store_in_context(self, token: Token[T], instance: T) -&gt; None:\n        \"\"\"\n        Store instance in appropriate context.\n\n        Args:\n            token: Token for the instance\n            instance: Instance to store\n        \"\"\"\n        self._scope_manager.store_in_context(token, instance)\n\n    def clear_request_context(self) -&gt; None:\n        \"\"\"Clear current request context.\"\"\"\n        self._scope_manager.clear_request_context()\n\n    def clear_session_context(self) -&gt; None:\n        \"\"\"Clear current session context.\"\"\"\n        self._scope_manager.clear_session_context()\n\n    def clear_all_contexts(self) -&gt; None:\n        \"\"\"Clear all contexts including singletons.\"\"\"\n        self._scope_manager.clear_all_contexts()\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.__init__","title":"<code>__init__()</code>","text":"<p>Initialize contextual container.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize contextual container.\"\"\"\n    # Singleton cache (process-wide)\n    self._singletons: dict[Token[object], object] = {}\n\n    # Weak cache for transients (auto-cleanup)\n    self._transients: WeakValueDictionary[Token[object], object] = (\n        WeakValueDictionary()\n    )\n\n    # Providers registry (value type depends on concrete container)\n    self._providers: dict[Token[object], Any] = {}\n\n    # Async locks for thread-safe singleton creation\n    self._async_locks: dict[Token[object], asyncio.Lock] = {}\n\n    # Track resources for cleanup\n    from .protocols import SupportsAsyncClose, SupportsClose\n\n    self._resources: list[SupportsClose | SupportsAsyncClose] = []\n\n    # Scope manager (RAII contexts, precedence enforcement)\n    self._scope_manager = ScopeManager(self)\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.async_request_scope","title":"<code>async_request_scope()</code>  <code>async</code>","text":"<p>Async context manager variant of :meth:<code>request_scope</code>.</p> Example <p>async with container.async_request_scope():     service = await container.aget(ServiceToken)</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>@asynccontextmanager\nasync def async_request_scope(self) -&gt; AsyncIterator[ContextualContainer]:\n    \"\"\"Async context manager variant of :meth:`request_scope`.\n\n    Example:\n        async with container.async_request_scope():\n            service = await container.aget(ServiceToken)\n    \"\"\"\n    async with self._scope_manager.async_request_scope():\n        yield self\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.clear_all_contexts","title":"<code>clear_all_contexts()</code>","text":"<p>Clear all contexts including singletons.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def clear_all_contexts(self) -&gt; None:\n    \"\"\"Clear all contexts including singletons.\"\"\"\n    self._scope_manager.clear_all_contexts()\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.clear_request_context","title":"<code>clear_request_context()</code>","text":"<p>Clear current request context.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def clear_request_context(self) -&gt; None:\n    \"\"\"Clear current request context.\"\"\"\n    self._scope_manager.clear_request_context()\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.clear_session_context","title":"<code>clear_session_context()</code>","text":"<p>Clear current session context.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def clear_session_context(self) -&gt; None:\n    \"\"\"Clear current session context.\"\"\"\n    self._scope_manager.clear_session_context()\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.request_scope","title":"<code>request_scope()</code>","text":"<p>Create a request scope (similar to a web request lifecycle).</p> Example <p>with container.request_scope():     service = container.get(ServiceToken)</p> <p>Yields:</p> Type Description <code>ContextualContainer</code> <p>Self for chaining.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>@contextmanager\ndef request_scope(self) -&gt; Iterator[ContextualContainer]:\n    \"\"\"Create a request scope (similar to a web request lifecycle).\n\n    Example:\n        with container.request_scope():\n            service = container.get(ServiceToken)\n\n    Yields:\n        Self for chaining.\n    \"\"\"\n    with self._scope_manager.request_scope():\n        yield self\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.resolve_from_context","title":"<code>resolve_from_context(token)</code>","text":"<p>Resolve dependency from current context.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[T]</code> <p>Token to resolve</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>Resolved instance or None if not in context</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def resolve_from_context(self, token: Token[T]) -&gt; T | None:\n    \"\"\"\n    Resolve dependency from current context.\n\n    Args:\n        token: Token to resolve\n\n    Returns:\n        Resolved instance or None if not in context\n    \"\"\"\n    return self._scope_manager.resolve_from_context(token)\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.session_scope","title":"<code>session_scope()</code>","text":"<p>Create a session scope (longer-lived than request).</p> <p>Session scopes persist across multiple requests but are isolated between different sessions (e.g., users).</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>@contextmanager\ndef session_scope(self) -&gt; Iterator[ContextualContainer]:\n    \"\"\"\n    Create a session scope (longer-lived than request).\n\n    Session scopes persist across multiple requests but are\n    isolated between different sessions (e.g., users).\n    \"\"\"\n    with self._scope_manager.session_scope():\n        yield self\n</code></pre>"},{"location":"api/#pyinj.contextual.ContextualContainer.store_in_context","title":"<code>store_in_context(token, instance)</code>","text":"<p>Store instance in appropriate context.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token[T]</code> <p>Token for the instance</p> required <code>instance</code> <code>T</code> <p>Instance to store</p> required Source code in <code>src/pyinj/contextual.py</code> <pre><code>def store_in_context(self, token: Token[T], instance: T) -&gt; None:\n    \"\"\"\n    Store instance in appropriate context.\n\n    Args:\n        token: Token for the instance\n        instance: Instance to store\n    \"\"\"\n    self._scope_manager.store_in_context(token, instance)\n</code></pre>"},{"location":"api/#pyinj.contextual.RequestScope","title":"<code>RequestScope</code>","text":"<p>Helper class for request-scoped dependencies.</p> Example <p>async with RequestScope(container) as scope:     service = scope.resolve(ServiceToken)</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>class RequestScope:\n    \"\"\"\n    Helper class for request-scoped dependencies.\n\n    Example:\n        async with RequestScope(container) as scope:\n            service = scope.resolve(ServiceToken)\n    \"\"\"\n\n    def __init__(self, container: ContextualContainer):\n        \"\"\"Initialize request scope.\"\"\"\n        self.container = container\n        self._context_manager = None\n        self._async_context_manager = None\n\n    def __enter__(self) -&gt; RequestScope:\n        \"\"\"Enter request scope.\"\"\"\n        self._context_manager = self.container.request_scope()\n        self._context_manager.__enter__()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Exit request scope.\"\"\"\n        if self._context_manager:\n            self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n\n    async def __aenter__(self) -&gt; RequestScope:\n        \"\"\"Async enter request scope.\"\"\"\n        self._async_context_manager = self.container.async_request_scope()\n        await self._async_context_manager.__aenter__()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Async exit request scope.\"\"\"\n        if self._async_context_manager:\n            await self._async_context_manager.__aexit__(exc_type, exc_val, exc_tb)\n\n    def resolve(self, token: Token[T]) -&gt; T | None:\n        \"\"\"Resolve dependency in this scope.\"\"\"\n        return self.container.resolve_from_context(token)\n</code></pre>"},{"location":"api/#pyinj.contextual.RequestScope.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Async enter request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>async def __aenter__(self) -&gt; RequestScope:\n    \"\"\"Async enter request scope.\"\"\"\n    self._async_context_manager = self.container.async_request_scope()\n    await self._async_context_manager.__aenter__()\n    return self\n</code></pre>"},{"location":"api/#pyinj.contextual.RequestScope.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Async exit request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Async exit request scope.\"\"\"\n    if self._async_context_manager:\n        await self._async_context_manager.__aexit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.contextual.RequestScope.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __enter__(self) -&gt; RequestScope:\n    \"\"\"Enter request scope.\"\"\"\n    self._context_manager = self.container.request_scope()\n    self._context_manager.__enter__()\n    return self\n</code></pre>"},{"location":"api/#pyinj.contextual.RequestScope.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit request scope.\"\"\"\n    if self._context_manager:\n        self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.contextual.RequestScope.__init__","title":"<code>__init__(container)</code>","text":"<p>Initialize request scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __init__(self, container: ContextualContainer):\n    \"\"\"Initialize request scope.\"\"\"\n    self.container = container\n    self._context_manager = None\n    self._async_context_manager = None\n</code></pre>"},{"location":"api/#pyinj.contextual.RequestScope.resolve","title":"<code>resolve(token)</code>","text":"<p>Resolve dependency in this scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def resolve(self, token: Token[T]) -&gt; T | None:\n    \"\"\"Resolve dependency in this scope.\"\"\"\n    return self.container.resolve_from_context(token)\n</code></pre>"},{"location":"api/#pyinj.contextual.ScopeManager","title":"<code>ScopeManager</code>","text":"<p>Scope orchestration with RAII managers and explicit precedence.</p> <p>Precedence: REQUEST &gt; SESSION &gt; SINGLETON. Uses ContextVars for async safety.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>class ScopeManager:\n    \"\"\"Scope orchestration with RAII managers and explicit precedence.\n\n    Precedence: REQUEST &gt; SESSION &gt; SINGLETON. Uses ContextVars for async safety.\n    \"\"\"\n\n    def __init__(self, container: ContextualContainer) -&gt; None:\n        self._container = container\n\n    @contextmanager\n    def request_scope(self) -&gt; Iterator[None]:\n        request_cache: dict[Token[object], object] = {}\n        current = _context_stack.get()\n        if current is None:\n            new_context = ChainMap(request_cache, self._container._singletons)\n        else:\n            new_context = ChainMap(request_cache, *current.maps)\n        token = _context_stack.set(new_context)\n        # Initialize per-request cleanup stacks\n        req_sync_token = _request_cleanup_sync.set([])\n        req_async_token = _request_cleanup_async.set([])\n        try:\n            yield\n        finally:\n            # Cleanup resources stored via context introspection (legacy path)\n            self._container._cleanup_scope(request_cache)\n            # Run explicit per-request cleanup stacks (LIFO)\n            try:\n                sync_fns = _request_cleanup_sync.get() or []\n                for fn in reversed(sync_fns):\n                    try:\n                        fn()\n                    except Exception:\n                        pass\n            finally:\n                _request_cleanup_sync.reset(req_sync_token)\n            _request_cleanup_async.reset(req_async_token)\n            _context_stack.reset(token)\n\n    @asynccontextmanager\n    async def async_request_scope(self) -&gt; AsyncIterator[None]:\n        request_cache: dict[Token[object], object] = {}\n        current = _context_stack.get()\n        if current is None:\n            new_context = ChainMap(request_cache, self._container._singletons)\n        else:\n            new_context = ChainMap(request_cache, *current.maps)\n        token = _context_stack.set(new_context)\n        # Initialize per-request cleanup stacks\n        req_sync_token = _request_cleanup_sync.set([])\n        req_async_token = _request_cleanup_async.set([])\n        try:\n            yield\n        finally:\n            # Async cleanup for resources stored via context introspection\n            await self._container._async_cleanup_scope(request_cache)\n            # Then run explicit per-request async cleanups (LIFO)\n            async_fns = _request_cleanup_async.get() or []\n            if async_fns:\n                await asyncio.gather(\n                    *[fn() for fn in reversed(async_fns)], return_exceptions=True\n                )\n            # Finally run any sync cleanups\n            sync_fns = _request_cleanup_sync.get() or []\n            for fn in reversed(sync_fns):\n                try:\n                    fn()\n                except Exception:\n                    pass\n            _request_cleanup_sync.reset(req_sync_token)\n            _request_cleanup_async.reset(req_async_token)\n            _context_stack.reset(token)\n\n    @contextmanager\n    def session_scope(self) -&gt; Iterator[None]:\n        existing = _session_context.get()\n        if existing is None:\n            session_cache: dict[Token[object], object] = {}\n            session_token = _session_context.set(session_cache)\n            # Only create new cleanup stacks when opening a new session\n            sess_sync_token = _session_cleanup_sync.set([])\n            sess_async_token = _session_cleanup_async.set([])\n        else:\n            session_cache = existing\n            session_token = None\n            sess_sync_token = None\n            sess_async_token = None\n        current = _context_stack.get()\n        if current is None:\n            new_context = ChainMap(session_cache, self._container._singletons)\n        else:\n            new_context = ChainMap(\n                current.maps[0], session_cache, self._container._singletons\n            )\n        context_token = _context_stack.set(new_context)\n        try:\n            yield\n        finally:\n            _context_stack.reset(context_token)\n            if session_token:\n                # Run explicit per-session cleanup stacks (LIFO) when session ends\n                try:\n                    sync_fns = _session_cleanup_sync.get() or []\n                    for fn in reversed(sync_fns):\n                        try:\n                            fn()\n                        except Exception:\n                            pass\n                finally:\n                    if sess_sync_token is not None:\n                        _session_cleanup_sync.reset(sess_sync_token)\n                if sess_async_token is not None:\n                    _session_cleanup_async.reset(sess_async_token)\n                _session_context.reset(session_token)\n\n    def resolve_from_context(self, token: Token[T]) -&gt; T | None:\n        context = _context_stack.get()\n        if context is not None:\n            key = cast(Token[object], token)\n            if key in context:\n                return cast(T, context[key])\n        if token.scope == Scope.SESSION:\n            session = _session_context.get()\n            if session and token in session:\n                return cast(T, session[cast(Token[object], token)])\n        if token.scope == Scope.SINGLETON and token in self._container._singletons:\n            return cast(T, self._container._singletons[cast(Token[object], token)])\n        if token.scope == Scope.TRANSIENT and token in self._container._transients:\n            return cast(T, self._container._transients[cast(Token[object], token)])\n        return None\n\n    def store_in_context(self, token: Token[T], instance: T) -&gt; None:\n        if token.scope == Scope.SINGLETON:\n            self._container._singletons[cast(Token[object], token)] = cast(\n                object, instance\n            )\n        elif token.scope == Scope.REQUEST:\n            self._container._put_in_current_request_cache(token, instance)\n        elif token.scope == Scope.SESSION:\n            session = _session_context.get()\n            if session is not None:\n                session[cast(Token[object], token)] = cast(object, instance)\n        elif token.scope == Scope.TRANSIENT:\n            try:\n                self._container._transients[cast(Token[object], token)] = cast(\n                    object, instance\n                )\n            except TypeError:\n                pass\n\n    def clear_request_context(self) -&gt; None:\n        context = _context_stack.get()\n        if context is not None and hasattr(context, \"maps\") and len(context.maps) &gt; 0:\n            context.maps[0].clear()\n\n    def clear_session_context(self) -&gt; None:\n        session = _session_context.get()\n        if session is not None:\n            session.clear()\n\n    def clear_all_contexts(self) -&gt; None:\n        self._container._singletons.clear()\n        self._container._transients.clear()\n        self.clear_request_context()\n        self.clear_session_context()\n</code></pre>"},{"location":"api/#pyinj.contextual.SessionScope","title":"<code>SessionScope</code>","text":"<p>Helper class for session-scoped dependencies.</p> Example <p>with SessionScope(container) as scope:     user = scope.resolve(UserToken)</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>class SessionScope:\n    \"\"\"\n    Helper class for session-scoped dependencies.\n\n    Example:\n        with SessionScope(container) as scope:\n            user = scope.resolve(UserToken)\n    \"\"\"\n\n    def __init__(self, container: ContextualContainer):\n        \"\"\"Initialize session scope.\"\"\"\n        self.container = container\n        self._context_manager = None\n\n    def __enter__(self) -&gt; SessionScope:\n        \"\"\"Enter session scope.\"\"\"\n        self._context_manager = self.container.session_scope()\n        self._context_manager.__enter__()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Exit session scope.\"\"\"\n        if self._context_manager:\n            self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.contextual.SessionScope.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter session scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __enter__(self) -&gt; SessionScope:\n    \"\"\"Enter session scope.\"\"\"\n    self._context_manager = self.container.session_scope()\n    self._context_manager.__enter__()\n    return self\n</code></pre>"},{"location":"api/#pyinj.contextual.SessionScope.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit session scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit session scope.\"\"\"\n    if self._context_manager:\n        self._context_manager.__exit__(exc_type, exc_val, exc_tb)\n</code></pre>"},{"location":"api/#pyinj.contextual.SessionScope.__init__","title":"<code>__init__(container)</code>","text":"<p>Initialize session scope.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def __init__(self, container: ContextualContainer):\n    \"\"\"Initialize session scope.\"\"\"\n    self.container = container\n    self._context_manager = None\n</code></pre>"},{"location":"api/#pyinj.contextual.get_current_context","title":"<code>get_current_context()</code>","text":"<p>Get current dependency context.</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def get_current_context() -&gt; ChainMap[Token[object], object] | None:\n    \"\"\"Get current dependency context.\"\"\"\n    return _context_stack.get()\n</code></pre>"},{"location":"api/#pyinj.contextual.set_context","title":"<code>set_context(context)</code>","text":"<p>Set the current dependency context.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>ChainMap[Token[object], object]</code> <p>ChainMap of dependency caches</p> required <p>Returns:</p> Type Description <code>Token[ChainMap[Token[object], object] | None]</code> <p>Token for resetting context</p> Source code in <code>src/pyinj/contextual.py</code> <pre><code>def set_context(\n    context: ChainMap[Token[object], object],\n) -&gt; ContextToken[ChainMap[Token[object], object] | None]:\n    \"\"\"\n    Set the current dependency context.\n\n    Args:\n        context: ChainMap of dependency caches\n\n    Returns:\n        Token for resetting context\n    \"\"\"\n    return _context_stack.set(context)\n</code></pre>"},{"location":"api/#tokens-and-scope","title":"Tokens and Scope","text":"<p>Enhanced Token implementation with immutability and optimizations.</p>"},{"location":"api/#pyinj.tokens.Scope","title":"<code>Scope</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Lifecycle scope for dependencies.</p> Values <p>SINGLETON: One instance for the process/container. REQUEST: One instance per request context. SESSION: One instance per longer-lived session context. TRANSIENT: A new instance for every resolution.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>class Scope(Enum):\n    \"\"\"Lifecycle scope for dependencies.\n\n    Values:\n        SINGLETON: One instance for the process/container.\n        REQUEST: One instance per request context.\n        SESSION: One instance per longer-lived session context.\n        TRANSIENT: A new instance for every resolution.\n    \"\"\"\n\n    SINGLETON = auto()  # Process-wide singleton\n    REQUEST = auto()  # Request/context scoped\n    SESSION = auto()  # Session scoped\n    TRANSIENT = auto()  # New instance every time\n</code></pre>"},{"location":"api/#pyinj.tokens.Token","title":"<code>Token</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Immutable, hashable identifier for a typed dependency.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Human-readable name for the binding.</p> required <code>type_</code> <code>type[T]</code> <p>The expected Python type of the dependency.</p> required <code>scope</code> <code>Scope</code> <p>Lifecycle scope. Defaults to TRANSIENT.</p> <code>TRANSIENT</code> <code>qualifier</code> <code>str | None</code> <p>Optional qualifier to differentiate multiple bindings of the same type.</p> <code>None</code> <code>tags</code> <code>tuple[str, ...]</code> <p>Optional tags for discovery/metadata.</p> <code>tuple()</code> Example <p>LOGGER = TokenLogger</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass Token(Generic[T]):\n    \"\"\"Immutable, hashable identifier for a typed dependency.\n\n    Args:\n        name: Human-readable name for the binding.\n        type_: The expected Python type of the dependency.\n        scope: Lifecycle scope. Defaults to TRANSIENT.\n        qualifier: Optional qualifier to differentiate multiple bindings of the same type.\n        tags: Optional tags for discovery/metadata.\n\n    Example:\n        LOGGER = Token[Logger](\"logger\", scope=Scope.SINGLETON)\n    \"\"\"\n\n    name: str\n    type_: type[T]\n    scope: Scope = Scope.TRANSIENT\n    qualifier: str | None = None\n    tags: tuple[str, ...] = field(default_factory=tuple)\n    _hash: int = field(init=False, repr=False, compare=False)\n    _metadata: dict[str, Any] = field(default_factory=dict, repr=False, compare=False)\n\n    def __post_init__(self) -&gt; None:\n        # Pre-compute hash for performance\n        hash_tuple = (\n            self.name,\n            self.type_.__module__ if hasattr(self.type_, \"__module__\") else \"\",\n            self.type_.__name__ if hasattr(self.type_, \"__name__\") else str(self.type_),\n            self.scope.value,\n            self.qualifier,\n            self.tags,\n        )\n        object.__setattr__(self, \"_hash\", hash(hash_tuple))\n\n        # Make metadata immutable\n        if self._metadata:\n            object.__setattr__(self, \"_metadata\", MappingProxyType(self._metadata))\n\n    def __hash__(self) -&gt; int:  # pragma: no cover - trivial\n        return self._hash\n\n    def __eq__(self, other: object) -&gt; bool:  # pragma: no cover - trivial\n        if not isinstance(other, Token):\n            return False\n        other_token = cast(\"Token[object]\", other)\n        if self._hash != other_token._hash:\n            return False\n        return (\n            self.name == other.name\n            and self.type_ == other_token.type_\n            and self.scope == other_token.scope\n            and self.qualifier == other_token.qualifier\n            and self.tags == other_token.tags\n        )\n\n    @property\n    def metadata(self) -&gt; MappingProxyType[str, Any]:\n        \"\"\"Read-only view of metadata.\"\"\"\n        return self._metadata  # type: ignore[return-value]\n\n    @property\n    def qualified_name(self) -&gt; str:\n        \"\"\"Fully qualified name including module, type, qualifier, and token name.\"\"\"\n        parts: list[str] = []\n        if hasattr(self.type_, \"__module__\"):\n            parts.append(self.type_.__module__)  # type: ignore[arg-type]\n        parts.append(getattr(self.type_, \"__name__\", str(self.type_)))\n        if self.qualifier:\n            parts.append(self.qualifier)\n        parts.append(self.name)\n        return \".\".join(parts)\n\n    def with_scope(self, scope: Scope) -&gt; Token[T]:\n        \"\"\"Return a copy of this token with a different scope.\"\"\"\n        return Token(\n            name=self.name,\n            type_=self.type_,\n            scope=scope,\n            qualifier=self.qualifier,\n            tags=self.tags,\n            _metadata=dict(self._metadata) if self._metadata else {},\n        )\n\n    def with_qualifier(self, qualifier: str) -&gt; Token[T]:\n        \"\"\"Return a copy of this token with a qualifier.\"\"\"\n        return Token(\n            name=self.name,\n            type_=self.type_,\n            scope=self.scope,\n            qualifier=qualifier,\n            tags=self.tags,\n            _metadata=dict(self._metadata) if self._metadata else {},\n        )\n\n    def with_tags(self, *tags: str) -&gt; Token[T]:\n        \"\"\"Return a copy of this token with tags merged in (set semantics).\"\"\"\n        return Token(\n            name=self.name,\n            type_=self.type_,\n            scope=self.scope,\n            qualifier=self.qualifier,\n            tags=tuple(set(self.tags) | set(tags)),\n            _metadata=dict(self._metadata) if self._metadata else {},\n        )\n\n    def __repr__(self) -&gt; str:  # pragma: no cover - representation\n        type_name = getattr(self.type_, \"__name__\", str(self.type_))\n        parts = [f\"Token('{self.name}', {type_name}\"]\n        if self.scope != Scope.TRANSIENT:\n            parts.append(f\", scope={self.scope.name}\")\n        if self.qualifier:\n            parts.append(f\", qualifier='{self.qualifier}'\")\n        if self.tags:\n            parts.append(f\", tags={self.tags}\")\n        return \"\".join(parts) + \")\"\n\n    def validate(self, instance: object) -&gt; bool:\n        \"\"\"Validate instance type against the token's expected type.\n\n        Returns False only when ``isinstance(instance, type_)`` is definitively False.\n        If runtime type information is insufficient, returns True.\n        \"\"\"\n        try:\n            return isinstance(instance, self.type_)\n        except Exception:\n            return True\n</code></pre>"},{"location":"api/#pyinj.tokens.Token.metadata","title":"<code>metadata</code>  <code>property</code>","text":"<p>Read-only view of metadata.</p>"},{"location":"api/#pyinj.tokens.Token.qualified_name","title":"<code>qualified_name</code>  <code>property</code>","text":"<p>Fully qualified name including module, type, qualifier, and token name.</p>"},{"location":"api/#pyinj.tokens.Token.validate","title":"<code>validate(instance)</code>","text":"<p>Validate instance type against the token's expected type.</p> <p>Returns False only when <code>isinstance(instance, type_)</code> is definitively False. If runtime type information is insufficient, returns True.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def validate(self, instance: object) -&gt; bool:\n    \"\"\"Validate instance type against the token's expected type.\n\n    Returns False only when ``isinstance(instance, type_)`` is definitively False.\n    If runtime type information is insufficient, returns True.\n    \"\"\"\n    try:\n        return isinstance(instance, self.type_)\n    except Exception:\n        return True\n</code></pre>"},{"location":"api/#pyinj.tokens.Token.with_qualifier","title":"<code>with_qualifier(qualifier)</code>","text":"<p>Return a copy of this token with a qualifier.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def with_qualifier(self, qualifier: str) -&gt; Token[T]:\n    \"\"\"Return a copy of this token with a qualifier.\"\"\"\n    return Token(\n        name=self.name,\n        type_=self.type_,\n        scope=self.scope,\n        qualifier=qualifier,\n        tags=self.tags,\n        _metadata=dict(self._metadata) if self._metadata else {},\n    )\n</code></pre>"},{"location":"api/#pyinj.tokens.Token.with_scope","title":"<code>with_scope(scope)</code>","text":"<p>Return a copy of this token with a different scope.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def with_scope(self, scope: Scope) -&gt; Token[T]:\n    \"\"\"Return a copy of this token with a different scope.\"\"\"\n    return Token(\n        name=self.name,\n        type_=self.type_,\n        scope=scope,\n        qualifier=self.qualifier,\n        tags=self.tags,\n        _metadata=dict(self._metadata) if self._metadata else {},\n    )\n</code></pre>"},{"location":"api/#pyinj.tokens.Token.with_tags","title":"<code>with_tags(*tags)</code>","text":"<p>Return a copy of this token with tags merged in (set semantics).</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def with_tags(self, *tags: str) -&gt; Token[T]:\n    \"\"\"Return a copy of this token with tags merged in (set semantics).\"\"\"\n    return Token(\n        name=self.name,\n        type_=self.type_,\n        scope=self.scope,\n        qualifier=self.qualifier,\n        tags=tuple(set(self.tags) | set(tags)),\n        _metadata=dict(self._metadata) if self._metadata else {},\n    )\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory","title":"<code>TokenFactory</code>","text":"<p>Factory for creating and caching commonly used tokens.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>class TokenFactory:\n    \"\"\"Factory for creating and caching commonly used tokens.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._cache: dict[tuple[str, type[Any], Scope, str | None], Token[Any]] = {}\n\n    def create(\n        self,\n        name: str,\n        type_: type[T],\n        scope: Scope = Scope.TRANSIENT,\n        qualifier: str | None = None,\n        tags: tuple[str, ...] = (),\n    ) -&gt; Token[T]:\n        \"\"\"Create a token, with a small internal cache for common shapes.\"\"\"\n        cache_key = (name, type_, scope, qualifier)\n        if not tags and cache_key in self._cache:\n            return cast(Token[T], self._cache[cache_key])\n        token: Token[T] = Token(\n            name=name, type_=type_, scope=scope, qualifier=qualifier, tags=tags\n        )\n        if not tags:\n            self._cache[cache_key] = cast(Token[Any], token)\n        return token\n\n    def singleton(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a singleton-scoped token.\"\"\"\n        return self.create(name, type_, scope=Scope.SINGLETON)\n\n    def request(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a request-scoped token.\"\"\"\n        return self.create(name, type_, scope=Scope.REQUEST)\n\n    def session(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a session-scoped token.\"\"\"\n        return self.create(name, type_, scope=Scope.SESSION)\n\n    def transient(self, name: str, type_: type[T]) -&gt; Token[T]:\n        \"\"\"Create a transient-scoped token (default).\"\"\"\n        return self.create(name, type_, scope=Scope.TRANSIENT)\n\n    def qualified(\n        self, qualifier: str, type_: type[T], scope: Scope = Scope.TRANSIENT\n    ) -&gt; Token[T]:\n        \"\"\"Create a qualified token for the given type and scope.\"\"\"\n        name = getattr(type_, \"__name__\", str(type_))\n        return self.create(name, type_, scope=scope, qualifier=qualifier)\n\n    def clear_cache(self) -&gt; None:\n        \"\"\"Clear the internal token cache (harmless).\"\"\"\n        self._cache.clear()\n\n    @property\n    def cache_size(self) -&gt; int:\n        \"\"\"Number of cached token shapes currently held.\"\"\"\n        return len(self._cache)\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory.cache_size","title":"<code>cache_size</code>  <code>property</code>","text":"<p>Number of cached token shapes currently held.</p>"},{"location":"api/#pyinj.tokens.TokenFactory.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear the internal token cache (harmless).</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear the internal token cache (harmless).\"\"\"\n    self._cache.clear()\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory.create","title":"<code>create(name, type_, scope=Scope.TRANSIENT, qualifier=None, tags=())</code>","text":"<p>Create a token, with a small internal cache for common shapes.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def create(\n    self,\n    name: str,\n    type_: type[T],\n    scope: Scope = Scope.TRANSIENT,\n    qualifier: str | None = None,\n    tags: tuple[str, ...] = (),\n) -&gt; Token[T]:\n    \"\"\"Create a token, with a small internal cache for common shapes.\"\"\"\n    cache_key = (name, type_, scope, qualifier)\n    if not tags and cache_key in self._cache:\n        return cast(Token[T], self._cache[cache_key])\n    token: Token[T] = Token(\n        name=name, type_=type_, scope=scope, qualifier=qualifier, tags=tags\n    )\n    if not tags:\n        self._cache[cache_key] = cast(Token[Any], token)\n    return token\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory.qualified","title":"<code>qualified(qualifier, type_, scope=Scope.TRANSIENT)</code>","text":"<p>Create a qualified token for the given type and scope.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def qualified(\n    self, qualifier: str, type_: type[T], scope: Scope = Scope.TRANSIENT\n) -&gt; Token[T]:\n    \"\"\"Create a qualified token for the given type and scope.\"\"\"\n    name = getattr(type_, \"__name__\", str(type_))\n    return self.create(name, type_, scope=scope, qualifier=qualifier)\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory.request","title":"<code>request(name, type_)</code>","text":"<p>Create a request-scoped token.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def request(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a request-scoped token.\"\"\"\n    return self.create(name, type_, scope=Scope.REQUEST)\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory.session","title":"<code>session(name, type_)</code>","text":"<p>Create a session-scoped token.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def session(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a session-scoped token.\"\"\"\n    return self.create(name, type_, scope=Scope.SESSION)\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory.singleton","title":"<code>singleton(name, type_)</code>","text":"<p>Create a singleton-scoped token.</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def singleton(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a singleton-scoped token.\"\"\"\n    return self.create(name, type_, scope=Scope.SINGLETON)\n</code></pre>"},{"location":"api/#pyinj.tokens.TokenFactory.transient","title":"<code>transient(name, type_)</code>","text":"<p>Create a transient-scoped token (default).</p> Source code in <code>src/pyinj/tokens.py</code> <pre><code>def transient(self, name: str, type_: type[T]) -&gt; Token[T]:\n    \"\"\"Create a transient-scoped token (default).\"\"\"\n    return self.create(name, type_, scope=Scope.TRANSIENT)\n</code></pre>"},{"location":"api/#injection-utilities","title":"Injection Utilities","text":"<p>Lightweight decorators and markers for function parameter injection.</p> <p>These tools are inspired by FastAPI but remain framework-agnostic and work with synchronous and asynchronous callables.</p>"},{"location":"api/#pyinj.injection.Given","title":"<code>Given</code>","text":"<p>Scala-style given marker for implicit dependencies.</p> Usage <p>def handler(db: Given[Database]):     # db is resolved from given instances     ...</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>class Given:\n    \"\"\"\n    Scala-style given marker for implicit dependencies.\n\n    Usage:\n        def handler(db: Given[Database]):\n            # db is resolved from given instances\n            ...\n    \"\"\"\n\n    def __class_getitem__(cls, item: type[T]) -&gt; builtins.type[\"Inject[T]\"]:\n        \"\"\"Support Given[Type] syntax by delegating to Inject.\"\"\"\n        return Inject[item]\n</code></pre>"},{"location":"api/#pyinj.injection.Given.__class_getitem__","title":"<code>__class_getitem__(item)</code>","text":"<p>Support Given[Type] syntax by delegating to Inject.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __class_getitem__(cls, item: type[T]) -&gt; builtins.type[\"Inject[T]\"]:\n    \"\"\"Support Given[Type] syntax by delegating to Inject.\"\"\"\n    return Inject[item]\n</code></pre>"},{"location":"api/#pyinj.injection.Inject","title":"<code>Inject</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Marker for injected dependencies (similar to FastAPI's <code>Depends</code>).</p> Usage <p>def handler(db: Inject[Database]):     # db is auto-injected     ...</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>class Inject(Generic[T]):\n    \"\"\"\n    Marker for injected dependencies (similar to FastAPI's ``Depends``).\n\n    Usage:\n        def handler(db: Inject[Database]):\n            # db is auto-injected\n            ...\n\n        # Or with default provider\n        def handler(db: Inject[Database] = Inject(create_db)):\n            ...\n    \"\"\"\n\n    def __init__(self, provider: Callable[..., T] | None = None) -&gt; None:\n        \"\"\"\n        Initialize an injection marker optionally carrying a provider.\n\n        Args:\n            provider: Optional provider function\n        \"\"\"\n        self.provider = provider\n        self._type: type[T] | None = None\n\n    _typed_cache: ClassVar[dict[type[object], builtins.type]] = {}\n\n    def __class_getitem__(cls, item: builtins.type[T]) -&gt; builtins.type[\"Inject[T]\"]:\n        \"\"\"Support Inject[Type] syntax without recursion and with caching.\n\n        Returns a cached subclass carrying the injection type, so that\n        repeated references to Inject[T] are identical across calls.\n        \"\"\"\n        cached = cls._typed_cache.get(item)\n        if cached is not None:\n            return cached\n\n        name = f\"Inject_{getattr(item, '__name__', 'T')}\"\n        TypedInject = type(name, (cls,), {\"_inject_type\": item})\n        cls._typed_cache[item] = TypedInject\n        return tcast(builtins.type, TypedInject)\n\n    @property\n    def type(self) -&gt; builtins.type[T] | None:\n        \"\"\"Get the injected type if available.\"\"\"\n        t = getattr(self.__class__, \"_inject_type\", None)\n        if isinstance(t, type):\n            return t\n        return self._type\n\n    def set_type(self, type_: builtins.type[T]) -&gt; None:\n        \"\"\"Set the injected type explicitly (used by analyzers).\"\"\"\n        self._type = type_\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Readable representation.\"\"\"\n        if self.type:\n            return f\"Inject[{self.type.__name__}]\"\n        return \"Inject()\"\n</code></pre>"},{"location":"api/#pyinj.injection.Inject--or-with-default-provider","title":"Or with default provider","text":"<p>def handler(db: Inject[Database] = Inject(create_db)):     ...</p>"},{"location":"api/#pyinj.injection.Inject.type","title":"<code>type</code>  <code>property</code>","text":"<p>Get the injected type if available.</p>"},{"location":"api/#pyinj.injection.Inject.__class_getitem__","title":"<code>__class_getitem__(item)</code>","text":"<p>Support Inject[Type] syntax without recursion and with caching.</p> <p>Returns a cached subclass carrying the injection type, so that repeated references to Inject[T] are identical across calls.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __class_getitem__(cls, item: builtins.type[T]) -&gt; builtins.type[\"Inject[T]\"]:\n    \"\"\"Support Inject[Type] syntax without recursion and with caching.\n\n    Returns a cached subclass carrying the injection type, so that\n    repeated references to Inject[T] are identical across calls.\n    \"\"\"\n    cached = cls._typed_cache.get(item)\n    if cached is not None:\n        return cached\n\n    name = f\"Inject_{getattr(item, '__name__', 'T')}\"\n    TypedInject = type(name, (cls,), {\"_inject_type\": item})\n    cls._typed_cache[item] = TypedInject\n    return tcast(builtins.type, TypedInject)\n</code></pre>"},{"location":"api/#pyinj.injection.Inject.__init__","title":"<code>__init__(provider=None)</code>","text":"<p>Initialize an injection marker optionally carrying a provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>Callable[..., T] | None</code> <p>Optional provider function</p> <code>None</code> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __init__(self, provider: Callable[..., T] | None = None) -&gt; None:\n    \"\"\"\n    Initialize an injection marker optionally carrying a provider.\n\n    Args:\n        provider: Optional provider function\n    \"\"\"\n    self.provider = provider\n    self._type: type[T] | None = None\n</code></pre>"},{"location":"api/#pyinj.injection.Inject.__repr__","title":"<code>__repr__()</code>","text":"<p>Readable representation.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Readable representation.\"\"\"\n    if self.type:\n        return f\"Inject[{self.type.__name__}]\"\n    return \"Inject()\"\n</code></pre>"},{"location":"api/#pyinj.injection.Inject.set_type","title":"<code>set_type(type_)</code>","text":"<p>Set the injected type explicitly (used by analyzers).</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def set_type(self, type_: builtins.type[T]) -&gt; None:\n    \"\"\"Set the injected type explicitly (used by analyzers).\"\"\"\n    self._type = type_\n</code></pre>"},{"location":"api/#pyinj.injection.InjectionAnalyzer","title":"<code>InjectionAnalyzer</code>","text":"<p>Small analyzer facade to build dependency plans.</p> <p>This class enables decomposition and easier testing while remaining backward-compatible with analyze_dependencies.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>class InjectionAnalyzer:\n    \"\"\"Small analyzer facade to build dependency plans.\n\n    This class enables decomposition and easier testing while\n    remaining backward-compatible with analyze_dependencies.\n    \"\"\"\n\n    @staticmethod\n    def build_plan(func: Callable[..., Any]) -&gt; dict[str, DependencyRequest]:\n        return analyze_dependencies(func)\n</code></pre>"},{"location":"api/#pyinj.injection.Depends","title":"<code>Depends(provider)</code>","text":"<p>FastAPI-compatible <code>Depends</code> marker.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>Callable[..., T]</code> <p>Provider function for the dependency</p> required <p>Returns:</p> Name Type Description <code>An</code> <code>T</code> <p>class:<code>Inject</code> marker usable as a default parameter value.</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def Depends[T](provider: Callable[..., T]) -&gt; T:  # noqa: N802\n    \"\"\"\n    FastAPI-compatible ``Depends`` marker.\n\n    Args:\n        provider: Provider function for the dependency\n\n    Returns:\n        An :class:`Inject` marker usable as a default parameter value.\n    \"\"\"\n    return Inject(provider)  # type: ignore\n</code></pre>"},{"location":"api/#pyinj.injection.analyze_dependencies","title":"<code>analyze_dependencies(func)</code>  <code>cached</code>","text":"<p>Analyze function signature for injected dependencies.</p> <p>This is cached for performance as signature analysis is expensive.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>Function to analyze</p> required <p>Returns:</p> Type Description <code>dict[str, DependencyRequest]</code> <p>Dictionary mapping parameter names to their injection specs</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>@lru_cache(maxsize=256)\ndef analyze_dependencies(func: Callable[..., Any]) -&gt; dict[str, DependencyRequest]:\n    \"\"\"\n    Analyze function signature for injected dependencies.\n\n    This is cached for performance as signature analysis is expensive.\n\n    Args:\n        func: Function to analyze\n\n    Returns:\n        Dictionary mapping parameter names to their injection specs\n    \"\"\"\n    sig = signature(func)\n    # Resolve annotations (handles from __future__ import annotations)\n    try:\n        resolved = get_type_hints(func, include_extras=True)\n    except Exception:\n        resolved = {}\n    deps: dict[str, DependencyRequest] = {}\n\n    for name, param in sig.parameters.items():\n        # Skip *args and **kwargs\n        if param.kind in (Parameter.VAR_POSITIONAL, Parameter.VAR_KEYWORD):\n            continue\n\n        annotation = resolved.get(name, param.annotation)\n\n        # Skip if no annotation\n        if annotation is Parameter.empty:\n            continue\n\n        # Check various injection patterns\n        origin = get_origin(annotation)\n        args = get_args(annotation)\n\n        # 1) Annotated[T, Inject(...) | Token(...)]\n        if origin is Annotated and args:\n            dep_type = args[0]\n            metadata = args[1:]\n            for meta in metadata:\n                if isinstance(meta, Inject):\n                    marker = cast(Inject[Any], meta)\n                    if not marker.type and isinstance(dep_type, type):\n                        marker.set_type(dep_type)\n                    deps[name] = marker\n                    break\n                if isinstance(meta, Token):\n                    deps[name] = meta\n                    break\n\n        elif _is_inject_type(annotation):\n            # It's Inject[T] or Given[T]\n            deps[name] = _extract_inject_spec(annotation, param.default)\n\n        elif isinstance(param.default, Inject):\n            # Default value is Inject()\n            marker = cast(Inject[Any], param.default)\n            deps[name] = marker\n            if annotation != Parameter.empty and isinstance(annotation, type):\n                # Store the type from annotation\n                marker.set_type(annotation)\n\n        elif isinstance(annotation, Token):\n            # Direct Token annotation\n            deps[name] = annotation\n\n        elif _is_plain_injectable_type(annotation):\n            # Fallback: plain type annotation (non-builtin class/protocol)\n            deps[name] = annotation\n\n        elif isinstance(param.annotation, str) and \"Inject[\" in param.annotation:\n            # Last-resort: parse string annotations from future annotations\n            inner = param.annotation.strip()\n            try:\n                inner_type_str = inner[inner.find(\"[\") + 1 : inner.rfind(\"]\")]\n                inner_type = eval(inner_type_str, func.__globals__, {})  # noqa: S307 (trusted test context)\n                inner_type = tcast(type[object], inner_type)\n                marker = Inject[object]()\n                marker.set_type(inner_type)\n                deps[name] = marker\n            except Exception:\n                # Ignore if we cannot resolve\n                pass\n\n    return deps\n</code></pre>"},{"location":"api/#pyinj.injection.get_default_container","title":"<code>get_default_container()</code>","text":"<p>Indirection for default container lookup (patchable in tests).</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def get_default_container() -&gt; Resolvable[Any]:\n    \"\"\"Indirection for default container lookup (patchable in tests).\"\"\"\n    from .container import get_default_container as _gdc\n\n    return tcast(Resolvable[Any], _gdc())\n</code></pre>"},{"location":"api/#pyinj.injection.inject","title":"<code>inject(func=None, *, container=None, cache=True)</code>","text":"<pre><code>inject(func: Callable[P, R], *, container: Resolvable[Any] | None = ..., cache: bool = ...) -&gt; Callable[P, R]\n</code></pre><pre><code>inject(func: None = ..., *, container: Resolvable[Any] | None = ..., cache: bool = ...) -&gt; Callable[[Callable[P, R]], Callable[P, R]]\n</code></pre> <p>Decorator that injects dependencies into function parameters.</p> <p>This is the main entry point for dependency injection, inspired by FastAPI's dependency injection system.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R] | None</code> <p>Function to decorate (or None if using with parameters)</p> <code>None</code> <code>container</code> <code>Resolvable[Any] | None</code> <p>Container to resolve dependencies from</p> <code>None</code> <code>cache</code> <code>bool</code> <p>Whether to cache dependency analysis</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable[P, R] | Callable[[Callable[P, R]], Callable[P, R]]</code> <p>Decorated function with automatic dependency injection</p> <p>Examples:</p> <p>@inject def service(db: Inject[Database]):     return db.query()</p> <p>@inject(container=my_container) async def handler(cache: Inject[Cache]):     return await cache.get(\"key\")</p> <p>@inject async def endpoint(     user_id: int,     db: Inject[Database],     cache: Given[Cache],     settings: Settings = Inject() ):     # Mixed regular and injected parameters     pass</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def inject(\n    func: Callable[P, R] | None = None,\n    *,\n    container: Resolvable[Any] | None = None,\n    cache: bool = True,\n) -&gt; Callable[P, R] | Callable[[Callable[P, R]], Callable[P, R]]:\n    \"\"\"\n    Decorator that injects dependencies into function parameters.\n\n    This is the main entry point for dependency injection, inspired by\n    FastAPI's dependency injection system.\n\n    Args:\n        func: Function to decorate (or None if using with parameters)\n        container: Container to resolve dependencies from\n        cache: Whether to cache dependency analysis\n\n    Returns:\n        Decorated function with automatic dependency injection\n\n    Examples:\n        @inject\n        def service(db: Inject[Database]):\n            return db.query()\n\n        @inject(container=my_container)\n        async def handler(cache: Inject[Cache]):\n            return await cache.get(\"key\")\n\n        @inject\n        async def endpoint(\n            user_id: int,\n            db: Inject[Database],\n            cache: Given[Cache],\n            settings: Settings = Inject()\n        ):\n            # Mixed regular and injected parameters\n            pass\n    \"\"\"\n\n    def decorator(fn: Callable[P, R]) -&gt; Callable[P, R]:\n        # Analyze dependencies (cached if cache=True)\n        deps = InjectionAnalyzer.build_plan(fn) if cache else None\n\n        if iscoroutinefunction(fn):\n\n            @wraps(fn)\n            async def async_wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n                # Get dependencies if not cached\n                nonlocal deps\n                if deps is None:\n                    deps = InjectionAnalyzer.build_plan(fn)\n\n                if not deps:\n                    # No dependencies, call original\n                    return await fn(*args, **kwargs)\n\n                # Get container\n                nonlocal container\n                if container is None:\n                    # Try to get default container via indirection (patchable)\n                    from .injection import get_default_container as _gdc\n                    container = tcast(Resolvable[Any], _gdc())\n\n                # Extract overrides from kwargs\n                overrides: dict[str, Any] = {}\n                for name in deps:\n                    if name in kwargs:  # type: ignore[operator]\n                        overrides[name] = cast(Any, kwargs.pop(name))  # type: ignore[call-arg]\n\n                # Resolve dependencies\n                resolved = await resolve_dependencies_async(deps, container, overrides)\n\n                # Rebind arguments: skip injected params from positional binding\n                sig = signature(fn)\n                new_kwargs: dict[str, Any] = {}\n                arg_i = 0\n                for pname, param in sig.parameters.items():\n                    if pname in resolved:\n                        # will be injected\n                        continue\n                    if param.kind in (Parameter.POSITIONAL_ONLY, Parameter.POSITIONAL_OR_KEYWORD) and arg_i &lt; len(args):\n                        new_kwargs[pname] = args[arg_i]\n                        arg_i += 1\n                # bring through any explicit kwargs provided\n                new_kwargs.update(kwargs)\n                # inject resolved deps\n                new_kwargs.update(resolved)\n\n                return await fn(**new_kwargs)\n\n            return tcast(Callable[P, R], async_wrapper)\n\n        else:\n\n            @wraps(fn)\n            def sync_wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n                # Get dependencies if not cached\n                nonlocal deps\n                if deps is None:\n                    deps = InjectionAnalyzer.build_plan(fn)\n\n                if not deps:\n                    # No dependencies, call original\n                    return fn(*args, **kwargs)\n\n                # Get container\n                nonlocal container\n                if container is None:\n                    from .injection import get_default_container as _gdc\n                    container = tcast(Resolvable[Any], _gdc())\n\n                # Extract overrides from kwargs\n                overrides: dict[str, Any] = {}\n                for name in deps:\n                    if name in kwargs:  # type: ignore[operator]\n                        overrides[name] = cast(Any, kwargs.pop(name))  # type: ignore[call-arg]\n\n                # Resolve dependencies\n                resolved = resolve_dependencies(deps, container, overrides)\n\n                # Rebind arguments: skip injected params from positional binding\n                sig = signature(fn)\n                new_kwargs: dict[str, Any] = {}\n                arg_i = 0\n                for pname, param in sig.parameters.items():\n                    if pname in resolved:\n                        continue\n                    if param.kind in (Parameter.POSITIONAL_ONLY, Parameter.POSITIONAL_OR_KEYWORD) and arg_i &lt; len(args):\n                        new_kwargs[pname] = args[arg_i]\n                        arg_i += 1\n                new_kwargs.update(kwargs)\n                new_kwargs.update(resolved)\n\n                return fn(**new_kwargs)\n\n            return tcast(Callable[P, R], sync_wrapper)\n\n    # Handle both @inject and @inject(...) syntax\n    if func is None:\n        # Called with parameters: @inject(container=...)\n        return decorator\n    else:\n        # Called without parameters: @inject\n        return decorator(func)\n</code></pre>"},{"location":"api/#pyinj.injection.resolve_dependencies","title":"<code>resolve_dependencies(deps, container, overrides=None)</code>","text":"<p>Resolve dependencies synchronously.</p> <p>Parameters:</p> Name Type Description Default <code>deps</code> <code>dict[str, DependencyRequest]</code> <p>Dependencies to resolve</p> required <code>container</code> <code>Resolvable[object]</code> <p>Container to resolve from</p> required <code>overrides</code> <code>dict[str, object] | None</code> <p>Optional overrides for specific dependencies</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, object]</code> <p>Dictionary of resolved dependencies</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>def resolve_dependencies(\n    deps: dict[str, DependencyRequest],\n    container: Resolvable[object],\n    overrides: dict[str, object] | None = None,\n) -&gt; dict[str, object]:\n    \"\"\"\n    Resolve dependencies synchronously.\n\n    Args:\n        deps: Dependencies to resolve\n        container: Container to resolve from\n        overrides: Optional overrides for specific dependencies\n\n    Returns:\n        Dictionary of resolved dependencies\n    \"\"\"\n    resolved: dict[str, object] = {}\n    ov = overrides or {}\n    for name, req in deps.items():\n        if name in ov:\n            resolved[name] = ov[name]\n            continue\n        spec = _to_spec(req)\n        resolved[name] = _resolve_one(spec, container)\n    return resolved\n</code></pre>"},{"location":"api/#pyinj.injection.resolve_dependencies_async","title":"<code>resolve_dependencies_async(deps, container, overrides=None)</code>  <code>async</code>","text":"<p>Resolve dependencies asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>deps</code> <code>dict[str, DependencyRequest]</code> <p>Dependencies to resolve</p> required <code>container</code> <code>Resolvable[object]</code> <p>Container to resolve from</p> required <code>overrides</code> <code>dict[str, object] | None</code> <p>Optional overrides for specific dependencies</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, object]</code> <p>Dictionary of resolved dependencies</p> Source code in <code>src/pyinj/injection.py</code> <pre><code>async def resolve_dependencies_async(\n    deps: dict[str, DependencyRequest],\n    container: Resolvable[object],\n    overrides: dict[str, object] | None = None,\n) -&gt; dict[str, object]:\n    \"\"\"\n    Resolve dependencies asynchronously.\n\n    Args:\n        deps: Dependencies to resolve\n        container: Container to resolve from\n        overrides: Optional overrides for specific dependencies\n\n    Returns:\n        Dictionary of resolved dependencies\n    \"\"\"\n    resolved: dict[str, object] = {}\n    overrides = overrides or {}\n    tasks: dict[str, asyncio.Task[object]] = {}\n\n    for name, req in deps.items():\n        if name in overrides:\n            resolved[name] = overrides[name]\n            continue\n        spec = _to_spec(req)\n        tasks[name] = asyncio.create_task(_aresolve_one(spec, container))\n\n    # Resolve all tasks in parallel\n    if tasks:\n        results: list[Any] = await asyncio.gather(*tasks.values())\n        for name, result in zip(tasks.keys(), results, strict=False):\n            resolved[name] = result\n\n    return resolved\n</code></pre>"},{"location":"concurrency/","title":"Concurrency","text":"<p>PyInj is designed for both threaded and async-concurrent programs.</p> <ul> <li>Thread-safe singletons: first creation is protected by locks.</li> <li>Async-safe singletons: first creation is protected by <code>asyncio.Lock</code>.</li> <li>Request/session scoping: implemented with <code>contextvars</code>, so context flows across awaits.</li> <li>Overrides: per-request overrides backed by <code>ContextVar</code> for isolation.</li> </ul>"},{"location":"concurrency/#threaded-programs","title":"Threaded programs","text":"<pre><code>from pyinj import Container, Token, Scope\nimport threading\n\ncontainer = Container()\nCACHE = Token[dict[str, str]](\"cache\", scope=Scope.SINGLETON)\ncontainer.register(CACHE, lambda: {\"a\": \"1\"})\n\n# Safe: every thread gets the same singleton\nvalues: list[dict[str, str]] = []\n\ndef worker() -&gt; None:\n    values.append(container.get(CACHE))\n\nthreads = [threading.Thread(target=worker) for _ in range(10)]\n[t.start() for t in threads]\n[t.join() for t in threads]\nassert all(v is values[0] for v in values)\n</code></pre>"},{"location":"concurrency/#async-programs","title":"Async programs","text":"<pre><code>import asyncio\nfrom typing import Awaitable\nfrom pyinj import Container, Token, Scope\n\ncontainer = Container()\n\nclass Client:\n    async def aclose(self) -&gt; None: ...\n\nCLIENT = Token[Client](\"client\", scope=Scope.SINGLETON)\n\nasync def make_client() -&gt; Client:\n    await asyncio.sleep(0)  # simulate I/O\n    return Client()\n\ncontainer.register(CLIENT, make_client)\n\nasync def main() -&gt; None:\n    # Safe: async singleton is created once under an asyncio.Lock\n    c1, c2 = await asyncio.gather(container.aget(CLIENT), container.aget(CLIENT))\n    assert c1 is c2\n\nasyncio.run(main())\n</code></pre>"},{"location":"concurrency/#request-session-scope-web-style-lifetimes","title":"Request / session scope (web-style lifetimes)","text":"<pre><code>from typing import Any\nfrom pyinj import Container, Token, Scope\n\ncontainer = Container()\nSESSION = Token[dict[str, Any]](\"session\", scope=Scope.SESSION)\nREQUEST = Token[dict[str, Any]](\"request\", scope=Scope.REQUEST)\n\ncontainer.register(SESSION, lambda: {\"s\": 1})\ncontainer.register(REQUEST, lambda: {\"r\": 1})\n\n# Request scope isolates per-request caches while sharing singletons\nwith container.request_scope():\n    assert container.get(REQUEST)[\"r\"] == 1\n    with container.request_scope():\n        assert container.get(REQUEST)[\"r\"] == 1  # new dict in inner scope\n\nNote: nested `request_scope` blocks are fully isolated; the inner scope does not inherit the parent request cache. This ensures deterministic lifetimes for per-request values.\n</code></pre>"},{"location":"concurrency/#overrides-per-request","title":"Overrides per request","text":"<pre><code>from typing import Any\n\nLOGGER = Token[object](\"logger\")\ncontainer.register(LOGGER, lambda: object())\n\nwith container.use_overrides({LOGGER: \"fake\"}):\n    assert container.get(LOGGER) == \"fake\"\n# Outside override, original provider is used\nassert container.get(LOGGER) != \"fake\"\n</code></pre>"},{"location":"concurrency/#cleanup","title":"Cleanup","text":"<ul> <li>Request/session scopes clean up resources stored in the scope when the scope exits.</li> <li>Container-level <code>dispose()</code> / <code>aclose()</code> cleans up resources registered via <code>register_context(...)</code> (both sync and async).</li> </ul> <pre><code># Register a context-managed singleton (async)\nfrom contextlib import asynccontextmanager\n\n@asynccontextmanager\nasync def client_cm():\n    c = make_async_client()\n    try:\n        yield c\n    finally:\n        await c.aclose()\n\nCLIENT = Token[AsyncClient](\"client\", scope=Scope.SINGLETON)\ncontainer.register_context(CLIENT, lambda: client_cm(), is_async=True)\n\n# Later, ensure cleanup runs\nawait container.aclose()  # or await container.dispose()\n\nMixed cleanup in async request scopes:\n- In `async_request_scope`, async cleanups run first, then sync cleanups. This ensures awaiting all async finalizers before executing any synchronous ones, avoiding event loop blocking.\n\nTyped registration helpers:\n- `register_context_sync(token, cm_provider, scope=...)` for sync context managers.\n- `register_context_async(token, cm_provider, scope=...)` for async context managers.\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>We follow trunk-based development and Conventional Commits. See the full guide in CONTRIBUTING.md.</p> <p>Key points: - Short-lived branches, PRs into <code>main</code>, squash merge. - CI must pass (ruff, basedpyright, pytest). - Releases automated by Release Please and published to PyPI via GitHub Releases.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>uv add pyinj\n# or\npip install pyinj\n</code></pre>"},{"location":"getting-started/#basic-concepts","title":"Basic Concepts","text":"<ul> <li>Token: a typed identifier for a dependency.</li> <li>Provider: a function or class that creates the dependency.</li> <li>Scope: lifecycle (SINGLETON, TRANSIENT, REQUEST).</li> </ul>"},{"location":"getting-started/#example","title":"Example","text":"<pre><code>from pyinj import Container, Token, Scope\n\ncontainer = Container()\nLOGGER = Token[Logger](\"logger\")\n\ncontainer.register(LOGGER, ConsoleLogger, Scope.SINGLETON)\n\nlogger = container.get(LOGGER)\nlogger.info(\"Hello\")\n</code></pre>"},{"location":"getting-started/#cleanup-and-circuit-breaker","title":"Cleanup and Circuit Breaker","text":"<p>Call <code>aclose()</code>/<code>dispose()</code> to close resources (async-friendly):</p> <pre><code>await container.aclose()  # or await container.dispose()\n</code></pre> <p>If you attempt to close async-only resources from a synchronous context (<code>with container:</code>), PyInj raises <code>AsyncCleanupRequiredError</code> to alert you to use an async scope or <code>await container.aclose()</code>.</p>"},{"location":"internals/","title":"Internals","text":"<p>This page outlines how PyInj is structured under the hood.</p>"},{"location":"internals/#core-concepts","title":"Core concepts","text":"<ul> <li>Token[T]: immutable, hashable identifier for a typed dependency. Holds <code>name</code>, <code>type_</code>, <code>scope</code>, optional <code>qualifier</code>, and <code>tags</code>.</li> <li>ProviderLike[T]: either a sync provider <code>() -&gt; T</code> or async provider <code>() -&gt; Awaitable[T]</code>.</li> <li>Scopes:</li> <li>SINGLETON: shared across the process/container</li> <li>REQUEST: bound to the current request context</li> <li>SESSION: longer-lived context separate from request</li> <li>TRANSIENT: created each resolution</li> </ul>"},{"location":"internals/#container","title":"Container","text":"<ul> <li>Registries</li> <li><code>_providers: dict[Token[object], ProviderLike[object]]</code></li> <li><code>_singletons: dict[Token[object], object]</code></li> <li><code>_token_scopes: dict[Token[object], Scope]</code></li> <li><code>_async_locks: dict[Token[object], asyncio.Lock]</code></li> <li>Concurrency</li> <li>Thread-safe singleton creation (per-token <code>threading.Lock</code>)</li> <li>Async-safe singleton creation (per-token <code>asyncio.Lock</code>)</li> <li>Contexts</li> <li>Uses <code>contextvars</code> to implement REQUEST and SESSION scoping</li> <li><code>use_overrides()</code> merges override maps per context</li> </ul>"},{"location":"internals/#resolution","title":"Resolution","text":"<ul> <li><code>get(Token[T] | type[T]) -&gt; T</code></li> <li>If a <code>type[T]</code> is passed, the container finds or creates a matching token.</li> <li>Checks overrides, request/session caches, then provider</li> <li>Validates type using <code>Token.validate()</code> before storing</li> <li>Disallows calling async providers in sync <code>get()</code></li> <li><code>aget(Token[T] | type[T]) -&gt; T</code></li> <li>Async variant; awaits async providers and uses <code>asyncio.Lock</code> for singletons</li> </ul>"},{"location":"internals/#injection","title":"Injection","text":"<ul> <li>Analyzer inspects function signatures and annotations to build a dependency plan.</li> <li>Supported patterns (preferred first):</li> <li><code>Annotated[T, Inject()]</code></li> <li>Default marker: <code>param: T = Inject()</code></li> <li>Direct <code>Token[T]</code> annotations</li> <li>Plain type-only injection for non-builtin classes/protocols</li> <li>Decorator <code>@inject</code> resolves dependencies per call (sync/async) and passes them as kwargs.</li> </ul>"},{"location":"internals/#typing-model","title":"Typing model","text":"<ul> <li><code>get/aget</code> return types depend on runtime providers in a DI system; the container remains generic.</li> <li>At call sites, annotate variables that receive container results when you need static precision.</li> <li>For <code>@inject</code>, prefer <code>Annotated[T, Inject()]</code> so tools know T is the runtime type while Inject carries metadata.</li> </ul>"},{"location":"llm/","title":"LLM Guide: Using PyInj for Reliable DI","text":"<p>Purpose: concise guidance for integrating PyInj into LLM-driven projects and tools.</p> <ul> <li>Audience: engineers wiring DI into agents, tools, plugins.</li> <li>Constraints: brief, &lt;10k tokens, actionable.</li> </ul>"},{"location":"llm/#core-concepts","title":"Core Concepts","text":"<ul> <li>Token[T]: typed identifier for a dependency; holds name, type, scope.</li> <li>Scopes: SINGLETON (process), SESSION (user/session), REQUEST (per-call), TRANSIENT.</li> <li>Resolution: <code>get/aget</code> by token or type; <code>@inject</code> for functions.</li> <li>Registrations are immutable: re-registering a token raises.</li> </ul>"},{"location":"llm/#setup-minimal-boilerplate","title":"Setup (Minimal Boilerplate)","text":"<pre><code>from pyinj import Container, Token, Scope\ncontainer = Container()\n\n# Tokens\nHTTP = Token[HttpClient](\"http\", scope=Scope.SINGLETON)\nTOOLRUN = Token[dict](\"toolrun\", scope=Scope.REQUEST)\n\n# Providers\ncontainer.register(TOOLRUN, lambda: {\"invocations\": 0})\n\n# Context-managed async singleton\nfrom contextlib import asynccontextmanager\n@asynccontextmanager\nasync def http_cm():\n    client = HttpClient()\n    try:\n        yield client\n    finally:\n        await client.aclose()\n\ncontainer.register_context_async(HTTP, lambda: http_cm())\n</code></pre>"},{"location":"llm/#per-call-isolation-agentstools","title":"Per-Call Isolation (Agents/Tools)","text":"<pre><code>async def run_tool(container: Container, tool_input: dict) -&gt; dict:\n    async with container.async_request_scope():\n        # REQUEST-scoped values\n        state = container.get(TOOLRUN)\n        state[\"invocations\"] += 1\n        http = await container.aget(HTTP)\n        return await http.post(\"/run\", json=tool_input)\n</code></pre>"},{"location":"llm/#injection-in-handlers","title":"Injection in Handlers","text":"<pre><code>from pyinj.injection import Inject, inject\n\n@inject(container=container)\nasync def handler(payload: dict, http: Inject[HttpClient]):\n    return await http.post(\"/endpoint\", json=payload)\n</code></pre>"},{"location":"llm/#overrides-per-call-or-test","title":"Overrides (Per-Call or Test)","text":"<pre><code>FAKEHTTP = Token(\"http\", HttpClient)\nwith container.use_overrides({FAKEHTTP: FakeHttpClient()}):\n    # only this concurrent context sees the override\n    ...\n</code></pre>"},{"location":"llm/#accepted-patterns","title":"Accepted Patterns","text":"<ul> <li>Use <code>register_context_async/sync</code> for resources with lifecycles.</li> <li>Use <code>async_request_scope/request_scope</code> to delimit per-call lifetimes.</li> <li>Use <code>@inject</code> for handler entry points; avoid sprinkling <code>get()</code> across code.</li> <li>Prefer tokens per logical dependency; avoid string-based tokens.</li> <li>Use <code>override()</code>/<code>use_overrides()</code> in tests or local contexts.</li> </ul>"},{"location":"llm/#anti-patterns-avoid","title":"Anti-Patterns (Avoid)","text":"<ul> <li>Re-registering tokens at runtime (immutable; raises).</li> <li>Storing global singletons in module-level variables\u2014use SINGLETON scope instead.</li> <li>Long-lived REQUEST/SESSION scopes\u2014close them promptly.</li> <li>Mixing sync-only cleanup for async resources\u2014use async cleanup and <code>aclose()</code>.</li> <li>Hidden side-effects in providers\u2014keep providers pure and fast.</li> </ul>"},{"location":"llm/#breaking-patterns-incorrect","title":"Breaking Patterns (Incorrect)","text":"<ul> <li>Registering async providers via <code>register</code> and resolving with <code>get()</code> \u2014 use <code>aget()</code> or <code>register_context_async</code>.</li> <li>Entering async-only resources with sync cleanup (e.g., using <code>with container:</code> for async singletons) \u2014 this raises an error; use <code>await container.aclose()</code>.</li> <li>Accessing request-scoped values outside of any request/session scope \u2014 value won\u2019t exist.</li> </ul>"},{"location":"llm/#failure-modes-diagnostics","title":"Failure Modes &amp; Diagnostics","text":"<ul> <li>Circular dependencies: descriptive error with resolution chain.</li> <li>Provider setup failure: exception propagates (fail-fast); inspect the original error.</li> <li>Missing registration: <code>ResolutionError</code> with guidance.</li> </ul>"},{"location":"llm/#migration-notes","title":"Migration Notes","text":"<ul> <li>Registrations are now immutable; remove any re-registration logic.</li> <li>Switch resource cleanup to <code>register_context_sync/async</code>.</li> </ul>"},{"location":"llm/#checklist-for-llm-integrations","title":"Checklist for LLM Integrations","text":"<ul> <li>[ ] Define tokens per tool/client/config.</li> <li>[ ] Register context-managed singletons for IO clients.</li> <li>[ ] Wrap each tool/agent invocation in a request scope.</li> <li>[ ] Use <code>@inject</code> for handler entry points.</li> <li>[ ] Add overrides for tests and per-call variations.</li> <li>[ ] Ensure async cleanup is awaited in shutdown paths.</li> </ul>"},{"location":"performance/","title":"Performance","text":"<p>PyInj targets O(1) resolution and predictable overhead:</p> <ul> <li>O(1) type lookups via token tables</li> <li>Cached signatures to avoid repeated reflection</li> <li>Lock-free fast path for singletons</li> <li>Minimal per-binding memory footprint</li> </ul> <pre><code># Pseudo-benchmark\n# 1000 services registered\n# ~0.0001ms resolution, ~500 bytes/service\n</code></pre>"},{"location":"releases/","title":"Release Process","text":"<p>Releases are automated with Release Please:</p> <ol> <li>Merge Conventional Commits into <code>main</code>.</li> <li>Release Please opens a release PR with version bump and changelog.</li> <li>Merge the release PR to tag and publish a GitHub Release.</li> <li>The <code>publish.yml</code> workflow builds and publishes to PyPI.</li> </ol> <p>See also the maintainer notes in README and <code>CLAUDE.md</code>.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#type-safe-dependencies","title":"Type-Safe Dependencies","text":"<pre><code>from typing import Protocol, runtime_checkable\nfrom pyinj import Container, Token, Scope\n\n@runtime_checkable\nclass Logger(Protocol):\n    def info(self, message: str) -&gt; None: ...\n\nclass ConsoleLogger:\n    def info(self, message: str) -&gt; None:\n        print(message)\n\ncontainer = Container()\nlogger_token = Token[Logger](\"logger\", protocol=Logger)\ncontainer.register(logger_token, ConsoleLogger, Scope.SINGLETON)\n\nlogger = container.get(logger_token)  # Type: Logger\n</code></pre>"},{"location":"usage/#auto-registration-metaclass","title":"Auto-Registration (metaclass)","text":"<pre><code>from pyinj import Injectable\n\nclass EmailService(metaclass=Injectable):\n    __injectable__ = True\n    __token_name__ = \"email_service\"\n    __scope__ = Scope.SINGLETON\n    def __init__(self, logger: Logger):\n        self.logger = logger\n</code></pre>"},{"location":"usage/#async-providers-and-cleanup","title":"Async Providers and Cleanup","text":"<pre><code>class DatabaseConnection:\n    async def aclose(self) -&gt; None: ...\n\nDB = Token[DatabaseConnection](\"db\")\ncontainer.register(DB, DatabaseConnection, Scope.SINGLETON)\n\nconn = await container.aget(DB)\nawait container.dispose()\n</code></pre>"},{"location":"usage/#circuit-breaker-for-incorrect-sync-cleanup","title":"Circuit Breaker for Incorrect Sync Cleanup","text":"<p>Attempting to use synchronous cleanup (<code>with container:</code>) when an async-only resource is present raises <code>AsyncCleanupRequiredError</code>:</p> <pre><code>from pyinj.exceptions import AsyncCleanupRequiredError\n\n_ = await container.aget(DB)\n\ntry:\n    with container:\n        pass\nexcept AsyncCleanupRequiredError:\n    ...\n</code></pre>"},{"location":"usage/#plain-type-injection-ergonomic-default","title":"Plain Type Injection (ergonomic default)","text":"<p>You can annotate parameters with concrete types and let <code>@inject</code> resolve them. Primitives and builtins like <code>str</code>/<code>int</code> are ignored; user-defined classes and protocols are eligible.</p> <pre><code>from pyinj import inject\n\n@inject\ndef service(logger: Logger, db: Database) -&gt; None:\n    logger.info(\"start\"); db.connect()\n</code></pre>"}]}